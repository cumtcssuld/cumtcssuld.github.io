<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>爱Python, 就用ipython</title>
    <url>/2021/05/24/%E7%88%B1python,%E5%B0%B1%E7%94%A8ipython/</url>
    <content><![CDATA[<blockquote>
<p>本文首发于<a href="https://blog.csdn.net/weixin_43608722/article/details/104297628" target="_blank" rel="noopener">vito的CSDN博客</a>，经作者同意后转载。</p>
</blockquote>
<hr>
<p>本人Python爱好者，学习Python半年。一个月前我偶然接触到IPython，收益匪浅，在这里分享给大家</p>
<hr>
<h3 id="001-什么是IPython"><a href="#001-什么是IPython" class="headerlink" title="001.什么是IPython"></a>001.什么是IPython</h3><p><code>IPython</code>（interactive python），即交互式python，比默认的python shell 好用得多，支持变量自动补全，自动缩进，内置了许多很有用的功能和函数.</p>
<p>使用IPython的方式有两种，<code>IPython shell</code>和<code>jupyter notebook</code>，本文重点介绍jupyter notebook，IPython 被紧密地连接在Jupyter<a href="http://jupyter.org" target="_blank" rel="noopener">(http://jupyter.org)</a> 项目中.</p>
<h3 id="010-为什么选择jupyter-notebook"><a href="#010-为什么选择jupyter-notebook" class="headerlink" title="010.为什么选择jupyter notebook"></a>010.为什么选择jupyter notebook</h3><p>Jupyter Notebook 是 IPython shell 基于浏览器的界面，提供了各种花里胡哨的功能如：内置markdown格式、可视化图像……不仅可以运行python代码，而且作为学习python的笔记本也是不错的选择.你也可以分享你的notebook（<em>.ipynb文件</em>），这样你的小伙伴们也可以在自己的电脑上运行你的notebook代码<br>总而言之，jupyter notebook ==界面友好，功能强大==</p>
<h3 id="011-jupyter-notebook的安装"><a href="#011-jupyter-notebook的安装" class="headerlink" title="011.jupyter notebook的安装"></a>011.jupyter notebook的安装</h3><p>jupyter的安装方法有两种，一种是直接在cmd里输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install jupyter</span><br></pre></td></tr></table></figure>
<p>第二种是通过Anaconda安装，也是我推荐的方式<br>若没有安装Anaconda，先到<a href="https://www.anaconda.com/" target="_blank" rel="noopener">https://www.anaconda.com</a>下载安装包安装Anaconda，Anaconda完成后，在cmd输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install jupyter</span><br></pre></td></tr></table></figure>
<p>这样，juyter就安装成功了</p>
<h3 id="100-jupyter-notebook的启动与文件操作"><a href="#100-jupyter-notebook的启动与文件操作" class="headerlink" title="100.jupyter notebook的启动与文件操作"></a>100.jupyter notebook的启动与文件操作</h3><p>在cmd输入以下命令即可启动jupyter notebook，它将在你的默认浏览器中打开</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter noterbook</span><br></pre></td></tr></table></figure>
<p>打开以后界面如下<br><img src="https://img-blog.csdnimg.cn/20200213164611369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYwODcyMg==,size_16,color_FFFFFF,t_70" alt=""></p>
<ul>
<li><strong>jupyter notebook默认的路径是管理员Adminstrator所在文件夹</strong>，默认路径可以修改，在这里不作介绍 </li>
<li><strong>jupyter的文件操作可以浏览器界面和文件夹面同时操作</strong>，也就是说你在jupyter文件夹下面新建一个文件，浏览器界面会同时显示。当你需要打开一个<code>.ipynb</code>文件，可以将.ipynb直接复制到jupyter的文件夹下面.当然你也可以点击<code>Upload</code>来选择你要上传的jupyter notebook的文件</li>
<li>点击<code>Logout</code>或者关闭cmd和浏览器即可退出jupyter</li>
</ul>
<h3 id="101-jupyter-notebook的界面操作和常用快捷键"><a href="#101-jupyter-notebook的界面操作和常用快捷键" class="headerlink" title="101.jupyter notebook的界面操作和常用快捷键"></a>101.jupyter notebook的界面操作和常用快捷键</h3><p>俗话说得好，磨刀不误砍柴工，熟悉了jupyter的操作和快捷键，使用IPython自然得心应手<br>点击<code>New</code>出现下拉框，在点击Python 3(这里的python 3是Anaconda的python解释器)就可以创建一个<code>.ipynb</code>文件<br><img src="https://img-blog.csdnimg.cn/20200213170844651.png"   width="30%"><img src="https://img-blog.csdnimg.cn/20200213172110650.png"   width="70%"></p>
<ul>
<li><p>点击上面<code>Untitled</code>可以修改文件名</p>
</li>
<li><p>点击<code>代码</code>出现下拉框，可以实现<code>markdown</code>格式和代码格式的转换</p>
</li>
<li><p>点击<code>Insert</code>可以选择向前或向后插入代码行</p>
</li>
<li><p>jupyter notebook有两种模式，一种是<code>编辑模式</code>,按<code>Enter</code>进入此模式，此时代码行外框呈现出<code>绿色</code>，可以对代码行内部进行缩进、删除、运行等操作<br>另一种是<code>命令模式</code>，若进入编辑模式，则按<code>Esc</code>进入命令模式，此时代码行外框呈现出<code>蓝色</code></p>
</li>
<li><p>jupyter常用快捷键</p>
<ul>
<li><p>编辑模式</p>
<ul>
<li><strong>Shift-Enter</strong>: 运行本单元，选中下一代码行（若下面没有单元，则新建一个单元）</li>
<li><strong>Ctrl-Enter</strong>: 运行本单元</li>
<li><strong>Alt-Enter</strong>: 运行本单元，在下面插入一单元</li>
</ul>
</li>
<li><p>命令模式</p>
<ul>
<li><strong>数字1~6</strong>: 设定1到6级标题</li>
<li><strong>A</strong>: 在上方插入新单元</li>
<li><strong>B</strong>: 在下方插入新单元</li>
<li><strong>连续两下D</strong>: 删除选中的单元</li>
<li><strong>Shift-K</strong>: 扩大选中上方单元</li>
<li><strong>Shift-J</strong>: 扩大选中下方单元</li>
<li><strong>shift-M</strong>：合并单元</li>
</ul>
<p>更多快捷键等待你的探索</p>
<h3 id="110-IPython-的获取与探索功能"><a href="#110-IPython-的获取与探索功能" class="headerlink" title="110.IPython 的获取与探索功能"></a>110.IPython 的获取与探索功能</h3><p>IPython 和 Jupyter 最大的优势之一就是能方便我们搜索函数和文档的功能，帮助我们高效完成工作</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>使用<code>?</code>来获取文档<br>   我们传统的获取python文档是使用help()<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;help(list)</span><br><span class="line">Help on <span class="class"><span class="keyword">class</span> <span class="title">list</span> <span class="title">in</span> <span class="title">module</span> <span class="title">builtins</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span><span class="params">(object)</span></span></span><br><span class="line"><span class="class"> |  <span class="title">list</span><span class="params">(iterable=<span class="params">()</span>, /)</span></span></span><br><span class="line"><span class="class"> |  </span></span><br><span class="line"><span class="class"> |  <span class="title">Built</span>-<span class="title">in</span> <span class="title">mutable</span> <span class="title">sequence</span>.</span></span><br><span class="line"><span class="class"> |  </span></span><br><span class="line"> |  If no argument is given, the constructor creates a new empty list.</span><br><span class="line"> |  The argument must be an iterable <span class="keyword">if</span> specified.</span><br><span class="line"> |  </span><br><span class="line"> |  Methods defined here:</span><br><span class="line"> |  </span><br><span class="line"> |  __add__(self, value, /)</span><br><span class="line"> |      Return self+value.</span><br><span class="line">    (………………………………………………………………)</span><br></pre></td></tr></table></figure>
在IPython中我们可以使用<code>list？</code>,显示出的信息更加简明扼要</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In[1]:list?</span><br><span class="line">Init signature: list(iterable=(), /)</span><br><span class="line">Docstring:     </span><br><span class="line">Built-<span class="keyword">in</span> mutable sequence.</span><br><span class="line"></span><br><span class="line">If no argument <span class="keyword">is</span> given, the constructor creates a new empty list.</span><br><span class="line">The argument must be an iterable <span class="keyword">if</span> specified.</span><br><span class="line">Type:           type</span><br><span class="line">Subclasses:     _HashedSeq, StackSummary, SList, _ImmutableLineList, FormattedText, NodeList, _ExplodedList, Stack, _Accumulator, _ymd, ...</span><br></pre></td></tr></table></figure>
<p><code>?</code>也同样适应于<code>对象的方法</code>，甚至于对象本身</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">2</span>]: L=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [3]: L.append?</span><br><span class="line">Signature: L.append(object, /)</span><br><span class="line">Docstring: Append object to the end of the list.</span><br><span class="line">Type:      builtin_function_or_method</span><br><span class="line"></span><br><span class="line">In [4]: L?</span><br><span class="line">Type:        list</span><br><span class="line">String form: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">Length:      <span class="number">3</span></span><br><span class="line">Docstring:</span><br><span class="line">Built-<span class="keyword">in</span> mutable sequence.</span><br><span class="line"></span><br><span class="line">If no argument <span class="keyword">is</span> given, the constructor creates a new empty list.</span><br><span class="line">The argument must be an iterable <span class="keyword">if</span> specified.</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>TAB</code>探索模块<br>  L后面加上<code>.</code>再按<code>Tab</code>键即可看到该对象的所有方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: L.</span><br><span class="line">           append() count    insert   reverse</span><br><span class="line">           clear    extend   pop      sort</span><br><span class="line">           copy     index    remove</span><br></pre></td></tr></table></figure>

<p>   也可以输入方法的前面几个字母以缩小搜索范围，若只有一个选项满足搜索条件，则Tab<strong>自动补全</strong>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">6</span>]: L.c</span><br><span class="line">            clear()</span><br><span class="line">            copy()</span><br><span class="line">            count()</span><br></pre></td></tr></table></figure>
<p>同样的道理我们也可以应用在导入模块时</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">7</span>]: <span class="keyword">import</span> ma</span><br><span class="line">                  macpath    man        math</span><br><span class="line">                  mailbox    markupsafe matplotlib</span><br><span class="line">                  mailcap    marshal</span><br></pre></td></tr></table></figure>
<p>熟练使用Tab自动补全可以有效提高工作效率</p>
<h3 id="111-IPython的魔法命令"><a href="#111-IPython的魔法命令" class="headerlink" title="111.IPython的魔法命令"></a>111.IPython的魔法命令</h3><p>IPython的魔法命令显著地将IPython与pyhton区别开来，也彰显了Interactive的内涵<br>魔法命令分为行魔法(line magic)和单元魔法(cell magic)</p>
<ul>
<li>行魔法：前缀是一个<code>%</code>,只作用于单行</li>
<li>单元魔法：前缀是<code>%%</code>，作用于整个单元,方便多行输入<br>常用的魔法命令有<code>%paste</code>、<code>%cpaste</code>、<code>%run</code>、<code>%timeit</code></li>
</ul>
<p>这里我只介绍%timeit,其他魔法命令可以使用<code>%lsmagic</code>和<code>?</code>探索<br>%timeit，它会自动计算接下来一行的 Python 语句的执行时<br>间。例如，我们可能想了解生成列表所用的时间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">8</span>]: %timeit L = [n ** <span class="number">2</span> <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1000</span>)]</span><br><span class="line"><span class="number">375</span> µs ± <span class="number">3.07</span> µs per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">1000</span> loops each)</span><br></pre></td></tr></table></figure>

<p>%timeit 的好处是，它会自动多次执行简短的命令，以获得更稳定的结果。对于多行语句，可以加入第二个 % 符号将其转变成单元魔法，以处理多行输入。例如，下面是 for 循环的同等结构：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In[<span class="number">9</span>]: %%timeit</span><br><span class="line">    ...: L=[]</span><br><span class="line">    ...: <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    ...:     L.append(i**<span class="number">2</span>)</span><br><span class="line">    ...:</span><br><span class="line"><span class="number">414</span> µs ± <span class="number">5.02</span> µs per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">1000</span> loops each)</span><br></pre></td></tr></table></figure>
<p>可以看出使用range()生成列表比用for循环快一些</p>
<hr>
<blockquote>
<p>学习IPython网站：<br><a href="http://ipython.org" target="_blank" rel="noopener">http://ipython.org</a><br><a href="http://github.com/ipython/ipython/wiki/A-gallery-of-interestingIPython-Notebooks/" target="_blank" rel="noopener">http://github.com/ipython/ipython/wiki/A-gallery-of-interestingIPython-Notebooks/</a><br><a href="http://nbviewer.ipython.org/" target="_blank" rel="noopener">http://nbviewer.ipython.org</a></p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构笔记（第六章）</title>
    <url>/2021/05/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="第六章-集合与字典"><a href="#第六章-集合与字典" class="headerlink" title="第六章 集合与字典"></a>第六章 集合与字典</h1><p>这部分只讲了散列</p>
<h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p><strong>词典(Dictionary)的抽象数据类型</strong></p>
<p>在计算科学中把词典当作一种抽象数据类型。<br>在讨论词典抽象数据类型时，把词典定义为 &lt;名字-属性&gt;对的集合。</p>
<h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><p>若能在待查记录的关键字值和它的存储位置之间建立一个确定的对应关系f,则查找时不必再进行关键字值间的比较。这个对应关系f 称为哈希（Hash）函数,  按这个思想建立的表为哈希表（也称散列表）.</p>
<p><strong>哈希方法（建表与查找）</strong><br>      选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放；查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关键码进行比较，确定查找是否成功。<br><strong>冲突</strong><br>      通常关键码的集合比哈希地址集合大得多，因而经过哈希函数变换后，可能将不同的关键码映射到同一个哈希地址上，这种现象称为冲突。</p>
<p>所以对于散列方法, 需要讨论以下两个问题：<br>1）构造好的哈希函数<br>（a）所选函数尽可能简单，以便提高转换速度；<br>（b）所选函数对关键码计算出的地址，应在哈希地址集中大致均匀分布，以减少空间浪费。</p>
<p>2）制定一个好的解决冲突的方案<br>   查找时，如果从哈希函数计算出的地址中查不到关键码，则应当依据解决冲突的规则，有规律地查询其它相关单元。</p>
<h3 id="二、构造哈希函数的基本方法"><a href="#二、构造哈希函数的基本方法" class="headerlink" title="二、构造哈希函数的基本方法"></a>二、构造哈希函数的基本方法</h3><p><strong>基本要求</strong></p>
<p>设关键字集K中有n个关键字，哈希表长为m，即哈希表地址集为[0,m-1]，则哈希函数H应满足：</p>
<ol>
<li><p>对任意ki∈K，i=1,2,…,n，有0≤H(ki)≤m-1；</p>
</li>
<li><p>对任意ki∈K，H(ki)取[0,m-1]中任一值的概率相等</p>
</li>
</ol>
<p><strong>常用哈希构造方法</strong></p>
<p>直接定址法<br>除留余数法<br>乘余取整法<br>数字分析法<br>平方取中法<br>折叠法<br>随机数法 </p>
<p><strong>1</strong>、<strong>直接定址法</strong></p>
<p><strong>举例</strong></p>
<p>关键码集合为{100，300，500，700，800，900}，选取哈希函数为Hash(key)=key/100，则存储结构（哈希表）如下：</p>
<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200616164615277-963473401.png" alt=""></p>
<p>此方法所得地址集合和关键字集合的大小相同，因此对于不同的关键字不会发生冲突，但实际中使用这种哈希函数的情况很少。</p>
<p><strong>2</strong>、<strong>除留余数法</strong></p>
<p>取关键字被某个不大于哈希表表长 m 的数 p 除后所得余数为哈希地址。一般情况下， p≤m且为质数</p>
<p><strong>举例</strong></p>
<p>设有一组关键字如下：（19,14,23,01,68,20,84,27,55,11,10,79），试用除留余数法设计哈希函数</p>
<p>可取p为13，即令H(key)=key%13 。</p>
<p><strong>为什么要对 p 加限制？</strong></p>
<p>例：给定一组关键字为: 12, 39, 18, 24, 33, 21，若取 p=9, 则他们对应的哈希函数值将为: 3, 3, 0, 6, 6, 3</p>
<p>可见，若 p 中含质因子 3, 则所有含质因子 3 的关键字均映射到“3 的倍数”的地址上，从而增加了“冲突”的可能。</p>
<p><strong>3、数字分析法</strong></p>
<p>若关键字是ｒ进制数，且可预知全部可能出现的关键字值，则可取关键字中若干位构成哈希地址。</p>
<p><strong>举例</strong></p>
<p>设要在长为100的哈希地址空间中保存80个数据元素，部分关键字值如下，试用数字分析法设计哈希函数</p>
<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200616164649545-1056964307.png" alt=""></p>
<p>n数字分析法仅适用于事先明确知道表中所有关键码每一位数值的分布情况，它完全依赖于关键码集合。如果换一个关键码集合，选择哪几位要重新决定。</p>
<p><strong>4、平方取中法</strong></p>
<p>若关键字较短，则可先对关键字值求平方，然后取运算结果的中间几位为哈希地址</p>
<p><strong>举例</strong></p>
<p>　　设某计算机语言中标识符定义为一个字母或一个字母加一个数字，又知字母、数字的机内码（以八进制数表示）如下：</p>
<p>　　Ａ：０１　Ｂ：０２　Ｃ：０３　…　Ｚ：３２</p>
<p>　　０：６０　１：６１　２：６２　…　９：７１</p>
<p>现以标识符的机内码为关键字，构造哈希表，试用平方取中法设计哈希函数。</p>
<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200616164717530-793508365.png" alt=""></p>
<p><strong>4、折叠法</strong></p>
<p>将关键字值分割成位数相同的几个部分，然后取这几部分的叠加和（舍去进位）作为哈希地址。</p>
<p>移位叠加</p>
<p>　　将各部分按最低位对齐，然后相加；</p>
<p>间界叠加</p>
<p>　　将关键字值从一端向另一端沿分界线来回折迭，然后对齐相加。</p>
<p><strong>举例</strong></p>
<p>设某图书馆的馆藏图书不足10000种，现欲以国际标准图书编号为关键字构造哈希表，试用折叠法设计哈希函数。</p>
<p>移位叠加</p>
<p>设有编号：0-442-20586-4，即：0442205864，由低位向高位，每四位一折，可得三段，再将各部分按最低位对齐后相加，并舍去进位，即得对应的哈希地址。</p>
<p>间界叠加</p>
<p>设有编号：0-442-20586-4，即：0442205864，由低位向高位，每四位为一段，各段沿分割界来回折迭后对齐相加，舍去进位即得哈希地址。</p>
<p>一般当关键码的位数很多，而且关键码每一位上数字的分布大致比较均匀时，可用这种方法得到散列地址。以上介绍了几种常用的散列函数。在实际工作中应根据关键码的特点，选用适当的方法。有人曾用“轮盘赌”的统计分析方法对它们进行了模拟分析，结论是平方取中法最接近于“随机化”。</p>
<h3 id="三、处理冲突的基本方法"><a href="#三、处理冲突的基本方法" class="headerlink" title="三、处理冲突的基本方法"></a>三、处理冲突的基本方法</h3><p>处理冲突是指对于一个待插入哈希表的数据元素，若按给定的哈希函数求得的哈希地址已被占用，则按一定规则求下一哈希地址，如此重复，直至找到一个可用的地址以保存该元素。</p>
<p>开放定址法（开地址法）<br>链地址法（拉链法）<br>再哈希法（双哈希函数法）<br>建立一个公共溢出区 </p>
<p><strong>1、开放定址法</strong></p>
<p><strong>方法</strong></p>
<p>令Hi=(H(key)+di)%m，i=1,2,…,m-1，其中H(key)为哈希函数，m为哈希表长，di为增量序列。</p>
<p>若取di=1,2,3,…,m-1，则称线性探测再散列；</p>
<p>若取di=12,-12,22,-22…,±k2，则称二次探测再散列；</p>
<p>若取di=伪随机数序列，则称伪随机探测再散列。</p>
<p>平方探查法是一种较好的处理冲突的方法，可以避免出现堆积问题。它的缺点是不能探查到哈希表上的所有单元，但至少能探查到一半单元。</p>
<p><strong>举例</strong><br>　　设有一组关键字如下：(67,84,18,26,34,28)，哈希函数为H(key)=key%7，用线性探测再散列法处理冲突，试画出哈希表存储结构示意图。</p>
<p>已知：</p>
<p>哈希函数：H(key)=key%7</p>
<p>有冲突时：Hi=(H(key)+di)%7   其中：di=1,2,3,4,5,6</p>
<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200616164751453-1658178094.png" alt=""></p>
<p>线性探测法的优点：只要哈希表未被填满，保证能找到一个空地址单元存放有冲突的元素；<br>线性探测法的缺点：线性探测容易出现在相邻的哈希地址上“堆积”的问题。<br>解决方案：可采用二次探测法或伪随机探测法，以改善“堆积”问题。 </p>
<p>二次探查法是一种较好的处理冲突的方法</p>
<p>优点：可以避免出现堆积问题。<br>缺点：不能探查到哈希表上的所有单元，但至少能探查到一半单元<br>可证明：当表长m为质数且表的装载因子不超过0.5时，新表项插入时，任何位置不会被探查两次。<br>注意二次探查表长 m 必为素数(质数)（如: 7,  11, 13,17，19, 23, … 等）。</p>
<p>散列表的装填因子＝表中填入的记录数n/表长m</p>
<p><strong>2、再哈希法（双哈希函数法）</strong></p>
<p>Hi=RHi(key)       i=1, 2,  …，k<br>RHi均是不同的哈希函数，当产生冲突时就计算另一个哈希函数，直到冲突不再发生。<br>优点：不易产生聚集；<br>缺点：增加了计算时间。</p>
<p><strong>3、链地址法（开散列）</strong></p>
<p>将所有按给定的哈希函数求得的哈希地址相同的关键字存储在同一线性链表中，且使链表按关键字有序。</p>
<p><strong>举例</strong><br>设有一组关键字如下：(67,84,18,26,34,28)，哈希函数为H(key)=key%7，用链地址法处理冲突，哈希表存储结构</p>
<p>哈希函数：H(key)=key%7    有冲突时：在对应链表中插入新结点</p>
<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200616164838718-1003480619.png" alt=""></p>
<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200616164850313-61195599.png" alt=""></p>
<p><strong>4、公共溢出区法</strong></p>
<p>若关键字所对应的哈希地址已被占用，则保存到公共溢出区中。</p>
<p>设有一组关键字如下：(67,84,18,26,34,28)，哈希函数为H(key)=key%7，用公共溢出区法处理冲突，试画出哈希表存储结构示意图。</p>
<p>哈希函数：H(key)=key%7</p>
<p>有冲突时：保存到公共溢出区</p>
<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200616164922931-1574804304.png" alt=""></p>
<p>开散列和闭散列，这两种方法的不同之处在于：开散列法把发生冲突的关键码存储在散列表主表之外，而闭散列法把发生冲突的关键码存储在表中另一个槽内。</p>
<p>开散列法优于闭散列法；在散列函数中，用除留余数法作散列函数优于其它类型的散列函数，最差的是折叠法。</p>
<h3 id="四、在哈希表中查找元素"><a href="#四、在哈希表中查找元素" class="headerlink" title="四、在哈希表中查找元素"></a>四、在哈希表中查找元素</h3><p>在哈希表中查找数据元素的过程与将数据元素插入哈希表的过程基本一致，即：</p>
<p>根据待查关键字值，按给定的哈希函数，求哈希地址；</p>
<p>若该地址上无数据元素，则查找失败；</p>
<p>若该地址上有数据元素，则进行关键字值间的比较。若相等，则查找成功；若不等，则按冲突处理方法求下一可能的存储地址。</p>
<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200616164949182-2050846012.png" alt=""></p>
<p>虽然哈希表在关键字值与存储位置间建立了映象，但由于冲突的存在，查找时仍需进行关键字之间的比较，因此仍以查找成功时的平均查找长度和查找不成功时的比较次数作为衡量查找效率的依据。</p>
<p>ASL succ=搜索到表中已有元素的平均探查次数<br>ASL unsucc=表中所有可能散列到的位置上要插入新元素时为找到空桶的探查次数的平均值。</p>
<p><strong>哈希表的查找及分析</strong></p>
<p>由于冲突的存在，哈希法仍需进行关键字比较， 因此仍需用平均查找长度来评价哈希法的查找性能。<br>哈希法中影响关键字比较次数的因素有三个：<strong>哈希函数</strong>、 <strong>处理冲突的方法</strong>以及<strong>哈希表的装填因子</strong>。</p>
<p>哈希表的装填因子表明了表中的装满程度。越大，说明表越满，再插入新元素时发生冲突的可能性就越大。越小，发生冲突的可能就越小，而存储空间的利用率也就越低。<br>散列表的平均查找长度是装填因子α的函数，不直接依赖于 n 或 m。在很多情况下，散列表的空间都比查找集合大，此时虽然浪费了一定的空间，但换来的是查找效率。<br>不论表的长度有多大，总能选择一个合适的装填因子，以把平均查找长度限制在一定范围内。</p>
]]></content>
      <categories>
        <category>课内学习</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构笔记（第八章）</title>
    <url>/2021/05/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="第八章-图"><a href="#第八章-图" class="headerlink" title="第八章 图"></a>第八章 图</h1><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><p><strong>图定义：</strong></p>
<p>图是由顶点集合及顶点间的关系 集合组成的一种数据结构： </p>
<p>Graph＝( V, E )    </p>
<p>V = { x | x  属于某个数据对象} 是顶点的有穷非空集 合；  </p>
<p>E = {(x,y)|x,y 属于 V }或者{&lt;x, y&gt; | x, y属于 V &amp;&amp; Path (x, y)}   是顶点之间关系的有穷集合，也叫做边(edge)集合。 </p>
<p>Path (x, y)表示从 x 到 y 的一条单向通路, 它是有方向的。</p>
<p><strong>有向图:</strong></p>
<p>图G中的每条边都是有方向的； </p>
<p><strong>无向图:</strong></p>
<p>图G中的每条边都是无方向的；</p>
<p><strong>完全图</strong></p>
<p>图G任意两个顶点都有一条边相连接</p>
<p>若有 n 个顶点的无向图有 n(n-1)/2 条边, 则此图为 完全无向图。</p>
<p>有 n 个顶点的有向图有n(n-1) 条边, 则此图为完全有向图。 </p>
<p><strong>子图</strong> </p>
<p>设有两个图G＝(V, E) 和G’＝(V’, E’)。若V ‘含于V 且E’含于E, 则称图G’是图G的子图。 </p>
<p><strong>权</strong> </p>
<p>某些图的边具有与它相关的数, 称之为权。这种带 权图叫做网络。 </p>
<p><strong>邻接顶点</strong> </p>
<p>如果 (u, v) 是 E(G) 中的一条边， 则称 u 与 v 互为邻接顶点。 </p>
<p><strong>顶点的度</strong> </p>
<p>一个顶点v的度是与它相关联的边 的条数。记作TD(v)。在有向图中, 顶点的度 等于该顶点的入度与出度之和。</p>
<p>顶点 v 的入度是以 v 为终点的有向边的条数, 记作 ID(v);  </p>
<p>顶点 v 的出度是以 v 为始点的有向边的条数, 记作 OD(v)。 </p>
<p><strong>路径</strong> </p>
<p>在图 G＝(V, E) 中, 若从顶点 vi 出发, 沿一些 边经过一些顶点 vp1, vp2, …, vpm，到达顶点vj。 则称顶点序列 (vi  vp1 vp2 … vpm  vj) 为从顶点vi 到顶点 vj 的路径。</p>
<p>经过的边(vi, vp1)、(vp1, vp2)、..、(vpm, vj) 是 属于E的边。 </p>
<p><strong>路径长度</strong></p>
<p>非带权图的路径长度是指此路径 上边的条数。带权图的路径长度是指路径 上各边的权之和。 </p>
<p><strong>简单路径</strong>  </p>
<p>若路径上各顶点 v1, v2, …, vm 均不 互相重复, 则称这样的路径为简单 路径。</p>
<p><strong>回路</strong>    </p>
<p>若路径上第一个顶点 v1 与最后一 个顶点vm 重合, 则称这样的路径为回路 或环。</p>
<p><strong>连通图与连通分量</strong>  </p>
<p>在无向图中, 若从顶点v1到顶点v2有路径, 则称顶点v1与 v2是连通的。如果图中任意一对顶点都是连通的, 则称 此图是连通图。非连通图的极大连通子图叫做连通分量。</p>
<p><strong>强连通图与强连通分量</strong></p>
<p>在有向图中, 若对于每一对顶点vi和vj, 都存在一条从vi 到vj和从vj到vi的路径, 则称此图是强连通图。非强连通图的极大强连通子图叫做强连通分量。</p>
<p><strong>生成树</strong>   </p>
<p>一个连通图的生成树是其极小连通子图， 在 n 个顶点的情形下，有 n-1 条边。 </p>
<p>两类图形不在本章讨论之列：有自环的图，多重图。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//图的抽象数据类型 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> &#123;</span> <span class="comment">//对象: 由一个顶点的非空集合和一个边集合构成 //每条边由一个顶点对来表示。 </span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">Graph();   <span class="comment">//建立一个空的图    </span></span><br><span class="line">~Graph(); </span><br><span class="line"><span class="function">virturl <span class="keyword">void</span> <span class="title">insertVertex</span> <span class="params">(<span class="keyword">const</span> T&amp; vertex)</span></span>;    <span class="comment">//插入一个顶点vertex, 该顶点暂时没有入边 virtual void removeVertex (int v);    //在图中删除顶点v和所有关联到它的边    </span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">insertEdge</span> <span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2, <span class="keyword">int</span> weight)</span></span>; <span class="comment">//在图中插入一条边(v1, v2, w) </span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">removeEdge</span> <span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span>;    <span class="comment">//在图中删去边(v1,v2)    </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;<span class="comment">//若图中没有顶点, 则返回true, 否则false    </span></span><br><span class="line"><span class="function">T <span class="title">getWeight</span> <span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span>; <span class="comment">//函数返回边 (v1,v2) 的权值    </span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getFirstNeighbor</span> <span class="params">(<span class="keyword">int</span> v)</span></span>;    <span class="comment">//给出顶点 v 第一个邻接顶点的位置    </span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getNextNeighbor</span> <span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>;<span class="comment">//给出顶点 v 的某邻接顶点 w 的下一个邻接顶点   </span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> T <span class="title">getValue</span><span class="params">(<span class="keyword">int</span> i)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> E <span class="title">getWeight</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>;    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOfVertices</span><span class="params">()</span></span>;    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOfEdges</span><span class="params">()</span></span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h2 id="图的存储表示"><a href="#图的存储表示" class="headerlink" title="图的存储表示"></a>图的存储表示</h2><p>图的特点：非线性结构（m :n ） </p>
<p>顺序存储结构：</p>
<p>1）（多个顶点，无序可言） </p>
<p>2）但可用二维数组描述元素间关系。（ 邻接矩阵）</p>
<p>链式存储结构：可用多重链表</p>
<p>邻接表</p>
<p>邻接多重表 </p>
<p>十字链表 </p>
<p>重点介绍： 邻接矩阵(数组)表示法 邻接表(链式)表示法 </p>
<p><strong>邻接矩阵 (Adjacency Matrix)</strong> </p>
<p>表示图： 一个顶点表（记录各个顶点信息） 一个邻接矩阵（表示各个顶点之间关系） </p>
<p>设图 A = (V, E) 有 n 个顶点，则图的邻接矩阵是一个二维数组  A.Edge[n][n]，定义为： </p>
<p>A.Edge[i] [j]= 1 ,如果&lt;i,j&gt;∈E 或者（i,j）∈E         </p>
<p>否则A.Edge[i] [j]=0</p>
<p>分析1：无向图的邻接矩阵是对称的； </p>
<p>分析2：顶点i 的度＝第 i 行 (列) 中1 的个数； </p>
<p>特别：完全图的邻接矩阵中，对角元素为0，其余全1。</p>
<p>注：在有向图的邻接矩阵中，第i行含义：以结点vi为尾的弧(即出度边）；第i列含义：以结点vi为头的弧(即入度边）。 </p>
<p>分析1：有向图的邻接矩阵可能是不对称的。 </p>
<p>分析2：顶点的出度=第i行元素之和，OD( Vi )= ∑ A.Edge[ i ] [j ]                  </p>
<p>​              顶点的入度=第i列元素之和。ID( Vi )=∑  A.Edge[ j ] [i ]                   </p>
<p>​              顶点的度=第i行元素之和+第i列元素之和,   </p>
<p>网络的邻接矩阵 </p>
<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200617102707655-2094219092.png" alt=""></p>
<p> <strong>图的模板基类</strong>   </p>
<p> 在模板类定义中顶点数据类型是变量，边 的权值是变量。</p>
<p>因此数据类型参数表 &lt;class T, class E&gt; 中， T是顶点数据的类型，E是边上所附数据的 类型。</p>
<p>这个模板基类是按照最复杂的情况（即带 权无向图）来定义的，如果需要使用非带 权图，可改为 &lt; class  T&gt;。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//图的模板基类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">E</span>&gt; <span class="title">class</span> <span class="title">Graph</span> &#123;</span>       <span class="comment">//图的类定义</span></span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">T *VerticesList;    <span class="comment">//顶点表     </span></span><br><span class="line">E **Edge;    <span class="comment">//邻接矩阵 </span></span><br><span class="line"><span class="keyword">protected</span>:     </span><br><span class="line"><span class="keyword">int</span> maxVertices;      <span class="comment">//图中最大顶点数     </span></span><br><span class="line"><span class="keyword">int</span> numVertices;                       <span class="comment">//当前顶点数    </span></span><br><span class="line"><span class="keyword">int</span> numEdges;       <span class="comment">//当前边数     </span></span><br><span class="line"><span class="comment">//GraphKind kind             //图的种类(这样不用分类定义)     </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getVertexPos</span> <span class="params">(T vertex)</span></span>; <span class="comment">//给出顶点vertex在图中位置 </span></span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//相关操作…… </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//用邻接矩阵表示的图的类定义 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Graphmtx</span> :</span> <span class="keyword">public</span> Graph&lt;T, E&gt; </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span> &gt;&gt; ( istream&amp; in,   Graphmtx&lt;T, E&gt;&amp; G);   <span class="comment">//输入 </span></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; out, Graphmtx&lt;T, E&gt;&amp; G);  <span class="comment">//输出 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:     </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getVertexPos</span> <span class="params">(T vertex)</span></span></span><br><span class="line"><span class="function"></span>&#123;        <span class="comment">//给出顶点vertex在图中的位置         </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numVertices; i++)          </span><br><span class="line"><span class="keyword">if</span> (VerticesList[i] == Vertex) <span class="keyword">return</span> i;      </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;   &#125;; </span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">    Graphmtx (<span class="keyword">int</span> sz = DefaultVertices);    <span class="comment">//构造函数     </span></span><br><span class="line">    ～Graphmtx ()          <span class="comment">//析构函数         </span></span><br><span class="line">  &#123; <span class="keyword">delete</span> [ ]VerticesList;  <span class="keyword">delete</span> [ ]Edge; &#125;     </span><br><span class="line">  <span class="function">T <span class="title">getValue</span> <span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;         <span class="comment">//取顶点 i 的值, i 不合理返回0       </span></span><br><span class="line">  <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt;= numVertices ? VerticesList[i] : <span class="literal">NULL</span>;      &#125;     </span><br><span class="line">  <span class="function">E <span class="title">getWeight</span> <span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;  <span class="comment">//取边(v1,v2)上权值       </span></span><br><span class="line">  <span class="keyword">return</span> v1 != <span class="number">-1</span> &amp;&amp; v2 != <span class="number">-1</span> ? Edge[v1][v2] : <span class="number">0</span>;     &#125;     </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getFirstNeighbor</span> <span class="params">(<span class="keyword">int</span> v)</span></span>;       <span class="comment">//取顶点 v 的第一个邻接顶点 </span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">getNextNeighbor</span> <span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>;        <span class="comment">//取 v 的邻接顶点 w 的下一邻接顶点    </span></span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">insertVertex</span> <span class="params">(<span class="keyword">const</span> T vertex)</span></span>;        <span class="comment">//插入顶点vertex     </span></span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">insertEdge</span> <span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2, E cost)</span></span>;       <span class="comment">//插入边(v1, v2),权值为cost     </span></span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">removeVertex</span> <span class="params">(<span class="keyword">int</span> v)</span></span>;       <span class="comment">//删去顶点 v 和所有与它相关联的边     </span></span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">removeEdge</span> <span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span>;       <span class="comment">//在图中删去边(v1,v2) &#125;; </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">E</span>&gt; <span class="title">Graphmtx</span>&lt;T, E&gt;:</span>:Graphmtx (<span class="keyword">int</span> sz) &#123;      <span class="comment">//构造函数     maxVertices = sz;       </span></span><br><span class="line">numVertices = <span class="number">0</span>;  </span><br><span class="line">numEdges = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">int</span> i, j;  </span><br><span class="line">VerticesList = <span class="keyword">new</span> T[maxVertices];  <span class="comment">//创建顶点表     </span></span><br><span class="line">Edge = (E **) <span class="keyword">new</span> E *[maxVertices]; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; maxVertices; i++)      </span><br><span class="line">Edge[i] = <span class="keyword">new</span> E[maxVertices];   <span class="comment">//邻接矩阵     </span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; maxVertices; i++)        <span class="comment">//矩阵初始化      </span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; maxVertices; j++)    </span><br><span class="line">Edge[i][j] = (i == j) ? <span class="number">0</span> : maxWeight; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">E</span>&gt; <span class="title">int</span> <span class="title">Graphmtx</span>&lt;T, E&gt;:</span>:getFirstNeighbor (<span class="keyword">int</span> v) &#123; </span><br><span class="line"><span class="comment">//给出顶点位置为v的第一个邻接顶点的位置,如果找不到, 则函数返回-1     </span></span><br><span class="line"><span class="keyword">if</span> (v != <span class="number">-1</span>) &#123;      </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; numVertices; col++)           </span><br><span class="line"><span class="keyword">if</span> (Edge[v][col] &amp;&amp; Edge[v][col] &lt; maxWeight)                   </span><br><span class="line"><span class="keyword">return</span> col;     &#125;     </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; &#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">Graphmtx</span>&lt;T, E&gt;:</span>:getNextNeighbor (<span class="keyword">int</span> v, <span class="keyword">int</span> w) &#123; </span><br><span class="line"><span class="comment">//给出顶点 v 的某邻接顶点 w 的下一个邻接顶点      </span></span><br><span class="line"><span class="keyword">if</span> (v != <span class="number">-1</span> &amp;&amp; w != <span class="number">-1</span>) &#123;     </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col = w+<span class="number">1</span>; col &lt; numVertices; col++)            </span><br><span class="line"><span class="keyword">if</span> (Edge[v][col] &amp;&amp; Edge[v][col] &lt; maxWeight)                 </span><br><span class="line"><span class="keyword">return</span> col;      &#125;    </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; &#125;;</span><br></pre></td></tr></table></figure>

<p>邻接矩阵法优点：容易实现图的操作，如：求某顶点的度、判断 顶点之间是否有边（弧）、找顶点的邻接点等等。                 </p>
<p>邻接矩阵法缺点：n个顶点需要 n*n 个单元存储边(弧);空间效率 为O(n^2)。 对稀疏图而言尤其浪费空间。</p>
<p>为此需把邻接矩阵的各行分别组织为一个单链表 </p>
<p><strong>图的邻接表存储结构</strong></p>
<p>在邻接表表示法中</p>
<p>•顶点：通常按编号顺序将顶点数据存储在一维数组中 </p>
<p>•关联同一顶点的边：用单链表存储</p>
<p>无向图的邻接表 </p>
<p>顶点的度：统计某顶点对应边链表中结点个数。</p>
<p>某条边(vi, vj)在邻接表中有两个边结点，分别 在第 i 个顶点和第 j 个顶点对应的边链表中。 </p>
<p>有向图的邻接表和逆邻接表 </p>
<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200617102746243-301822766.png" alt=""></p>
<p>特性总结：</p>
<p>图中有 n 个顶点，e 条边， </p>
<p>邻接表表示无向图时，需要 n 个顶点结点，2e 个边结点；</p>
<p>用邻接表表示有向图时，若不考虑逆邻接表，只需 n 个顶点结点，e 个边结点。</p>
<p>当 e 远远小于 n2 时，可以节省大量的存储空 间。  </p>
<p>怎样计算无向图顶点的度？  </p>
<p>  TD(Vi) =单链表中链接的结点个数</p>
<p>怎样计算有向图顶点的出度？ </p>
<p>   OD(Vi)＝单链出边表中链接的结点数 </p>
<p>怎样计算有向图顶点的入度？    </p>
<p>   ID(Vi) ＝邻接点为Vi的弧个数 </p>
<p>怎样计算有向图顶点Vi的度：</p>
<p>   TD(Vi) = OD( Vi )+ID( Vi ) </p>
<p>邻接表的优点： 空间效率高；容易寻找顶点的邻接点； </p>
<p>邻接表的缺点： 判断两顶点间是否有边或弧， 需搜索两结点对应的单链表，没有邻接矩阵方便。 </p>
<p>网络 (带权图) 的邻接表 </p>
<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200617102823434-1325153282.png" alt=""></p>
<p>统计出边表中结点个数，得到该顶点的出度；</p>
<p>统计入边表中结点个数，得到该顶点的入度。 </p>
<p>单链表结点中包含另一顶点的下标 dest 和指针 link。对于带权图，边结点中还要 保存该边的权值cost。 </p>
<p><strong>用邻接表表示的图的类定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">E</span>&gt; <span class="title">struct</span> <span class="title">Edge</span> </span></span><br><span class="line"><span class="class">&#123;</span>      <span class="comment">//边结点的定义     </span></span><br><span class="line"><span class="keyword">int</span> dest;       <span class="comment">//边的另一顶点位置     </span></span><br><span class="line">E cost;       <span class="comment">//边上的权值     </span></span><br><span class="line">Edge&lt;T, E&gt; *link;     <span class="comment">//下一条边链指针     </span></span><br><span class="line">Edge () &#123;&#125;       <span class="comment">//构造函数    </span></span><br><span class="line">Edge (<span class="keyword">int</span> num, E cost): dest (num), weight (cost), link (<span class="literal">NULL</span>) &#123; &#125;  <span class="comment">//构造函数       </span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> != (Edge&lt;T, E&gt;&amp; R) <span class="keyword">const</span></span><br><span class="line">&#123; <span class="keyword">return</span> dest != R.dest; &#125;    <span class="comment">//判边等否 </span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">E</span>&gt; <span class="title">struct</span> <span class="title">Vertex</span> &#123;</span>      <span class="comment">//顶点的定义    </span></span><br><span class="line">T data;       <span class="comment">//顶点的名字 </span></span><br><span class="line">Edge&lt;T, E&gt; *adj;     <span class="comment">//边链表的头指针 </span></span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Graphlnk</span> :</span> <span class="keyword">public</span> Graph&lt;T, E&gt; </span><br><span class="line">&#123;   <span class="comment">//图的类定义 </span></span><br><span class="line"><span class="keyword">private</span>:     </span><br><span class="line">Vertex&lt;T, E&gt; *NodeTable;<span class="comment">//顶点表 (各边链表的头结点) </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span>:     </span><br><span class="line"><span class="keyword">int</span> maxVertices;      <span class="comment">//图中最大顶点数     </span></span><br><span class="line"><span class="keyword">int</span> numVertices;     <span class="comment">//当前顶点数    </span></span><br><span class="line"><span class="keyword">int</span> numEdges;      <span class="comment">//当前边数 </span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getVertexPos</span> <span class="params">(<span class="keyword">const</span> T vertx)</span> </span>&#123;          <span class="comment">//给出顶点vertex在图中的位置      </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numVertices; i++)          </span><br><span class="line"><span class="keyword">if</span> (NodeTable[i].data == vertx) <span class="keyword">return</span> i;       </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;   &#125; </span><br><span class="line"><span class="keyword">public</span>:     </span><br><span class="line">Graphlnk (<span class="keyword">int</span> sz = DefaultVertices);  <span class="comment">//构造函数     </span></span><br><span class="line">~Graphlnk();       <span class="comment">//析构函数 </span></span><br><span class="line"><span class="function">T <span class="title">getValue</span> <span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;       <span class="comment">//取顶点 i 的值  </span></span><br><span class="line"><span class="keyword">return</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; NumVertices) ?  NodeTable[i].data : <span class="number">0</span>;    </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function">E <span class="title">getWeight</span> <span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span>;      <span class="comment">//取边(v1,v2)权值  </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insertVertex</span> <span class="params">(<span class="keyword">const</span> T&amp; vertex)</span></span>;     </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">removeVertex</span> <span class="params">(<span class="keyword">int</span> v)</span></span>;     </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insertEdge</span> <span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2, E cost)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">removeEdge</span> <span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span>;     </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFirstNeighbor</span> <span class="params">(<span class="keyword">int</span> v)</span></span>;     </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNextNeighbor</span> <span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>;  </span><br><span class="line"><span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span> &gt;&gt; (istream&amp; in, Graphlnk&lt;T, E&gt;&amp; G);  </span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; out, Graphlnk&lt;T, E&gt;&amp; G);      </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">E</span>&gt; <span class="title">Graphlnk</span>&lt;T, E&gt;:</span>:Graphlnk (<span class="keyword">int</span> sz) &#123;</span><br><span class="line"><span class="comment">//构造函数：建立一个空的邻接表     </span></span><br><span class="line">maxVertices = sz;     </span><br><span class="line">numVertices = <span class="number">0</span>;  </span><br><span class="line">numEdges = <span class="number">0</span>;     </span><br><span class="line">NodeTable = <span class="keyword">new</span> Vertex&lt;T, E&gt;[maxVertices];  <span class="comment">//创建顶点表数组     </span></span><br><span class="line"><span class="keyword">if</span> (NodeTable == <span class="literal">NULL</span>)         </span><br><span class="line">&#123; <span class="built_in">cerr</span> &lt;&lt; <span class="string">"存储分配错！"</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="built_in">exit</span>(<span class="number">1</span>); &#125;     </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxVertices; i++)          </span><br><span class="line">NodeTable[i].adj = <span class="literal">NULL</span>; &#125;; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">E</span>&gt; <span class="title">Graphlnk</span>&lt;T, E&gt;:</span>:～Graphlnk() &#123; </span><br><span class="line"><span class="comment">//析构函数：删除一个邻接表    </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numVertices; i++ ) &#123;      </span><br><span class="line">Edge&lt;T, E&gt; *p = NodeTable[i].adj;         </span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>) </span><br><span class="line">&#123;                 </span><br><span class="line">NodeTable[i].adj = p-&gt;link;             </span><br><span class="line"><span class="keyword">delete</span> p;  p = NodeTable[i].adj;         &#125;    </span><br><span class="line">&#125;      <span class="keyword">delete</span> [ ]NodeTable;         </span><br><span class="line"><span class="comment">//删除顶点表数组 &#125;; </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">Graphlnk</span>&lt;T, E&gt;:</span>:getFirstNeighbor (<span class="keyword">int</span> v) &#123;</span><br><span class="line"><span class="comment">//给出顶点位置为 v 的第一个邻接顶点的位置,果找不到, 则函数返回-1     </span></span><br><span class="line"><span class="keyword">if</span> (v != <span class="number">-1</span>) &#123;   <span class="comment">//顶点v存在    </span></span><br><span class="line">Edge&lt;T, E&gt; *p = NodeTable[v].adj;   <span class="comment">//对应边链表第一个边结点  </span></span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) <span class="keyword">return</span> p-&gt;dest;    <span class="comment">//存在, 返回第一个邻接顶点     </span></span><br><span class="line">&#125;     </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//第一个邻接顶点不存在</span></span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">E</span>&gt; <span class="title">int</span> <span class="title">Graphlnk</span>&lt;T, E&gt;:</span>:getNextNeighbor (<span class="keyword">int</span> v, <span class="keyword">int</span> w) </span><br><span class="line">&#123; <span class="comment">//给出顶点v的邻接顶点w的下一个邻接顶点的位置,若没有下一个邻接顶点, 则函数返回-1     </span></span><br><span class="line"><span class="keyword">if</span> (v != <span class="number">-1</span>) &#123;    <span class="comment">//顶点v存在         </span></span><br><span class="line">Edge&lt;T, E&gt; *p = NodeTable[v].adj;         </span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;dest != w)             </span><br><span class="line">p = p-&gt;link;      </span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;link != <span class="literal">NULL</span>)              </span><br><span class="line"><span class="keyword">return</span> p-&gt;link-&gt;dest;  <span class="comment">//返回下一个邻接顶点     </span></span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;    <span class="comment">//下一邻接顶点不存在 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="图的遍历与连通性"><a href="#图的遍历与连通性" class="headerlink" title="图的遍历与连通性"></a>图的遍历与连通性</h2><p>从已给的连通图中某一顶点出发，沿着一些边访遍图 中所有的顶点，且使每个顶点仅被访问一次，就叫做图的遍历 (Graph Traversal)。 </p>
<p>图的遍历操作是求解图的连通性问题、拓扑排序等问题的基础。 </p>
<p><strong>遍历方法:</strong> </p>
<p>深度优先遍历DFS (Depth First Search) </p>
<p> 广度优先遍历BFS (Breadth First Search) </p>
<p><strong>遍历实质：</strong></p>
<p>找每个顶点的邻接点的过程。 </p>
<p><strong>图的特点：</strong></p>
<p>图中可能存在回路，且图的任一顶点都 可能与其它顶点相通，在访问完某个顶点之后可能 会沿着某些边又回到了曾经访问过的顶点。 </p>
<p>怎样避免重复访问？     </p>
<p>解决思路：可设置一个辅助数组 visited [n ]，用来 标记每个被访问过的顶点。它的初始状态为0，在图的遍历过程中，一旦某一个顶点i 被访问，就立即改 visited [i]为1，防止它被多次访问。 </p>
<p><strong>深度优先搜索DFS (Depth First Search)</strong> </p>
<p>深度优先遍历图的方法是，从图中某顶点v出发： </p>
<p>(1)访问顶点v； </p>
<p>(2)依次从v的未被访问的邻接点出发，对图进行深度优先 遍历；直至图中和v有路径相通的顶点都被访问； </p>
<p>(3)若此时图中尚有顶点未被访问，则从一个未被访问的 顶点出发，重新进行深度优先遍历，直到图中所有顶点 均被访问过为止。对非连通 图</p>
<p>深度优先搜索遍历类似于树的先序遍历。 </p>
<p>深度优先遍历过程是递归的，在遍历过程中，若 某个顶点的所有邻接顶点均被访问过，则需要回溯。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//连通图的深度遍历 </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">DFS</span> (<span class="title">Graph</span>&lt;T, E&gt;&amp; <span class="title">G</span>, <span class="title">int</span> <span class="title">v</span>, <span class="title">bool</span> <span class="title">visited</span>[]) &#123;</span>     </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; G.getValue(v) &lt;&lt; <span class="string">' '</span>;        <span class="comment">//访问顶点v     </span></span><br><span class="line">visited[v] = <span class="literal">true</span>;            <span class="comment">//作访问标记     </span></span><br><span class="line"><span class="keyword">int</span> w = G.getFirstNeighbor (v);     <span class="comment">//第一个邻接顶点     </span></span><br><span class="line"><span class="keyword">while</span> (w != <span class="number">-1</span>) &#123; <span class="comment">//若邻接顶点w存在       </span></span><br><span class="line"><span class="keyword">if</span> ( !visited[w] ) DFS(G, w, visited);   <span class="comment">//若w未访问过, 递归访问顶点w         </span></span><br><span class="line">w = G.getNextNeighbor (v, w); <span class="comment">//下一个邻接顶点     &#125; </span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//图的深度优先搜索算法 </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">E</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">DFSTraverse</span> (<span class="title">Graph</span>&lt;T, E&gt;&amp; <span class="title">G</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">v</span>) &#123;</span> </span><br><span class="line"><span class="comment">//从顶点v出发对图G进行深度优先遍历的主过程     </span></span><br><span class="line"><span class="keyword">int</span> i, loc, n = G.NumberOfVertices();    <span class="comment">//顶点个数    </span></span><br><span class="line"><span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[n];          <span class="comment">//创建辅助数组     </span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) visited [i] = <span class="literal">false</span>; <span class="comment">//辅助数组初始化     </span></span><br><span class="line">loc = G.getVertexPos(v);    </span><br><span class="line">DFS (G, loc, visited); <span class="comment">//从顶点0开始深度优先搜索  </span></span><br><span class="line"><span class="keyword">delete</span> [] visited;           <span class="comment">//释放visited </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>广度优先搜索BFS (Breadth First Search)</strong> </p>
<p>基本思想：——仿树的层次遍历过程。 </p>
<p>广度优先搜索（遍历）步骤： </p>
<p>简单归纳： </p>
<p>①访问了起始点v之后， </p>
<p>②依次访问 v的邻接点。</p>
<p>③然后再依次访问这些顶点的未被访问过的邻接点； 直到所有顶点都被访问过为止。 （连通图）  </p>
<p>若此时图中尚有顶点未被访问,则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止（非连通图） </p>
<p>计算机如何实现BFS？ </p>
<p>除辅助数组visited [n ]外，还需再开一辅助队列</p>
<p>(1)首先访问顶点v，并将其访问标志置为已被访问，即visited[v]=1，并入队； </p>
<p>(2)接着依次访问与顶点v有边相连的所有未访问顶点W1， W2，…，Wt，并入队； </p>
<p>(3)然后再按顺序访问与W1，W2，…，Wt有边相连又未曾访 问过的顶点；</p>
<p>依此类推，直到图中所有顶点都被访问完为止 。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//图的广度优先搜索算法 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BFS</span> (<span class="title">Graph</span>&lt;T, E&gt;&amp; <span class="title">G</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">v</span>) &#123;</span>     </span><br><span class="line"><span class="keyword">int</span> i, w, n = G.NumberOfVertices();   <span class="comment">//图中顶点个数   </span></span><br><span class="line"><span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[n];     </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) visited[i] = <span class="literal">false</span>;     </span><br><span class="line"><span class="keyword">int</span> loc = G.getVertexPos (v);  <span class="comment">//取顶点号     </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; G.getValue (loc) &lt;&lt; <span class="string">' '</span>;  <span class="comment">//访问顶点v    </span></span><br><span class="line">visited[loc] = <span class="literal">true</span>;           <span class="comment">//做已访问标记            </span></span><br><span class="line">Queue&lt;<span class="keyword">int</span>&gt; Q;  Q.EnQueue (loc);   <span class="comment">//顶点进队列, 实现分层访问 图的广度优先搜索算法 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (!Q.IsEmpty() ) &#123; <span class="comment">//循环, 访问所有结点         </span></span><br><span class="line">Q.DeQueue (loc);         </span><br><span class="line">w = G.getFirstNeighbor (loc);  <span class="comment">//第一个邻接顶点         </span></span><br><span class="line"><span class="keyword">while</span> (w != <span class="number">-1</span>) &#123;  <span class="comment">//若邻接顶点w存在            </span></span><br><span class="line"><span class="keyword">if</span> (!visited[w]) &#123;  <span class="comment">//若未访问过  </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; G.getValue (w) &lt;&lt; ‘ ’; <span class="comment">//访问           </span></span><br><span class="line">visited[w] = <span class="literal">true</span>;               </span><br><span class="line">Q.EnQueue (w);   <span class="comment">//顶点w进队列                </span></span><br><span class="line">&#125;           </span><br><span class="line">w = G.getNextNeighbor (loc, w); <span class="comment">//找顶点loc的下一个邻接点         </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;     <span class="comment">//外层循环，判队列空否</span></span><br><span class="line">&#125; <span class="comment">// 如果对于非联通的图    </span></span><br><span class="line"><span class="keyword">delete</span> [] visited; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>连通分量 (Connected component)</strong> </p>
<p>当无向图为非连通图时，从图中某一顶点出发，利 用深度优先搜索算法或广度优先搜索算法不可能遍 历到图中的所有顶点，只能访问到该顶点所在最大 连通子图（连通分量）的所有顶点。</p>
<p>若从无向图每一连通分量中的一个顶点出发进行遍 历,   可求得无向图的所有连通分量。</p>
<p>例如，对于非连通的无向图，所有连通分量的生成 树组成了非连通图的生成森林。 </p>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>对连通图进行遍历，得到的是什么？    </p>
<p>——得到的将是一个极小连通子图，即图的生成树！     由深度优先搜索得到的，称为深度优先搜索生成树。   由广度优先搜索得到的，称为广度优先搜索生成树。 </p>
<p>对非连通图进行遍历，得到的是什么？ </p>
<p>—— 得到的是各连通分量的生成树，即图的生成森林 </p>
<p>求解步骤：<br>Step1:先用邻接矩阵或邻接表表示；<br>Step2:写出DFS或BFS结果序列；<br>Step3:画出对应生成树或森林。 </p>
<p><strong>最小代价生成树</strong></p>
<p>在一个连通网的所有生成树中， 各边的代价之和 最小的那棵生成树。简称为最小生成树(MST)。 </p>
<p>构造最小生成树的准则： </p>
<ol>
<li>必须使用且仅使用n-1条边来联结网络中的n个顶点 </li>
<li>不能使用产生回路的边。</li>
<li>各边上的权值的总和达到最小。 </li>
</ol>
<p><strong>典型用途：</strong> </p>
<p>欲在n个城市间建立通信网，则n个城市应铺n-1条线路； 但因为每条线路都会有对应的经济成本，而n个城市至多可 能有n(n-1)/2 条线路，那么，如何选择n–1条线路，使总 费用最少？ </p>
<p>数学模型： 顶点———表示城市，有n个； 边————表示线路，有n–1条； 边的权值—表示线路的经济代价； 连通网——表示n个城市间通信网。</p>
<p>下面仅讨论无向网的最小生成树问题。 </p>
<p>有多种算法，但最常用的是以下两种：</p>
<p>Prim（普里姆）算法：  将顶点归并，与边数无关，适于稠密网  </p>
<p>Kruskal（克鲁斯卡尔）算法： 将边归并，适于求稀疏网的最小生成树 </p>
<p>这两个算法，都是利用MST 性质来构造最小生成树的 。</p>
<p><strong>MST性质</strong><br>假设G=(V, E)是一个无向连通网，U是顶点集V的一 个非空子集。若(u, v)是一条具有最小权值的边，其 中u∈U，v∈V－U，则必存在一棵包含边(u, v)的最 小生成树。 </p>
<p><strong>克鲁斯卡尔 (Kruskal) 算法</strong> </p>
<p>克鲁斯卡尔算法的基本思想： </p>
<p> 设有一个有 n 个顶点的连通网络 N = { V, E }, 最初先构造一 个只有 n 个顶点, 没有边的非连通图 T = { V, Ø },  图中每个顶 点自成一个连通分量。 </p>
<p>当在 E 中选到一条具有最小权值的边时, 若该边的两个顶点 落在不同的连通分量上，则将此边加入到 T 中。 </p>
<p>如此重复下去, 直到所有顶点在同一个连通分量上为止。 </p>
<p>不用最小堆的算法实现： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顶点结点： </span></span><br><span class="line"><span class="keyword">typedef</span>   <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span>    <span class="keyword">int</span> data;    <span class="comment">//顶点信息       </span></span><br><span class="line">     <span class="keyword">int</span>  jihe;    </span><br><span class="line">&#125;VEX;</span><br><span class="line"><span class="comment">//边结点</span></span><br><span class="line"> <span class="keyword">typedef</span>   <span class="class"><span class="keyword">struct</span>  </span></span><br><span class="line"><span class="class">&#123;</span>    <span class="keyword">int</span>   tail, head;  <span class="comment">//边依附的两顶点       </span></span><br><span class="line">     <span class="keyword">int</span>  cost;       <span class="comment">//边的权值       </span></span><br><span class="line">     <span class="keyword">int</span>  flag;        <span class="comment">//标志域 </span></span><br><span class="line">&#125;EDGE;</span><br></pre></td></tr></table></figure>

<p>0）用顶点数组和边数组存放顶点和边信息 </p>
<p>1）初始时，令每个顶点的集合互不相同；每个边的flag为0 </p>
<p>2）选出权值最小且flag为0的边 </p>
<p>3）若该边依附的两个顶点的集合值不同，即非连通，则令该边的flag=1, 选中该边；再令该边依附的两顶点的集合以及两集合中所有顶点的集合 相同  若该边依附的两个顶点的集合值相同，即连通，则令该边的flag=2, 即舍去该边 </p>
<p>4）重复上述步骤，直到选出n-1条边为止<br><strong>算法的框架</strong>  </p>
<p> 利用最小堆(MinHeap)和并 查集(DisjointSets)来实现克鲁斯卡尔算法</p>
<p>首先, 利用最小堆来存放E中的所有的边, 并选出最小边 </p>
<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200617102907499-992845421.png" alt=""></p>
<p>利用并查集的运算检查两顶点是否在同一连通分量 上。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最小生成树类定义 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> maxValue = FLOAT_MAX     <span class="comment">//机器可表示的、问题中不可能出现的大数 </span></span><br><span class="line"><span class="keyword">template</span> &lt;class T, class E&gt; </span><br><span class="line">struct MSTEdgeNode &#123;  <span class="comment">//树边结点的类定义     </span></span><br><span class="line"><span class="keyword">int</span> tail, head;   <span class="comment">//两顶点位置    </span></span><br><span class="line">E cost;    <span class="comment">//边上的权值  </span></span><br><span class="line">MSTEdgeNode() : tail(<span class="number">-1</span>), head(<span class="number">-1</span>), cost(<span class="number">0</span>) &#123; &#125;      <span class="comment">//构造函数  </span></span><br><span class="line">&#125;;   </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">MinSpanTree</span> &#123;</span> <span class="comment">//树的类定义</span></span><br><span class="line"><span class="keyword">protected</span>:     </span><br><span class="line">MSTEdgeNode&lt;T, E&gt; *edgevalue;     <span class="comment">//边值数组   </span></span><br><span class="line"><span class="keyword">int</span> maxSize, n;  <span class="comment">//最大元素个数和当前个数 </span></span><br><span class="line"><span class="keyword">public</span>:     </span><br><span class="line">MinSpanTree (<span class="keyword">int</span> sz = DefaultSize<span class="number">-1</span>) : MaxSize (sz), n (<span class="number">0</span>) </span><br><span class="line">&#123;       </span><br><span class="line">edgevalue = <span class="keyword">new</span> MSTEdgeNode&lt;T, E&gt;[sz];      </span><br><span class="line">&#125;     </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Insert</span> <span class="params">(MSTEdgeNode&amp; item)</span></span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在求解最小生成树时，可以用邻接矩阵存储图， 也可以用邻接表存储图。算法中使用图的抽象 基类的操作，无需考虑图及其操作的具体实现。</p>
<p><strong>Kruskal算法的实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"heap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"UFSets.h"</span> </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Kruskal</span> (<span class="title">Graph</span>&lt;T, E&gt;&amp; <span class="title">G</span>, <span class="title">MinSpanTree</span>&lt;T, E&gt;&amp; <span class="title">MST</span>) &#123;</span> </span><br><span class="line"> MSTEdgeNode&lt;T, E&gt; ed;           <span class="comment">//边结点辅助单元     </span></span><br><span class="line"> <span class="keyword">int</span> u, v, count;       </span><br><span class="line"> <span class="keyword">int</span> n = G.NumberOfVertices();   <span class="comment">//顶点数     </span></span><br><span class="line"> <span class="keyword">int</span> m = G.NumberOfEdges();     <span class="comment">//边数    </span></span><br><span class="line"> MinHeap &lt;MSTEdgeNode&lt;T, E&gt;&gt; H(m);   //最小堆      </span><br><span class="line"> <span class="function">UFSets <span class="title">F</span><span class="params">(n)</span></span>;        <span class="comment">//并查集     </span></span><br><span class="line"> <span class="keyword">for</span> (u = <span class="number">0</span>; u &lt; n; u++)            </span><br><span class="line"> <span class="keyword">for</span> (v = u+<span class="number">1</span>; v &lt; n; v++)   <span class="comment">//无向连通图             </span></span><br><span class="line"> <span class="keyword">if</span> (G.getWeight(u,v) != maxValue) &#123;                 </span><br><span class="line"> ed.tail = u;  ed.head = v;  <span class="comment">//插入堆                 </span></span><br><span class="line"> ed.cost = G.getWeight (u, v);                 </span><br><span class="line"> H.Insert(ed);              </span><br><span class="line"> &#125; </span><br><span class="line">count = <span class="number">1</span>;                <span class="comment">//最小生成树边数计数    </span></span><br><span class="line"><span class="keyword">while</span> (count &lt; n) &#123;      <span class="comment">//反复执行, 取n-1条边         </span></span><br><span class="line">H.Remove(ed);      <span class="comment">//退出具最小权值的边         </span></span><br><span class="line">u = F.Find(ed.tail);  v = F.Find(ed.head);<span class="comment">//取两顶点所在集合的根u与v        </span></span><br><span class="line"><span class="keyword">if</span> (u != v) &#123;                <span class="comment">//不是同一集合,不连通             </span></span><br><span class="line">F.Union(u, v);     <span class="comment">//合并,连通它们               </span></span><br><span class="line">MST.Insert(ed);     <span class="comment">//该边存入MST             </span></span><br><span class="line">count++;       </span><br><span class="line">&#125;     &#125; </span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p><strong>普里姆(Prim)算法</strong> </p>
<p>普里姆算法的基本思想： </p>
<p>从连通网络 N = {V, E}中的某一顶点 u0 出发, 选择与 它关联的具有最小权值的边 (u0, v), 将其顶点加入到 生成树顶点集合U中。 </p>
<p>以后每一步从一个顶点在集合U中,  而另一个顶点不 在集合U中的各条边中选择权值最小的边(u, v), 把它 的顶点加入到集合U中。 </p>
<p>如此继续下去, 直到网络中的所有顶点都加入到生 成树顶点集合U中为止。 </p>
<p>注意：当各边有相同权值时，由于选择的随意 性，产生的生成树可能不唯一。 </p>
<p><strong>Prim算法的实现</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"heap.h"</span> </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Prim</span> (<span class="title">Graph</span>&lt;T, E&gt;&amp; <span class="title">G</span>, <span class="title">const</span> <span class="title">T</span> <span class="title">u0</span>,<span class="title">MinSpanTree</span>&lt;T, E&gt;&amp; <span class="title">MST</span>) &#123;</span>     </span><br><span class="line">MSTEdgeNode&lt;T, E&gt; ed; <span class="comment">//边结点辅助单元     </span></span><br><span class="line"><span class="keyword">int</span> i, u, v, count;         </span><br><span class="line"><span class="keyword">int</span> n = G.NumberOfVertices();   <span class="comment">//顶点数      </span></span><br><span class="line"><span class="keyword">int</span> m = G.NumberOfEdges();   <span class="comment">//边数  </span></span><br><span class="line"><span class="keyword">int</span> u = G.getVertexPos(u0);    <span class="comment">//起始顶点号  </span></span><br><span class="line">MinHeap &lt;MSTEdgeNode&lt;T, E&gt;&gt; H(m);  //最小堆 </span><br><span class="line"><span class="keyword">bool</span> Vmst = <span class="keyword">new</span> <span class="keyword">bool</span>[n];   <span class="comment">//最小生成树顶点集合     </span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) Vmst[i] = <span class="literal">false</span>;      </span><br><span class="line">Vmst[u] = <span class="literal">true</span>;          <span class="comment">//u 加入生成树     </span></span><br><span class="line">count = <span class="number">1</span>;     </span><br><span class="line"><span class="keyword">do</span> &#123;           <span class="comment">//迭代      </span></span><br><span class="line">v = G.getFirstNeighbor(u);         </span><br><span class="line"><span class="keyword">while</span> (v != <span class="number">-1</span>) &#123;         <span class="comment">//检测u所有邻接顶点             </span></span><br><span class="line"><span class="keyword">if</span> (!Vmst[v]) &#123;         <span class="comment">//v不在mst中                 </span></span><br><span class="line">ed.tail = u;  ed.head = v;                </span><br><span class="line">ed.cost = G.getWeight(u, v);                 </span><br><span class="line">H.Insert(ed);         <span class="comment">//(u,v)加入堆             </span></span><br><span class="line">&#125;     <span class="comment">//堆中存所有u在mst中, v不在mst中的边             </span></span><br><span class="line">v = G.getNextNeighbor(u, v);  </span><br><span class="line">        &#125;        </span><br><span class="line"> <span class="keyword">while</span> (!H.IsEmpty() &amp;&amp; count &lt; n) &#123;              </span><br><span class="line"> H.Remove(ed);          <span class="comment">//选堆中具最小权的边             </span></span><br><span class="line"> <span class="keyword">if</span> (!Vmst[ed.head]) &#123;                </span><br><span class="line"> MST.Insert(ed);       <span class="comment">//加入最小生成树                 </span></span><br><span class="line"> u = ed.head;  Vmst[u] = <span class="literal">true</span>;   <span class="comment">//u加入生成树顶点集合                 </span></span><br><span class="line"> count++;                   </span><br><span class="line"> <span class="keyword">break</span>;  <span class="comment">//找找未曾加入的边入栈            </span></span><br><span class="line"> &#125;         &#125;     </span><br><span class="line"> &#125; <span class="keyword">while</span> (count &lt; n); </span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>Prim算法（只用数组记录最值当前状态）自学 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MiniSpanTree_PRIM</span><span class="params">(MGraph G, VertexType u)</span> </span>&#123;     </span><br><span class="line"><span class="comment">// 用普里姆算法从第u个顶点出发构造网G的最小生成树T，输出T 的各条边。  </span></span><br><span class="line"><span class="comment">// 记录从顶点集U到V－U的代价最小的边的辅助数组定义：  </span></span><br><span class="line"><span class="comment">//  struct &#123;   </span></span><br><span class="line"><span class="comment">//      VertexType  adjvex;  </span></span><br><span class="line"><span class="comment">//      VRType     lowcost;  </span></span><br><span class="line"><span class="comment">//  &#125; closedge[MAX_VERTEX_NUM];   </span></span><br><span class="line"><span class="keyword">int</span> i,j,k;  </span><br><span class="line">k = LocateVex ( G, u );   </span><br><span class="line"><span class="keyword">for</span> ( j=<span class="number">0</span>; j&lt;G.vexnum; ++j ) &#123;    </span><br><span class="line"><span class="comment">// 辅助数组初始化     </span></span><br><span class="line"><span class="keyword">if</span> (j!=k)    </span><br><span class="line">&#123; closedge[j].adjvex=u;       </span><br><span class="line">closedge[j].lowcost=G.arcs[k][j].adj; &#125;  </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">closedge[k].lowcost = <span class="number">0</span>; <span class="comment">// 初始，U＝&#123;u&#125; </span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;G.vexnum; ++i) &#123;  <span class="comment">// 选择其余G.vexnum-1个顶点</span></span><br><span class="line">k = minimum(closedge);  <span class="comment">// 求出T的下一个结点：第k顶点 </span></span><br><span class="line"><span class="comment">//此时closedge[k].lowcost = </span></span><br><span class="line"><span class="comment">//MIN&#123; closedge[vi].lowcost | closedge[vi].lowcost&gt;0, vi∈V-U &#125;</span></span><br><span class="line"><span class="built_in">printf</span>(closedge[k].adjvex, G.vexs[k]);  <span class="comment">// 输出生成树的边 </span></span><br><span class="line">closedge[k].lowcost = <span class="number">0</span>;  <span class="comment">// 第k顶点并入U集 </span></span><br><span class="line"><span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;G.vexnum; ++j)</span><br><span class="line"><span class="keyword">if</span> (G.arcs[k][j].adj &lt; closedge[j].lowcost) &#123;  </span><br><span class="line"><span class="comment">// 新顶点并入U后重新选择最小边 </span></span><br><span class="line"><span class="comment">// closedge[j] = &#123; G.vexs[k], G.arcs[k][j].adj &#125;; </span></span><br><span class="line">closedge[j].adjvex=G.vexs[k]; </span><br><span class="line">closedge[j].lowcost=G.arcs[k][j].adj; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125; <span class="comment">// MiniSpanTree</span></span><br></pre></td></tr></table></figure>

<p>显然， Prim算法的时间效率＝O（n^2） </p>
<p>两种算法比较<br>Prim：从某一个顶点出发寻找到其他顶点 最小了分支（与顶点有关）</p>
<p>Kruscal：先对边排序，再测试连通（与边有关） </p>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p>最短路径问题：如果从图中某一顶点（称为源 点）到另一顶点（称为终点）的路径可能不止一条，如何找到一条路径使得沿此路径上各边 上的权值总和达到最小。 </p>
<p> 问题解法  :边上权值非负情形的单源最短路径问题   —  Dijkstra算法   </p>
<p>典型用途：交通问题。如：城市A到城市B有多条线路， 但每条线路的交通费（或所需时间）不同，那么，如何 选择一条线路，使总费用（或总时间）最少？ （注：最短路径与最小生成树不同，路径上不一定包含n 个顶点） </p>
<p>问题抽象：在带权有向图中A点（源点）到达B点（终点） 的多条路径中，寻找一条各边权值之和最小的路径，即 最短路径.</p>
<p><strong>边上权值非负情形的 单源最短路径问题</strong> </p>
<p>目的： 设一有向图G=（V, E），已知各边的权值， 以某指定点v0为源点，求从v0到图的其余各点的最短 路径。限定各边上的权值大于或等于0。 </p>
<p>Dijkstra提出按路径长度的递增次序,   逐步产生最短 路径的算法。 </p>
<p>假设S是已求得的最短路径的终点的集合，则可 证明：下一条最短路径必然是从v0 出发，中间只经过S 中的顶点便可到达的那些顶点vx (vxV-S )的路 径中路径长度值最小的一条。逐步扩充S,将终点加入集合S中。 </p>
<p><strong>Dijkstra 算法的基本步骤</strong></p>
<p>1) 设V0是起始源点，S是已求得最短路径的终点集合。 1) V-S = 未确定最短路径的顶点的集合， 初始时 S={V0} </p>
<p>2) 选择下一条长度最短的路径： </p>
<p>① Vi  V - S ，求出V0 到Vi 中间只经 S 中顶点的最短 路径；    </p>
<p>② 上述最短路径中长度最小者即为下一条长度最短的路径   </p>
<p>③ 将所求最短路径的终点加入S 中，并作调整； </p>
<p>3) 重复2）直到求出所有终点的最短路径 </p>
<p><strong>数据结构描述</strong> </p>
<p>1 引入辅助数组dist[]  </p>
<p>dist[]:存放当前找到的从源点V0到每个终点的最短路径长度 </p>
<p> 初始状态：  若从v0到顶点vi有边, 则dist[i]为该边的权值；  若从v0到顶点vi无边, 则dist[i]为 ∞</p>
<p>每次求得一条最短路径后, 其终点vk 加入集合S，然后对所有的vi V-S，修改其 dist[i]值 </p>
<p>2 s[]: 存放点是否已确定最短路径的状态 </p>
<p>3 path[]:表示从V0到各终点的最短路径上，此顶点的前一顶 点的序号；若从V0到某终点无路径，则用0作为其前一顶 点的序号。 </p>
<p><strong>算法描述：</strong> </p>
<p>（1）S为已找到从源点v0出发的最短路径的终点集合，初始为{v0}.  辅助数组 dist [ n ]存储各终点当前找到的最短路径的长度<br>（2）选择u，使得&lt;v0,u&gt;是这些路径中长度最短的路径，加入已求 的最短路径的点集合     </p>
<p> dist [ u ]＝min{dist[i] | i∈V-S }  // i是S集之外的顶点    </p>
<p> // dist[u]是从源点v0到S集外所有顶点的弧中最短的一条     </p>
<p> S= S ∪{u}   //将u加入S集<br>（3）对于所有不在S中的终点w，进行路径调整：  dist[u]+ A[u,i]&lt; dist[i]  // 即(v0,u)＋(u,i)&lt;(v0,i)  则修改dist[i]为： dist[i]＝ dist[u]+ A[u,i]<br>重复操作（2）、（3）共n-1次，由此求得从v0到各终点的最短路径。 </p>
<p><strong>从单个顶点到其他各顶点最短路径的算法</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath</span> <span class="params">(Graph&lt;T, E&gt;&amp; G, T v, E dist[], <span class="keyword">int</span> path[])</span> </span>&#123; </span><br><span class="line"> <span class="keyword">int</span> n = G.NumberOfVertices();    </span><br><span class="line"> <span class="keyword">bool</span> *S = <span class="keyword">new</span> <span class="keyword">bool</span>[n];     <span class="comment">//最短路径顶点集     </span></span><br><span class="line"> <span class="keyword">int</span> i, j, k;  E w, <span class="built_in">min</span>;     </span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;      </span><br><span class="line"> dist[i] = G.getWeight(v, i);           </span><br><span class="line"> S[i] = <span class="literal">false</span>;         </span><br><span class="line"> <span class="keyword">if</span> (i != v &amp;&amp; dist[i] &lt; maxValue) path[i] = v;         </span><br><span class="line"> <span class="keyword">else</span> path[i] = <span class="number">-1</span>;   </span><br><span class="line">S[v] = <span class="literal">true</span>;  dist[v] = <span class="number">0</span>;      <span class="comment">//顶点v加入顶点集合     </span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;       <span class="comment">//求解各顶点最短路径          </span></span><br><span class="line"><span class="built_in">min</span> = maxValue;  <span class="keyword">int</span> u = v;               </span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)               </span><br><span class="line"><span class="keyword">if</span> (!S[j] &amp;&amp; dist[j] &lt; <span class="built_in">min</span>)                 </span><br><span class="line">&#123; u = j; <span class="built_in">min</span> = dist[j];&#125;         <span class="comment">//将源点V加 入S后, 初始化剩 余点的当前路径 </span></span><br><span class="line">S[u] = <span class="literal">true</span><span class="comment">//将顶点u加入集合S        </span></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++) &#123;                    </span><br><span class="line">w = G.GetWeight(u, k);      <span class="comment">//然后对其余各点路径 进行适当调整：,并记 录每个点的前驱 </span></span><br><span class="line"><span class="keyword">if</span> (!S[k] &amp;&amp; w &lt; maxValue &amp;&amp;                      </span><br><span class="line">dist[u]+w &lt; dist[k]) &#123;                        </span><br><span class="line">dist[k] = dist[u]+w;                 </span><br><span class="line">path[k] = u;                    </span><br><span class="line">&#125;    &#125; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="活动网络"><a href="#活动网络" class="headerlink" title="活动网络"></a>活动网络</h2><p><strong>用顶点表示活动的网络 (AOV网络)</strong> </p>
<p>计划、施工过程、生产流程、程序流程等都是“工 程”。除了很小的工程外，一般都把工程分为若干 个叫做“活动”的子工程。完成了这些活动，这个 工程就可以完成了。</p>
<p>例如，计算机专业学生的学习就是一个工程，每一 门课程的学习就是整个工程的一些活动。其中有些 课程要求先修课程，有些则不要求。这样在有的课 程之间有领先关系，有的课程可以并行地学习。 </p>
<p>可以用有向图表示一个工程。在这种有向图中， 用顶点表示活动，用有向边&lt;Vi, Vj&gt;表示活动Vi 必须先于活动Vj 进行。这种有向图叫做顶点表 示活动的AOV网络 (Activity  On Vertices)。 </p>
<p><strong>拓扑排序</strong> </p>
<p>问题：    </p>
<p>假设以有向图表示一个工程的施工图或程 序的数据流图，则图中不允许出现回路 </p>
<p>如何检查有向图中是否存在回路的方法之 一，是对有向图进行拓扑排序。 </p>
<p><strong>什么是拓扑排序：</strong></p>
<p>对有向图进行如下操作： 按照有向图给出的次序关系，将图中顶点排成一个线 性序列，对于有向图中没有限定次序关系的顶点，则 可以人为加上任意的次序关系。 由此所得顶点的线性序列称为拓扑有序序列构造有向图的一个拓扑序列的过程称为拓扑排序。</p>
<p>若该线性序列中包含AOV网全部顶点，则AOV网无环，否 则，AOV网中存在有向环，此AOV网络所代表的工程是不 可行的。 </p>
<p><strong>进行拓扑排序的方法</strong></p>
<p> ① 输入AOV网络。令 n 为顶点个数。  </p>
<p> ② 在AOV网络中选一个没有直接前驱的顶点, 并 输出之; </p>
<p> ③ 从图中删去该顶点, 同时删去所有它发出的有 向边; </p>
<p> ④ 重复以上 ②、③步, 直到 全部顶点均已输出，拓扑有序序列形成， 拓扑排序完成；或 图中还有未输出的顶点, 但已跳出处理循环。 说明图中还剩下一些顶点, 它们都有直接前 驱。这时网络中必存在有向环。 </p>
<p>在邻接表中增设一个数组count[]，记录各顶点入 度。入度为零的顶点即无前驱顶点。</p>
<p>在输入数据前, 顶点表NodeTable[]和入度数组 count[]全部初始化。在输入数据时, 每输入一条 边&lt;j, k&gt;, 就需要建立一个边结点, 并将它链入相 应边链表中, 统计入度信息：     </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Edge * p = <span class="keyword">new</span> Edge&lt; <span class="keyword">int</span> &gt; (k);   <span class="comment">//建立边结点, dest 域赋为 k    </span></span><br><span class="line"></span><br><span class="line"> p-&gt;link = NodeTable[j].adj;    </span><br><span class="line"></span><br><span class="line"> NodeTable[j].adj = p;    <span class="comment">//链入顶点j的边链表的前端     </span></span><br><span class="line"></span><br><span class="line">count[k]++;     <span class="comment">//顶点k入度加一</span></span><br></pre></td></tr></table></figure>



<p> 在算法中, 使用一个存放入度为零的顶点的链 式栈, 供选择和输出无前驱的顶点。</p>
<p>拓扑排序算法可描述如下： </p>
<p>1、建立入度为零的顶点栈; </p>
<p>2、当入度为零的顶点栈不空时, 重复执行</p>
<p>从顶点栈中退出一个顶点, 并输出之; </p>
<p>从AOV网络中删去这个顶点和它发出的 边, 边的终顶点入度减一; </p>
<p>如果边的终顶点入度减至0, 则该顶点进 入度为零的顶点栈; </p>
<p> 3、如果输出顶点个数少于AOV网络的顶点 个数, 则报告网络中存在有向环。 </p>
<p>在算法实现时, 为了建立入度为零的顶点栈,可 以不另外分配存储空间, 直接利用入度为零的 顶点的count[ ]数组元素。设立一个栈顶指针 top, 指示当前栈顶位置, 即某一个入度为零的 顶点。栈初始化时置top = -1。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将顶点i 进栈时执行以下指针的修改：   </span></span><br><span class="line">count[i] = top;  top = i ; <span class="comment">// top指向新栈顶i, 原栈顶元素在count[i]中 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//退栈操作可以写成：  </span></span><br><span class="line"> j = top;  top = count[top]; <span class="comment">//位于栈顶的顶点记于 j, top退到次栈顶</span></span><br></pre></td></tr></table></figure>

<p><strong>拓扑排序的算法</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">TopologicalSort</span> (<span class="title">Graph</span>&lt;T, E&gt;&amp; <span class="title">G</span>) </span></span><br><span class="line"><span class="class">&#123;</span> <span class="keyword">int</span> i, j, w, v;     </span><br><span class="line"><span class="keyword">int</span> top = <span class="number">-1</span>;              <span class="comment">//入度为零顶点的栈初始化     </span></span><br><span class="line"><span class="keyword">int</span> n = G.NumberOfVertices();    <span class="comment">//网络中顶点个数     </span></span><br><span class="line"><span class="keyword">int</span> *count = <span class="keyword">new</span> <span class="keyword">int</span>[n];     <span class="comment">//入度数组兼入度为零顶点栈     </span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) count[i] = <span class="number">0</span>;    </span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; i &gt;&gt; j;    <span class="comment">//输入一条边(i, j)    </span></span><br><span class="line"><span class="keyword">while</span> (i &gt; <span class="number">-1</span> &amp;&amp; i &lt; n &amp;&amp; j &gt; <span class="number">-1</span> &amp;&amp; j &lt; n) &#123;        </span><br><span class="line">G.insertEdge (i, j);  </span><br><span class="line">count[j]++; </span><br><span class="line"> <span class="built_in">cin</span> &gt;&gt; i &gt;&gt; j;      &#125;     </span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)  <span class="comment">//初始化，检查网络所有顶点   </span></span><br><span class="line"> <span class="keyword">if</span> (count[i] == <span class="number">0</span>)         <span class="comment">//入度为零的顶点进栈  </span></span><br><span class="line"> &#123; count[i] = top;  top = i; &#125;      </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)       <span class="comment">//期望输出n个顶点         </span></span><br><span class="line"><span class="keyword">if</span> (top == <span class="number">-1</span>) &#123;            <span class="comment">//中途栈空,转出</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; “网络中有回路！<span class="string">" &lt;&lt; endl;  </span></span><br><span class="line"><span class="string">return;   </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">else </span></span><br><span class="line"><span class="string">&#123;     //继续拓扑排序     </span></span><br><span class="line"><span class="string">v = top;  top = count[top];    //退栈v            </span></span><br><span class="line"><span class="string">cout &lt;&lt; G.getValue(v) &lt;&lt; "</span>  <span class="string">" &lt;&lt; endl;   //输出            </span></span><br><span class="line"><span class="string">w = G.GetFirstNeighbor(v);                </span></span><br><span class="line"><span class="string">while (w != -1) &#123;      //扫描顶点v的出边表             </span></span><br><span class="line"><span class="string">count[w]--;    //邻接顶点入度减一             </span></span><br><span class="line"><span class="string">if (!count[w])              </span></span><br><span class="line"><span class="string">&#123; count[w] = top;  top = w; &#125;  //入度减至零,进栈      </span></span><br><span class="line"><span class="string">w = G.GetNextNeighbor (v, w);   </span></span><br><span class="line"><span class="string">&#125;     //一个顶点输出后，调整其邻接顶点入度        </span></span><br><span class="line"><span class="string">&#125;     </span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure>

<p>分析此拓扑排序算法可知，如果AOV网络有 n个顶点，e条边，在拓扑排序的过程中，搜 索入度为零的顶点，建立链式栈所需要的时 间是O(n)。在正常的情况下，有向图有n个顶 点，每个顶点进一次栈，出一次栈，共输出 n 次。顶点入度减一的运算共执行了e次。所 以总的时间复杂度为O(n+e)。 </p>
<p><strong>用边表示活动的网络(AOE网络)</strong> </p>
<p>用一个带权有向图（DAG）描述工程的预计进度。 </p>
<p>顶点表示事件，有向边表示活动，边e的权c(e） 表示完成活动e所需的时间(比如 天数）。 </p>
<p>图中入度为0的顶点表示工程的开始事件（如开工 仪式），出度为0的顶点表示工程结束事件。 </p>
<p><strong>关键路径</strong> </p>
<p>从AOE网中源点到汇点的最长路径，具有最大长 度的路径叫关键路径。</p>
<p>关键路径是由关键活动构成的，关键路径可能不唯一。</p>
<p>关键路径为源点到汇点的最长路径，这样转变为查找图中最长路径问题。</p>
<p>求一个AOE的关键路径 即 求AOE的中的关键活动 </p>
<p><strong>用边表示活动的网络(AOE网络)</strong> </p>
<p>如果在无有向环的带权有向图中, 用有向边表 示一个工程中的活动 (Activity), 用边上权值表 示活动持续时间 (Duration),  用顶点表示事件 (Event),  则这样的有向图叫做用边表示活动的 网络, 简称 AOE ( Activity On Edges ) 网络。</p>
<p>AOE网络在某些工程估算方面非常有用。例如，可以使人们了解：</p>
<p> 完成整个工程至少需要多少时间(假设网络 中没有环)?  </p>
<p>为缩短完成工程所需的时间, 应当加快哪些 活动?  </p>
<p>从源点到各个顶点, 以至从源点到汇点的有向 路径可能不止一条。  这些路径的长度也可能 不同。  完成不同路径的活动所需的时间虽然 不同, 但只有各条路径上所有活动都完成了, 整 个工程才算完成。</p>
<p>因此, 完成整个工程所需的时间取决于从源点 到汇点的最长路径长度, 即在这条路径上所有 活动的持续时间之和。这条路径长度最长的路 径就叫做关键路径(Critical Path)。</p>
<p>要找出关键路径，必须找出关键活动, 即不按 期完成就会影响整个工程完成的活动。</p>
<p>关键路径上的所有活动都是关键活动。因此, 只要找到了关键活动, 就可以找到关键路径。 例如, 下图就是一个AOE网。 </p>
<p><strong>定义几个与计算关键活动有关的量</strong></p>
<ol>
<li><p>事件Vi 的最早可能开始时间Ve(i)  是从源点V0 到顶点Vi 的最长路径长度。</p>
</li>
<li><p>事件Vi 的最迟允许开始时间Vl[i]  是在保证汇点Vn-1 在Ve[n-1] 时刻完成的前提 下，事件Vi 的允许的最迟开始时间。</p>
</li>
<li><p>活动ak 的最早可能开始时间 e[k]  设活动ak 在边&lt;Vi, Vj&gt;上, 则e[k]是从源点V0 到 顶点Vi 的最长路径长度。因此,  e[k] = Ve[i]。</p>
</li>
<li><p>活动ak 的最迟允许开始时间 l[k]，l[k]是在不会引起时间延误的前提下, 该活动 允许的最迟开始时间。            l[k] = Vl[j]-dur(&lt;i, j&gt;)。  其中, dur(&lt;i, j&gt;)是完成 ak  所需的时间。</p>
</li>
<li><p>时间余量 l[k]-e[k]  </p>
<p>表示活动ak的最早可能开始时间和最迟允许 开始时间的时间余量。l[k] == e[k]表示活动 ak 是没有时间余量的关键活动。</p>
<p>为找出关键活动, 需要求各个活动的 e[k] 与 l[k]，以判别是否 l[k] == e[k]。 </p>
<p>为求得e[k]与l[k],  需要先求得从源点V0到各个 顶点Vi 的Ve[i]和Vl[i]。 </p>
<p>求Ve[i]的递推公式，从 Ve[0] = 0 开始，向前递推 ， Ve[j]=max{ Ve[i]+dur(&lt; Vi , Vj&gt;)},   &lt; Vi, Vj &gt; ∈S2,   j = 1, 2, … , n-1 。 S2 是所有指向Vj 的有向边&lt;Vi,Vj&gt;的集合。 </p>
<p>从Vl[n-1] = Ve[n-1]开始，反向递推 Vl [j]=min{ Vl[k]-dur(&lt; Vj , Vk&gt;)},   &lt; Vj, Vk &gt; ∈S1,   j = 1, 2, … , n-1 。 S1 是所有指向Vj 的有向边&lt;Vj,Vk&gt;的集合。</p>
<p>这两个递推公式的计算必须分别在拓扑有序及 逆拓扑有序的前提下进行。  </p>
<p>设活动ak (k=1, 2, …, e)在带权有向边&lt; Vi, Vj &gt; 上, 其持续时间用dur (&lt;Vi,Vj&gt;)表示, 则有       </p>
<p> e[k] = Ve[i]；        </p>
<p> l[k] = Vl[j]-dur(&lt;Vi,Vj&gt;)；k = 1, 2, …, e。  这样就得到计算关键路径的算法。</p>
<p>为了简化算法,  假定在求关键路径之前已经对 各顶点实现了拓扑排序,  并按拓扑有序的顺序 对各顶点重新进行了编号。 </p>
<p><strong>求关键路径的过程</strong></p>
<p>（1）事件的最早开始和最迟开始时间</p>
<p>事件v的最早开始时间：规定源点事件的最早开始时间为0。定义图中任 一事件v的最早开始时间（early event） ee(v)等于x、y、z到v所有路径长度的 最大值：</p>
<p>事件v的最迟开始时间：定义在不影响整个工程进度的前提下，事件v必 须发生的时间称为v的最迟开始时间（late event） ，记作le(v)。le(v)应等于 ee(y)与v到汇点的最长路径长度之差：</p>
<p>（2）活动的最早开始时间和最迟开始时间</p>
<p>活动a的最早开始时间e(a)指该活动起点x事件的最早开始时间，即： e(a)=ee(x)</p>
<p>活动a的最迟开始时间l(a)指该活动终点y事件的最迟开始时间与该 活动所需时间之差，即： l(a)=le(y)-c</p>
<p>（3）求关键活动 </p>
<p>对于每个活动a，求出d(a)=l(a)-e(a)，若d(a)为0，则称活动a为关键活动。对关键活动来说，不存在富余时间。</p>
</li>
</ol>
<p>   <strong>利用关键路径法求AOE网的各关键活动</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">CriticalPath</span>(<span class="title">graph</span>&lt;T, E&gt;&amp; <span class="title">G</span>) &#123;</span>     </span><br><span class="line"><span class="keyword">int</span> i, j, k;   E Ae, Al, dur;     </span><br><span class="line"><span class="keyword">int</span> n = G.NumberOfVertices();     </span><br><span class="line">E *Ve = <span class="keyword">new</span> E[n]; </span><br><span class="line">E *Vl = <span class="keyword">new</span> E[n];    </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) Ve[i] = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;        <span class="comment">//正向计算Ve[]         </span></span><br><span class="line">j = G.getFirstNeighbor(i);         </span><br><span class="line"><span class="keyword">while</span> (j != <span class="number">-1</span>) &#123;           </span><br><span class="line">dur = G.getWeight (i, j); </span><br><span class="line"> <span class="keyword">if</span> (Ve[i]+dur &gt; Ve[j]) Ve[j] = Ve[i]+dur;              </span><br><span class="line"> j = G.getNextNeighbor(i, j);         &#125;     </span><br><span class="line"> &#125;     Vl[n<span class="number">-1</span>] = Ve[n<span class="number">-1</span>];    </span><br><span class="line"> <span class="keyword">for</span> (j = n<span class="number">-2</span>; j &gt; <span class="number">0</span>; j--) &#123;       <span class="comment">//逆向计算Vl[]         </span></span><br><span class="line"> k = G.getFirstNrighbor (j);         </span><br><span class="line"> <span class="keyword">while</span> (k != <span class="number">-1</span>) &#123;         </span><br><span class="line"> dur = G.getWeight (j, k);              </span><br><span class="line"> <span class="keyword">if</span> (Vl[k]-dur &lt; Vl[j]) Vl[j] = Vl[k]-dur;           </span><br><span class="line"> k = G.getNextNeighbor (j, k);             </span><br><span class="line"> &#125;     &#125; </span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;  <span class="comment">//求各活动的e, l         </span></span><br><span class="line"> j = G.getFirstNeighbor (i);         </span><br><span class="line"> <span class="keyword">while</span> (j != <span class="number">-1</span>) &#123;             </span><br><span class="line"> Ae = Ve[i];  </span><br><span class="line"> Al = Vl[k]-G.getWeight(i, j);          </span><br><span class="line"> <span class="keyword">if</span> (Al == Ae)                  </span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;"</span> &lt;&lt; G.getValue(i) &lt;&lt; <span class="string">","</span> &lt;&lt; G.getValue(j) &lt;&lt; “&gt;”&lt;&lt; <span class="string">"是关键活动"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> j = G.getNextNeighbor (i, j);         </span><br><span class="line"> &#125;     </span><br><span class="line"> &#125;  <span class="keyword">delete</span> [] Ve; </span><br><span class="line"> <span class="keyword">delete</span> [] Vl; </span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> </p>
<p>所有顶点按拓扑有序的次序编号。</p>
<p>仅计算 Ve[i] 和 Vl[i] 是不够的，还须计算 e[k] 和 l[k]。</p>
<p>不是任一关键活动加速一定能使整个工程提前。 想使整个工程提前，要考虑各个关键路径上所 有关键活动。</p>
<p>如果任一关键活动延迟，整个工程就要延迟。 </p>
]]></content>
      <categories>
        <category>课内学习</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构笔记（第五章）</title>
    <url>/2021/05/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AC%AC%E4%BA%94%E7%AB%A0%20%EF%BC%89/</url>
    <content><![CDATA[<h1 id="第五章-树"><a href="#第五章-树" class="headerlink" title="第五章 树"></a>第五章 树</h1><h2 id="树和森林的概念"><a href="#树和森林的概念" class="headerlink" title="树和森林的概念"></a>树和森林的概念</h2><p><strong>自由树：</strong> </p>
<p>一棵自由树 Tf 可定义为一个二元组Tf = (V, E)  V = {v1, …, vn} 是由 n (n＞0) 个元素组成的有限非空集合，称为顶点集合。 E = {(vi, vj) | vi, vj ∈V, 1≤i, j≤n} 是n-1个序对的集 合，称为边集合，E 中的元素 (vi, vj）称为边或分支。 </p>
<p><strong>有根树：</strong></p>
<p> 一棵有根树 T，简称为树，它是n (n≥0) 个 结点的有限集合。当n = 0时，T 称为空树；否 则，T 是非空树，记作 T=Ø  (n=0)        T={r,T1,T2,…,Tm}  (n&gt;0). </p>
<p><strong>有根树的特征 :</strong></p>
<p>r 是一个特定的称为根(root)的结点，它只有直 接后继，但没有直接前驱； </p>
<p>根以外的其他结点划分为 m (m  0) 个互不相交 的有限集合T1, T2, …, Tm，每个集合又是一棵树， 并且称之为根的子树。 </p>
<p>每棵子树的根结点有且仅有一个直接前驱，但可 以有0个或多个直接后继。 </p>
<p><strong>注：</strong>树的定义具有递归性，即树中还有树。 </p>
<p><strong>树的基本术语:</strong> </p>
<p>兄弟 ：同一结点的子女互称为兄弟。 </p>
<p>分支结点 ：度不为0的结点即为分支结点，亦 称为非终端结点。 </p>
<p>叶结点 ：度为0的结点即为叶结点，亦称为终 端结点。 </p>
<p>祖先 ：某结点到根结点的路径上的各个结点 都是该结点的祖先。 </p>
<p>子孙 ：某结点的所有下属结点，都是该结点 的子孙。 </p>
<p>结点的层次 ：规定根结点在第一层，其子女 结点的层次等于它的层次加一。以下类推。 </p>
<p>深度： 结点的深度即为结点的层次；离根最 远结点的层次即为树的深度。 </p>
<p>高度 ：规定叶结点的高度为1，其双亲结点 的高度等于它的高度加一。 </p>
<p>树的高度 ：等于根结点的高度，即根结点所 有子女高度的最大值加一。 </p>
<p>有序树 ：树中结点的各棵子树 T0, T1, …是有 次序的，即为有序树。 </p>
<p>无序树 ：树中结点的各棵子树之间的次序是 不重要的，可以互相交换位置。 </p>
<p>森林 ：森林是m（m≥0）棵树的集合。 </p>
<p><strong>树的抽象数据类型</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Tree</span> &#123;</span> </span><br><span class="line"><span class="comment">//对象: 树是由n (≥0) 个结点组成的有限集合。</span></span><br><span class="line"><span class="comment">//在类界面中的 position 是树中结点的地址。</span></span><br><span class="line"><span class="comment">//在顺序存储方式下是下标型, 在链表存储方式下是指针型。</span></span><br><span class="line"><span class="comment">//T 是树结点中存放数据的类型, 要求所有结点的数据类型都是一致的。 </span></span><br><span class="line"><span class="keyword">public</span>:     </span><br><span class="line">Tree ();           </span><br><span class="line">~Tree ();    </span><br><span class="line">BuildRoot (<span class="keyword">const</span> T&amp; value);           <span class="comment">//建立树的根结点   </span></span><br><span class="line"><span class="function"><span class="built_in">position</span> <span class="title">FirstChild</span><span class="params">(<span class="built_in">position</span> p)</span></span>;          <span class="comment">//返回 p 第一个子女地址, 无子女返回 0   </span></span><br><span class="line"><span class="function"><span class="built_in">position</span> <span class="title">NextSibling</span><span class="params">(<span class="built_in">position</span> p)</span></span>;          <span class="comment">//返回 p 下一兄弟地址, 若无下一兄弟返回 0   </span></span><br><span class="line"><span class="function"><span class="built_in">position</span> <span class="title">Parent</span><span class="params">(<span class="built_in">position</span> p)</span></span>;       <span class="comment">//返回 p 双亲结点地址, 若 p 为根返回 0 </span></span><br><span class="line">getData(<span class="built_in">position</span> p);         <span class="comment">//返回结点 p 中存放的值      </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertChild</span><span class="params">(<span class="built_in">position</span> p, T&amp; value)</span></span>;<span class="comment">//在结点p下插入值为 value 的新子女, 若插         </span></span><br><span class="line">                                       <span class="comment">//入失败, 函数返回false, 否则返回true </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteChild</span> <span class="params">(<span class="built_in">position</span> p, <span class="keyword">int</span> i)</span></span>;     <span class="comment">//删除结点 p 的第 i 个子女及其全部子孙结        </span></span><br><span class="line">                                         <span class="comment">//点, 若删除失败, 则返回false, 否则返回true  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteSubTree</span> <span class="params">(<span class="built_in">position</span> t)</span></span>;        <span class="comment">//删除以 t 为根结点的子树      </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span> <span class="params">()</span></span>;        <span class="comment">//判树空否, 若空则返回true, 否则返回false      </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traversal</span> <span class="params">(<span class="keyword">void</span> (*visit)(<span class="built_in">position</span> p))</span></span>;         <span class="comment">//遍历以 p 为根的子树 &#125;;</span></span><br></pre></td></tr></table></figure>

<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>为何要重点研究每结点最多只有两个 “叉” 的树？ </p>
<p>二叉树的结构最简单，规律性最强；</p>
<p>可以证明，所有树都能转为唯一对应的二叉树，不失一般性。 </p>
<p><strong>二叉树的定义</strong></p>
<p>一棵二叉树是结点的一个有限集合，该集合 或者为空，或者是由一个根结点加上两 棵分别称为左子树和右子树的、互不相交的 二叉树组成。 （5种形态）</p>
<p><strong>逻辑结构：</strong></p>
<p> 一对二（1：2） </p>
<p><strong>基本特征:</strong> </p>
<p>① 每个结点最多只有两棵子树（不存在度大于2的结 点）；</p>
<p>② 左子树和右子树次序不能颠倒（有序树</p>
<p><strong>特殊二叉树的定义</strong> </p>
<p><strong>定义1  满二叉树 (Full Binary Tree) ：</strong></p>
<p>每一层结点都达 到了最大个数的二叉树。深度为k的满二叉树有2^k - 1个。 </p>
<p><strong>定义2  完全二叉树 (Complete Binary Tree) :</strong>  </p>
<p>若设二叉树的深度为 k，则共有 k 层。除第 k 层外， 其它各层 (1—k-1) 的结点数都达到最大个数，第k层 从右向左连续缺若干结点，这就是完全二叉树。 </p>
<p>满二叉树和完全二叉树有什么区别?</p>
<p>满二叉树是叶子一个也不少的树，而完全二叉树虽然前n-1层是满的，但最底层却允许在右边缺少连续若干个结点。满二叉树是完全二叉树的一个特例。</p>
<p><strong>二叉树的抽象数据类型</strong> </p>
<p><strong>基本操作:</strong>  </p>
<p>第一类,  查询 ：寻找满足某种特定关系的结点；查询树的属性： 如高度深度，节点个数，状态, 特定节点，极其父子节点。 </p>
<p>第二类,  插入、修改或删除：如在树的当前结点上插入一个新 结点或删除当前结点的孩子结点等。 </p>
<p>第三类, 上述操作必须建立在对树结点能够“遍历”的基础上， 遍历树中每个结点,这里着重介绍。 </p>
<p>遍历：指每个结点都被访问且仅访问一次，不遗漏不重复 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">BinaryTree</span> &#123;</span> <span class="comment">//对象: 结点的有限集合, 二叉树是有序树 </span></span><br><span class="line"><span class="keyword">public</span>:     </span><br><span class="line">BinaryTree ();   <span class="comment">//构造函数   </span></span><br><span class="line">BinaryTree (BinTreeNode&lt;T&gt; *lch,                                </span><br><span class="line">BinTreeNode&lt;T&gt; *rch, T item);   <span class="comment">//构造函数, 以item为根, lch和rch为左、右子树构造一棵二叉树   </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Height</span> <span class="params">()</span></span>;   <span class="comment">//求树高度   </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Size</span> <span class="params">()</span></span>;   <span class="comment">//求树中结点个数 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span> <span class="params">()</span></span>;  <span class="comment">//判二叉树空否？       </span></span><br><span class="line"><span class="function">BinTreeNode&lt;T&gt; *<span class="title">Parent</span> <span class="params">(BinTreeNode&lt;T&gt; *t)</span></span>;       <span class="comment">//求结点 t 的双亲     </span></span><br><span class="line"><span class="function">BinTreeNode&lt;T&gt; *<span class="title">LeftChild</span> <span class="params">(BinTreeNode&lt;T&gt; *t)</span></span>;     <span class="comment">//求结点 t 的左子女      </span></span><br><span class="line"><span class="function">BinTreeNode&lt;T&gt; *<span class="title">RightChild</span> <span class="params">(BinTreeNode&lt;T&gt; *t)</span></span>;   <span class="comment">//求结点 t 的右子女      </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span> <span class="params">(T&amp; item)</span></span>;  <span class="comment">//判断item是否在树中      </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">getData</span> <span class="params">(T&amp; item)</span></span>; <span class="comment">//取得结点数据      </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span> <span class="params">(T item)</span></span>;  <span class="comment">//在树中插入新元素      </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Remove</span> <span class="params">(T item)</span></span>; <span class="comment">//在树中删除元素 </span></span><br><span class="line"><span class="function">BinTreeNode&lt;T&gt; *<span class="title">getRoot</span> <span class="params">()</span></span>; <span class="comment">//取根 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span> <span class="params">(<span class="keyword">void</span> (*visit) (BinTreeNode&lt;T&gt; *t))</span></span>; <span class="comment">//前序遍历, visit是访问函数 void </span></span><br><span class="line">inOrder (<span class="keyword">void</span> (*visit) (BinTreeNode&lt;T&gt; *t));   <span class="comment">//中序遍历, visit是访问函数  void </span></span><br><span class="line">postOrder (<span class="keyword">void</span> (*visit) (BinTreeNode&lt;T&gt; *t));   <span class="comment">//后序遍历, (*visit)是访问函数  void </span></span><br><span class="line">levelOrder (<span class="keyword">void</span> (*visit)(BinTreeNode&lt;T&gt; *t));   <span class="comment">//层次序遍历, visit是访问函数 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>二叉树的性质</strong> </p>
<p><strong>性质1</strong>   若二叉树结点的层次从 1 开始, 则在 二叉树的第 i 层最多有 2^（i-1） 个结点。( i≥1) </p>
<p><strong>性质2</strong>   深度为 k 的二叉树最少有 k 个结点， 最多有 2^k - 1个结点。( k≥1 )     因为每一层最少要有1个结点，因此，最少 结点数为 k。最多结点个数借助性质1：用 求等比级数前k项和的公式。   </p>
<p><strong>性质3</strong>    对任何一棵二叉树，如果其叶结点有 n0 个, 度为 2 的非叶结点有 n2 个,   则有n0＝n2＋1 </p>
<p><strong>性质4</strong>    具有 n (n≥0) 个结点的完全二叉树的深 度为 log(2) (n+1) </p>
<p><strong>性质5</strong>  如将一棵有n个结点的完全二叉树自顶向 下，同一层自左向右连续给结点编号1, 2, …, n， 则有以下关系：  若i = 1, 则 i 无双亲 </p>
<p>若i &gt; 1, 则 i 的双亲为[i／2]</p>
<p>i 的左子女为 2 * i( 如果 i 有左子女的话 )，   i 的右子女为2*i+1 ( 如果 i 有右子女的话 ) </p>
<p>若 i 为奇数, 且i != 1,   则其左兄弟为i-1,  </p>
<p>若 i 为偶数, 且i != n,   则其右兄弟为i+1</p>
<p>若二叉树用二叉链表作存贮结构，则在n个结点的二 叉树链表中只有n-1个非空指针域 </p>
<p>具有n个结点的完全二叉树有[(n-1)／2]或（n-1/2  n/2-1个度为2的结点</p>
<p><strong>二叉树的顺序表示</strong> </p>
<p><strong>顺序存储结构：</strong>用一组地址连续的存储单元存储二 叉树中的数据元素。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树的顺序存储结构的定义如下：</span></span><br><span class="line"><span class="keyword">const</span> MAXSIZE = <span class="number">100</span>; 　<span class="comment">// 暂定二叉树中结点数的最大值为100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ElemType *data;  <span class="comment">// 存储空间基址				        //(初始化时分配空间)</span></span><br><span class="line"><span class="keyword">int</span> nodeNum; 　 <span class="comment">// 二叉树中结点数</span></span><br><span class="line">&#125; SqBiTree; 　<span class="comment">// 二叉树的顺序存储结构</span></span><br></pre></td></tr></table></figure>

<p>按二叉树的结点“自上而下、 从左至右”编号，用一组连 续的存储单元存储。 </p>
<p>问：顺序存储后能否复原成唯一对应的二叉树形状？ </p>
<p>答：若是完全/满二叉树则可以做到唯一复原。   因为根据性质5：可知结点i，左孩子的下标值必为2i， 其右孩子的下标值必为2i＋1. 非完全二叉树要将各层空缺处统统补上“虚结点”，其内容为空。 </p>
<p>缺点：①浪费空间；②插入、删除不便      结论：非完全二叉树不适合进行顺序存储 </p>
<p><strong>二叉树的链表表示（二叉链表）</strong></p>
<p>二叉树结点定义：每个结点有3个数据成员， data域存储结点数据，leftChild和rightChild分 别存放指向左子女和右子女的指针。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树的二叉链表存储简单可以表示</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BiTNode</span> &#123;</span> </span><br><span class="line">ElemType data; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">Lchild</span>, *<span class="title">Rchild</span>;</span> <span class="comment">// 左、右孩子指针 </span></span><br><span class="line">&#125; *BiTree;</span><br></pre></td></tr></table></figure>

<p>一般从根结点开始存储。（相应地，访问树中结点时 也只能从根开始） </p>
<p>含n个结点的二叉链表其中空链域为n+1个 </p>
<p><strong>二叉树的链表表示（三叉链表）</strong> </p>
<p>每个结点增加一个指向双亲的指针parent， 使得查找双亲也很方便。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树c++的类定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">BinTreeNode</span> &#123;</span>       <span class="comment">//二叉树结点类定义   </span></span><br><span class="line">T data;          <span class="comment">//数据域     </span></span><br><span class="line">BinTreeNode&lt;T&gt; *leftChild, *rightChild;                                              <span class="comment">//左子女、右子女链域     </span></span><br><span class="line">BinTreeNode ()                <span class="comment">//构造函数        </span></span><br><span class="line">&#123; leftChild = <span class="literal">NULL</span>;  rightChild = <span class="literal">NULL</span>; &#125; </span><br><span class="line">BinTreeNode (T&amp; x, BinTreeNode&lt;T&gt; *l = <span class="literal">NULL</span>,BinTreeNode&lt;T&gt; *r = <span class="literal">NULL</span>)        </span><br><span class="line">&#123; data = x;  leftChild = l;  rightChild = r; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">BinaryTree</span> &#123;</span>  <span class="comment">//二叉树类定义</span></span><br><span class="line"><span class="keyword">protected</span>:      </span><br><span class="line">BinTreeNode&lt;T&gt; *root;  <span class="comment">//二叉树的根指针      </span></span><br><span class="line">T RefValue;    <span class="comment">//数据输入停止标志 </span></span><br><span class="line"><span class="keyword">public</span>:      </span><br><span class="line">BinaryTree () : root (<span class="literal">NULL</span>) &#123; &#125;   <span class="comment">//构造函数      </span></span><br><span class="line">BinaryTree (T value) : RefValue(value), root(<span class="literal">NULL</span>) &#123; &#125;   </span><br><span class="line">BinaryTree (BinaryTree&lt;T&gt;&amp; s);     <span class="comment">//复制构造函数      </span></span><br><span class="line">~BinaryTree () &#123; destroy(root); &#125;   <span class="comment">//析构函数      </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> root == <span class="literal">NULL</span>;&#125;<span class="comment">//判二叉树空否      </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Height</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> Height(root); &#125;  <span class="comment">//求树高度 </span></span><br><span class="line"><span class="function">BinTreeNode&lt;T&gt; *<span class="title">Parent</span> <span class="params">(BinTreeNode &lt;T&gt; *t)</span>          </span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> (root == <span class="literal">NULL</span> || root ==  t) ?<span class="literal">NULL</span> : Parent (root, t); &#125;  <span class="comment">//返回双亲结点 </span></span><br><span class="line"><span class="function">BinTreeNode&lt;T&gt; *<span class="title">LeftChild</span> <span class="params">(BinTreeNode&lt;T&gt; *t)</span>        </span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> (t != <span class="literal">NULL</span>)？t-&gt;leftChild : <span class="literal">NULL</span>; &#125; </span><br><span class="line"><span class="comment">//返回左子女      </span></span><br><span class="line"><span class="function">BinTreeNode&lt;T&gt; *<span class="title">RightChild</span> <span class="params">(BinTreeNode&lt;T&gt; *t)</span>        </span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> (t != <span class="literal">NULL</span>)？t-&gt;rightChild : <span class="literal">NULL</span>; &#125;</span><br><span class="line"><span class="comment">//返回右子女      </span></span><br><span class="line"><span class="function">BinTreeNode&lt;T&gt; *<span class="title">getRoot</span> <span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> root; &#125;     <span class="comment">//取根 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span> <span class="params">(<span class="keyword">void</span> (*visit) (BinTreeNode&lt;T&gt; *t))</span>           </span></span><br><span class="line"><span class="function"></span>&#123; preOrder (root, visit); &#125;           <span class="comment">//前序遍历      </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span> <span class="params">(<span class="keyword">void</span> (*visit) (BinTreeNode&lt;T&gt; *t))</span>         </span></span><br><span class="line"><span class="function"></span>&#123; inOrder (root, visit); &#125;             <span class="comment">//中序遍历      </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span> <span class="params">(<span class="keyword">void</span> (*visit) (BinTreeNode&lt;T&gt; *t))</span>         </span></span><br><span class="line"><span class="function"></span>&#123; postOrder (root, visit); &#125;         <span class="comment">//后序遍历      </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span> <span class="params">(<span class="keyword">void</span> (*visit)(BinTreeNode&lt;T&gt; *t))</span></span>;</span><br><span class="line"><span class="comment">//层次序遍历      </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">const</span> T item)</span></span>;        <span class="comment">//插入新元素      </span></span><br><span class="line"><span class="function">BinTreeNode&lt;T&gt; *<span class="title">Find</span> <span class="params">(T item)</span> <span class="keyword">const</span></span>;   <span class="comment">//搜索 </span></span><br><span class="line"><span class="keyword">protected</span>:            </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBinTree</span> <span class="params">(istream&amp; in,BinTreeNode&lt;T&gt; *&amp; subTree)</span></span>;</span><br><span class="line"><span class="comment">//从文件读入建树     </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span> <span class="params">(BinTreeNode&lt;T&gt; *&amp; subTree,  T&amp; x)</span></span>;</span><br><span class="line"><span class="comment">//插入    </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span> <span class="params">(BinTreeNode&lt;T&gt; *&amp; subTree)</span></span>;     <span class="comment">//删除    </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span> <span class="params">(BinTreeNode&lt;T&gt; *subTree, T&amp; x)</span></span>;   <span class="comment">// 查找</span></span><br><span class="line"><span class="function">BinTreeNode&lt;T&gt; *<span class="title">Copy</span> <span class="params">(BinTreeNode&lt;T&gt; *r)</span></span>;   <span class="comment">//复制  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Height</span> <span class="params">(BinTreeNode&lt;T&gt; *subTree)</span></span>;        <span class="comment">//返回树高度      </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Size</span> <span class="params">(BinTreeNode&lt;T&gt; *subTree)</span></span>;         <span class="comment">//返回结点数      </span></span><br><span class="line"><span class="function">BinTreeNode&lt;T&gt; *<span class="title">Parent</span> <span class="params">(BinTreeNode&lt;T&gt; *subTree, BinTreeNode&lt;T&gt; *t)</span></span>; <span class="comment">//返回父结点     </span></span><br><span class="line"><span class="function">BinTreeNode&lt;T&gt; *<span class="title">Find</span> <span class="params">(BinTreeNode&lt;T&gt; *subTree, T&amp; x)</span> <span class="keyword">const</span></span>;       <span class="comment">//搜寻x </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traverse</span> <span class="params">(BinTreeNode&lt;T&gt; *subTree, ostream&amp; out)</span></span>;              <span class="comment">//前序遍历输出 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span> <span class="params">(BinTreeNode&lt;T&gt;&amp; subTree,<span class="keyword">void</span> (*visit) (BinTreeNode&lt;T&gt; *t))</span></span>;  <span class="comment">//前序遍历 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span> <span class="params">(BinTreeNode&lt;T&gt;&amp; subTree,<span class="keyword">void</span> (*visit) (BinTreeNode&lt;T&gt; *t))</span></span>;  <span class="comment">//中序遍历 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span> <span class="params">(BinTreeNode&lt;T&gt;&amp; subTree,<span class="keyword">void</span> (*visit) (BinTreeNode&lt;T&gt; *t))</span></span>;<span class="comment">//后序遍历 </span></span><br><span class="line"><span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span> &gt;&gt; (istream&amp; in,BinaryTree&lt;T&gt;&amp; Tree);    <span class="comment">//重载操作：输入 </span></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; out,BinaryTree&lt;T&gt;&amp; Tree);    <span class="comment">//重载操作：输出 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><p>遍历——指按某条搜索路线遍访每个结点，使得 每个结点均被访问一次，而且仅被访问一次（又 称周游）。</p>
<p>遍历用途——它是树结构插入、删除、修改、查 找和排序运算的前提，是二叉树一切运算的基础 和核心。   </p>
<p>遍历方法——牢记一种约定，对每个结点的查看 都是“先左后右” 。 </p>
<p>“遍历”是任何类型均有的操作，对线性结构而言，只有一条搜索路径（因为每个结点均只 有一个后继），故不需要另加讨论。 而二叉树是非线性结构，每个结点有两个后继， 则存在如何遍历即按什么样的搜索路径遍历的问题 </p>
<p>二叉树的遍历就是按某种次序访问树中的结点，要求每个结点访问一次且仅访问一次。遍历可认为是 将一棵树进行线性化的处理。 对“二叉树”而言，可以有两类搜索策略：   1.  先上后下的按层次遍历。  2.  先左（子树）后（子树）的深度遍历。 </p>
<p>若限定子树先左后右访问，则对根的访问时机不同 ，有三种实现方案：           </p>
<p>DLR    先 (根)序遍历            </p>
<p>LDR    中 (根)序遍历            </p>
<p>LRD     后(根)序遍历  </p>
<p><strong>注：</strong>“先、中、后”的意思是指访问的结点D是先于子树出现还是后于子树出现。 </p>
<p><strong>先序遍历二叉树</strong></p>
<p><strong>若二叉树为空，则 空操作；否则 (1) 访问根结点； (2) 先序遍历左子树； (3) 先序遍历右子树。</strong> </p>
<p><strong>中序遍历二叉树</strong> </p>
<p><strong>若二叉树为空， 则空操作；否则 (1) 中序遍历 左子树； (2) 访问根结点； (3) 中序遍历右子树</strong>。</p>
<p><strong>后序遍历二叉树</strong> </p>
<p><strong>若二叉树为空，则 空操作；否则 (1) 后序遍历 左子树； (2) 后序遍历 右子树； (3) 访问根结点</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树C++版递归中序遍历算法 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BinaryTree</span>&lt;T&gt;:</span>:InOrder (BinTreeNode&lt;T&gt; * subTree, <span class="keyword">void</span> (*visit) (BinTreeNode&lt;T&gt; *t)) </span><br><span class="line">&#123;      </span><br><span class="line"><span class="keyword">if</span> (subTree != <span class="literal">NULL</span>) &#123;           </span><br><span class="line">InOrder (subTree-&gt;leftChild, visit);                                                 </span><br><span class="line"><span class="comment">//遍历左子树           </span></span><br><span class="line">visit (subTree);  <span class="comment">//访问根结点           </span></span><br><span class="line">InOrder (subTree-&gt;rightChild, visit);     <span class="comment">//遍历右子树   &#125; </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span> <span class="params">(<span class="keyword">void</span> (*visit) (BinTreeNode&lt;T&gt; *t))</span>         </span></span><br><span class="line"><span class="function"></span>&#123; inOrder (root, visit); &#125;             <span class="comment">//中序遍历 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树递归的c++版前序遍历算法 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">BinaryTree</span>&lt;T&gt;:</span>:PreOrder (BinTreeNode&lt;T&gt; * subTree, <span class="keyword">void</span> (*visit) (BinTreeNode&lt;T&gt; *t)) </span><br><span class="line">&#123;       </span><br><span class="line"><span class="keyword">if</span> (subTree != <span class="literal">NULL</span>) </span><br><span class="line">&#123;  </span><br><span class="line">visit (subTree);  <span class="comment">//访问根结点   </span></span><br><span class="line">PreOrder (subTree-&gt;leftChild, visit);         <span class="comment">//遍历左子树   </span></span><br><span class="line">PreOrder (subTree-&gt;rightChild, visit);         <span class="comment">//遍历右子树   </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span> <span class="params">(<span class="keyword">void</span> (*visit) (BinTreeNode&lt;T&gt; *t))</span>         </span></span><br><span class="line"><span class="function"></span>&#123; PreOrder (root, visit); &#125;             <span class="comment">//先序遍历</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树递归的c++版后序遍历算法 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BinaryTree</span>&lt;T&gt;:</span>:PostOrder (BinTreeNode&lt;T&gt; * subTree, <span class="keyword">void</span> (*visit) (BinTreeNode&lt;T&gt; *t ) ）&#123;  </span><br><span class="line"><span class="keyword">if</span> (subTree != <span class="literal">NULL</span> ) &#123;           </span><br><span class="line">PostOrder (subTree-&gt;leftChild, visit);           <span class="comment">//遍历左子树  </span></span><br><span class="line">PostOrder (subTree-&gt;rightChild, visit);           <span class="comment">//遍历右子树  </span></span><br><span class="line">visit (subTree);          <span class="comment">//访问根结点   </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面我们再给出两个遍历二叉树的技巧： </p>
<p>（1）对一棵二叉树中序遍历时，若我们将二叉树严格地按左  子树的所有结点位于根结点的左侧，右子树的所有结点       位于根右侧的形式绘制，就可以对每个结点做一条垂线，映射到下面的水平线上，由此得到的顺序就是该二 叉树的中序遍历序列。 </p>
<p>（2）任何一棵二叉树都可以将它的外部轮廓用 一条线绘制出来，我们将它称为二叉树的包线 ，这条包线对于理解二叉树的遍历过程很有用 </p>
<p>从虚线的出发点到终点的路径 上，每个结点经过3次。<br>第1次经过时访问＝先序遍历 </p>
<p>第2次经过时访问＝中序遍历 </p>
<p>第3次经过时访问＝后序遍历 </p>
<p> 由此可以看出： </p>
<p>（1）遍历操作实际上是将非线性结构线性化的过 程，其结果为线性序列，并根据采用的遍历顺 序分别称为先序序列、中序序列或后序序列； </p>
<p>（2）深度遍历操作是一个递归的过程，因此， 这三种遍历操作的算法用递归函数实现最简单 。 </p>
<p><strong>利用二叉树前序遍历建立二叉树，以递归方式建立二叉树。</strong></p>
<p>输入结点值的顺序必须对应二叉树结点前序 遍历的顺序。并约定以输入序列中不可能出 现的值作为空结点的值以结束递归, 此值在 RefValue中。例如用“#”或用“-1”表示字 符序列或正整数序列空结点。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BiTree</span>&lt;T&gt;:</span>:Creat(BiNode&lt;T&gt; * &amp;bt) &#123;      </span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; ch;                      <span class="comment">//输入结点的数据信息，假设为字符      </span></span><br><span class="line">if (ch == '# ') bt = NULL;                //建立一棵空树      </span><br><span class="line"><span class="keyword">else</span> &#123;         </span><br><span class="line">bt = <span class="keyword">new</span> BiNode(ch);   <span class="comment">//生成一个结点，数据域为ch        </span></span><br><span class="line"><span class="keyword">if</span> (bt == <span class="literal">NULL</span>) &#123;<span class="built_in">cerr</span> &lt;&lt; “存储分配错!” &lt;&lt; <span class="built_in">endl</span>;  <span class="built_in">exit</span> (<span class="number">1</span>);&#125;      </span><br><span class="line">Creat(bt-&gt;lchild);          <span class="comment">//递归建立左子树       </span></span><br><span class="line">Creat(bt-&gt;rchild);          <span class="comment">//递归建立右子树     &#125;&#125; </span></span><br><span class="line"><span class="function">binNode* <span class="title">BinTree::create</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">char</span> temp ; </span><br><span class="line">binNode* T;  <span class="comment">//读入字符 ，如是空格，结束否则生成节点，左，右子树  </span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;temp ;  </span><br><span class="line"><span class="keyword">if</span> (temp==<span class="string">'@'</span>) <span class="keyword">return</span> <span class="literal">NULL</span> ;  </span><br><span class="line"><span class="keyword">else</span>&#123;    </span><br><span class="line">T =<span class="keyword">new</span> binNode(temp) ;    </span><br><span class="line">T-&gt;lchild=create( );    </span><br><span class="line">T-&gt;rchild=create();    </span><br><span class="line"><span class="keyword">return</span> T;  &#125;</span><br><span class="line">&#125; </span><br><span class="line">BinTree::BinTree(<span class="keyword">void</span>) &#123;   root=create();     &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BinaryTree</span>&lt;T&gt;:</span>:CreateBinTree (istream&amp; in, BinTreeNode&lt;T&gt; *&amp; subTree) </span><br><span class="line">&#123; <span class="comment">//私有函数: 以递归方式建立二叉树。      </span></span><br><span class="line">T item;      </span><br><span class="line"><span class="keyword">if</span> ( !in.eof () ) </span><br><span class="line">&#123;      <span class="comment">//未读完, 读入并建树           </span></span><br><span class="line">in &gt;&gt; item;    <span class="comment">//读入根结点的值       </span></span><br><span class="line"><span class="keyword">if</span> (item != RefValue) &#123;              </span><br><span class="line">subTree = <span class="keyword">new</span> BinTreeNode&lt;T&gt;(item); <span class="comment">//建立根结点              </span></span><br><span class="line"><span class="keyword">if</span> (subTree == <span class="literal">NULL</span>)               </span><br><span class="line">&#123;<span class="built_in">cerr</span> &lt;&lt; “存储分配错!” &lt;&lt; <span class="built_in">endl</span>;  <span class="built_in">exit</span> (<span class="number">1</span>);&#125;           </span><br><span class="line">CreateBinTree (in, subTree-&gt;leftChild);                                    </span><br><span class="line">CreateBinTree (in, subTree-&gt;rightChild); </span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">else</span> subTree = <span class="literal">NULL</span>;    <span class="comment">//封闭指向空子树的指针      </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;;            </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">istream</span>&amp; <span class="title">operator</span> &gt;&gt; (<span class="title">istream</span>&amp; <span class="title">in</span>, <span class="title">BinaryTree</span>&lt;T&gt;&amp; <span class="title">Tree</span>) </span></span><br><span class="line"><span class="class">&#123;</span> <span class="comment">//重载操作: 输入并建立一棵二叉树Tree。in是输入流对象。      </span></span><br><span class="line">CreateBinTree (in, Tree.root);  <span class="comment">//建立二叉树      </span></span><br><span class="line"><span class="keyword">return</span> in; &#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">BinTreeNode</span>&lt;T&gt; *<span class="title">BinaryTree</span>&lt;T&gt;:</span>: Parent (BinTreeNode &lt;T&gt; *subTree, BinTreeNode &lt;T&gt; *t) &#123;     </span><br><span class="line"><span class="comment">//从结点 subTree 开始, 搜索结点 t 的双亲, 若找            </span></span><br><span class="line"><span class="comment">//到则返回双亲结点地址, 否则返回NULL      </span></span><br><span class="line"><span class="keyword">if</span> (subTree == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;      </span><br><span class="line"><span class="keyword">if</span> (subTree-&gt;leftChild == t || subTree-&gt;rightChild == t)            </span><br><span class="line"><span class="keyword">return</span> subTree;                  <span class="comment">//找到, 返回父结点地址      </span></span><br><span class="line">BinTreeNode &lt;T&gt; *p;     </span><br><span class="line"><span class="keyword">if</span> ((p = Parent (subTree-&gt;leftChild, t)) != <span class="literal">NULL</span>)             </span><br><span class="line"><span class="keyword">return</span> p;                               <span class="comment">//递归在左子树中搜索      </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> Parent (subTree-&gt;rightChild, t);               <span class="comment">//递归在左子树中搜索 &#125;; </span></span><br><span class="line"><span class="function">BinTreeNode&lt;T&gt; *<span class="title">Parent</span> <span class="params">(BinTreeNode &lt;T&gt; *t)</span>          </span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> (root == <span class="literal">NULL</span> || root ==  t) ? <span class="literal">NULL</span> : Parent (root, t); &#125;  <span class="comment">//返回双亲结点 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BinaryTree</span>&lt;T&gt;:</span>:destroy (BinTreeNode&lt;T&gt; * subTree) &#123; </span><br><span class="line"><span class="comment">//私有函数: 删除根为subTree的子树     </span></span><br><span class="line"><span class="keyword">if</span> (subTree != <span class="literal">NULL</span>) &#123;          </span><br><span class="line">destroy (subTree-&gt;leftChild);     <span class="comment">//删除左子树         </span></span><br><span class="line">destroy (subTree-&gt;rightChild);   <span class="comment">//删除右子树         </span></span><br><span class="line"><span class="keyword">delete</span> subTree;     <span class="comment">//删除根结点  </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;; </span><br><span class="line">~BinaryTree () &#123; destroy(root); &#125;   <span class="comment">//析构函数</span></span><br></pre></td></tr></table></figure>

<p><strong>二叉树遍历的非递归算法</strong> </p>
<p><strong>前序遍历——非递归算法（伪代码）</strong> </p>
<p>1.栈s初始化；</p>
<p>2.循环直到p为空且栈s为空   </p>
<p>  2.1 当p不空时循环   </p>
<p>​     2.1.1 输出p-&gt;data;      </p>
<p>​     2.1.2 将指针p的值保存到栈中；    </p>
<p>​     2.1.3 继续遍历p的左子树  </p>
<p>  2.2 如果栈s不空，则   </p>
<p>​     2.2.1 将栈顶元素弹出至p；   </p>
<p>​     2.2.2 准备遍历p的右子树； </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BinaryTree</span>&lt;T&gt;:</span>:preOrder (<span class="keyword">void</span> (*visit) (BinTreeNode&lt;T&gt; *t))</span><br><span class="line">&#123;      </span><br><span class="line"> <span class="built_in">stack</span>&lt;BinTreeNode&lt;T&gt;*&gt; S;           </span><br><span class="line"> BinTreeNode&lt;T&gt; *p = root;   </span><br><span class="line"> <span class="keyword">do</span> &#123;          <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123; <span class="comment">//遍历指针向左下移动                </span></span><br><span class="line">              visit(p);                </span><br><span class="line">              S.Push (p);   <span class="comment">//该子树沿途结点进栈               </span></span><br><span class="line">              p = p-&gt;leftChild;                  &#125;          </span><br><span class="line">    <span class="keyword">if</span> (!S.IsEmpty()) &#123;  <span class="comment">//栈不空时退栈               </span></span><br><span class="line">    S.Pop (p);   <span class="comment">//退栈                </span></span><br><span class="line">    p = p-&gt;rightChild; <span class="comment">//遍历指针进到右子女   &#125;      </span></span><br><span class="line">    &#125; <span class="keyword">while</span> (p != <span class="literal">NULL</span> || !S.IsEmpty ()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>中序遍历——非递归算法</strong><br>在二叉树的中序遍历中，访问结点的操作发生在 该结点的左子树遍历完毕并准备遍历右子树时， •所以，在遍历过程中遇到某结点时并不能立即访 问它，而是将它压栈，等到它的左子树遍历完毕后， 再从栈中弹出并访问之。</p>
<p>中序遍历的非递归算法只需将前序遍历的非递归 算法中的访问语句，移到S.Pop (p)出栈之后即可。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BinaryTree</span>&lt;T&gt;:</span>:InOrder (<span class="keyword">void</span> (*visit) (BinTreeNode&lt;T&gt; *t)) </span><br><span class="line">&#123;      <span class="built_in">stack</span>&lt;BinTreeNode&lt;T&gt;*&gt; S;         </span><br><span class="line">      BinTreeNode&lt;T&gt; *p = root;      </span><br><span class="line">         <span class="keyword">do</span> &#123;           <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123; <span class="comment">//遍历指针向左下移动                </span></span><br><span class="line">         S.Push (p);   <span class="comment">//该子树沿途结点进栈               </span></span><br><span class="line">         p = p-&gt;leftChild;           &#125;           </span><br><span class="line">         <span class="keyword">if</span> (!S.IsEmpty()) &#123;  <span class="comment">//栈不空时退栈                </span></span><br><span class="line">         S.Pop (p);  </span><br><span class="line">         visit (p); <span class="comment">//退栈, 访问                </span></span><br><span class="line">         p = p-&gt;rightChild; <span class="comment">//遍历指针进到右子女           &#125;      </span></span><br><span class="line">           &#125; <span class="keyword">while</span> (p != <span class="literal">NULL</span> || !S.IsEmpty ()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>后序遍历的非递归算法</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后序遍历的非递归算法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BinaryTree</span>&lt;T&gt;:</span>: PostOrder (<span class="keyword">void</span> (*visit) (BinTreeNode&lt;T&gt; *t) </span><br><span class="line">&#123;      </span><br><span class="line">  Stack&lt;stkNode&lt;T&gt;&gt; S;  </span><br><span class="line">  stkNode&lt;T&gt; w;       </span><br><span class="line">  BinTreeNode&lt;T&gt; * p = root;     <span class="comment">//p是遍历指针  </span></span><br><span class="line">  <span class="keyword">do</span> &#123;   </span><br><span class="line">      <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;        </span><br><span class="line">      w.ptr = p; </span><br><span class="line">      w.tag = L;  </span><br><span class="line">      S.Push (w);          </span><br><span class="line">      p = p-&gt;leftChild; &#125;   </span><br><span class="line">      <span class="keyword">int</span> continue1 = <span class="number">1</span>;     <span class="comment">//继续循环标记, 用于R </span></span><br><span class="line">      <span class="keyword">while</span> (continue1 &amp;&amp; !S.IsEmpty ())   &#123;       </span><br><span class="line">      S.Pop (w);  p = w.ptr;     </span><br><span class="line">      <span class="keyword">switch</span> (w.tag) &#123;    <span class="comment">//判断栈顶的tag标记      </span></span><br><span class="line">      <span class="keyword">case</span> L:  w.tag = R;  S.Push (w);          </span><br><span class="line">      continue1 = <span class="number">0</span>;                </span><br><span class="line">      p = p-&gt;rightChild;  <span class="keyword">break</span>;            </span><br><span class="line">      <span class="keyword">case</span> R:  visit (p);   <span class="keyword">break</span>;              </span><br><span class="line">                     &#125;    </span><br><span class="line">                                             &#125;     </span><br><span class="line">       &#125; <span class="keyword">while</span> (!S.IsEmpty ()); <span class="comment">//继续遍历其他结点      </span></span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>层次序遍历的算法</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BinaryTree</span>&lt;T&gt;:</span>: levelOrder (<span class="keyword">void</span> (*visit) (BinTreeNode&lt;T&gt; *t)) &#123;      </span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;      </span><br><span class="line">Queue&lt;BinTreeNode&lt;T&gt; * &gt; Q;      </span><br><span class="line">BinTreeNode&lt;T&gt; *p = root;          </span><br><span class="line">Q.EnQueue (p);       </span><br><span class="line"><span class="keyword">while</span> (!Q.IsEmpty ()) &#123;          </span><br><span class="line">Q.DeQueue (p);            </span><br><span class="line">visit(p);           </span><br><span class="line"><span class="keyword">if</span> (p-&gt;leftChild != <span class="literal">NULL</span>) Q.EnQueue (p-&gt;leftChild);           </span><br><span class="line"><span class="keyword">if</span> (p-&gt;rightChild != <span class="literal">NULL</span>) Q.EnQueue (p-&gt;rightChild);           &#125;      &#125;;             </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;//判断是否完全二叉树,是则返回1,否则返回0  </span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">levelOrder</span> (<span class="title">BitTreeNode</span>&lt;T&gt; * <span class="title">root</span>) &#123;</span>      </span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;     </span><br><span class="line">Queue&lt;BinTreeNode&lt;T&gt; *&gt; Q;   </span><br><span class="line">BinTreeNode&lt;T&gt; *p = root;          </span><br><span class="line">Q.EnQueue (p);        </span><br><span class="line"><span class="keyword">while</span> (!Q.IsEmpty ())   &#123;   </span><br><span class="line">Q.DeQueue (p);        </span><br><span class="line"><span class="keyword">if</span>(!p) flag=<span class="number">1</span>;      </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(flag)<span class="keyword">return</span> <span class="number">0</span>;         </span><br><span class="line"><span class="keyword">else</span> &#123;  Q.EnQueue (p-&gt;leftChild);                      </span><br><span class="line">Q.EnQueue (p-&gt;rightChild);  &#125; &#125;        </span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;  &#125;</span><br></pre></td></tr></table></figure>



<h2 id="二叉树的计数"><a href="#二叉树的计数" class="headerlink" title="二叉树的计数"></a>二叉树的计数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设计算法按前序次序打印二叉树中的叶子结点。 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiNode *root)</span> </span>&#123;     </span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;     </span><br><span class="line"><span class="keyword">else</span> &#123;         </span><br><span class="line"><span class="keyword">if</span> (root-&gt;lchild ==<span class="literal">NULL</span> &amp;&amp; root-&gt;rchild==<span class="literal">NULL</span>)                </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;root-&gt;data;        </span><br><span class="line">PreOrder(root-&gt;lchild);         </span><br><span class="line">PreOrder(root-&gt;rchild);    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//设计算法求二叉树中的叶子结点个数。 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">CountLeaf</span> <span class="params">(BiNode * T)</span> </span>&#123;<span class="comment">// 先序遍历二叉树，以 count 返回二叉树中叶子结点数    </span></span><br><span class="line"><span class="keyword">if</span> ( T ==null) <span class="keyword">return</span> <span class="number">0</span>;     </span><br><span class="line"><span class="keyword">else</span>  <span class="keyword">if</span> ((!T-&gt;Lchild)&amp;&amp; (!T-&gt;Rchild))                             </span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">// 对叶子结点计数          </span></span><br><span class="line"><span class="keyword">else</span>&#123;                 </span><br><span class="line"><span class="keyword">int</span> a=CountLeaf( T-&gt;Lchild) ;                </span><br><span class="line"><span class="keyword">int</span> b = CountLeaf( T-&gt;Rchild);                  </span><br><span class="line"><span class="keyword">return</span> a+b;   </span><br><span class="line">    &#125;               </span><br><span class="line">  &#125;  </span><br><span class="line">&#125; <span class="comment">// CountLeaf  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountLeaf</span> <span class="params">(BiNode * T, <span class="keyword">int</span>&amp; count)</span> </span>&#123;<span class="comment">// 先序遍历二叉树，以 count 返回二叉树中叶子结点数 </span></span><br><span class="line"><span class="keyword">if</span> ( T ) &#123;    </span><br><span class="line"><span class="keyword">if</span> ((!T-&gt;Lchild)&amp;&amp; (!T-&gt;Rchild))     count++;   <span class="comment">// 对叶子结点计数     </span></span><br><span class="line"><span class="keyword">else</span>&#123;                 </span><br><span class="line">CountLeaf( T-&gt;Lchild, count);          </span><br><span class="line">CountLeaf( T-&gt;Rchild, count);                         </span><br><span class="line">    &#125;            </span><br><span class="line">  &#125; <span class="comment">// if        </span></span><br><span class="line">&#125; <span class="comment">// CountLeaf</span></span><br></pre></td></tr></table></figure>

<p>由先序序列确定根结点    再由中序序列找出左右子树。  可唯一确定一棵二叉树！ </p>
<p>已知后序序列和中序序列也可以唯一确定一棵二叉树 。</p>
<h2 id="树与森林"><a href="#树与森林" class="headerlink" title="树与森林"></a>树与森林</h2><p><strong>树的存储表示</strong> </p>
<p>1、广义表表示 </p>
<p>2、父指针表示 </p>
<p>树中结点的存放顺序一般不做特殊要求，但 为了操作实现的方便，有时也会规定结点的 存放顺序。 </p>
<p>此存储结构找父节点的时间复杂度为O(1),但 找子女需遍历整个数组。 </p>
<p>3、子女链表表示 </p>
<p>无序树情形链表中各结点顺序任意，有序树 必须自左向右链接各个子女结点。 </p>
<p>4、子女-兄弟表示 </p>
<p> 也称为树的二叉树表示。</p>
<p> firstChild 指向该结点的第一个子女结点。无 序树时，可任意指定一个结点为第一个子女。</p>
<p> nextSibling 指向该结点的下一个兄弟。任一 结点在存储时总是有顺序的。 </p>
<p>若想找某结点的所有子女，可先找firstChild, 再反复用 nextSibling 沿链扫描。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用子女-兄弟表示的 树的类定义 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">TreeNode</span> &#123;</span>   <span class="comment">//树的结点类     </span></span><br><span class="line">T data;    <span class="comment">//结点数据     </span></span><br><span class="line">TreeNode&lt;T&gt; *firstChild, *nextSibling;          <span class="comment">//子女及兄弟指针     </span></span><br><span class="line">TreeNode (T value = <span class="number">0</span>, TreeNode&lt;T&gt; *fc = NULLTreeNode&lt;T&gt; *ns = <span class="literal">NULL</span>)   <span class="comment">//构造函数      : data (value), firstChild (fc), nextSibling (ns) &#123; &#125; &#125;; </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Tree</span> &#123;</span>   <span class="comment">//树类 </span></span><br><span class="line"><span class="keyword">private</span>:      </span><br><span class="line">TreeNode&lt;T&gt; *root, *current;  <span class="comment">//根指针及当前指针      </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span> <span class="params">(TreeNode&lt;T&gt; *p, T value)</span></span>;  <span class="comment">//在以p为根的树中搜索value     </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RemovesubTree</span> <span class="params">(TreeNode&lt;T&gt; *p)</span></span>; <span class="comment">//删除以p为根的子树      </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FindParent</span> <span class="params">(TreeNode&lt;T&gt; *t, TreeNode&lt;T&gt; *p)</span></span>; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">Tree () &#123; root = current = <span class="literal">NULL</span>; &#125; <span class="comment">//构造函数      </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Root</span> <span class="params">()</span></span>;            <span class="comment">//置根结点为当前结点     </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> root == <span class="literal">NULL</span>; &#125;     </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FirstChild</span> <span class="params">()</span></span>;       <span class="comment">//将当前结点的第一个子女置为当前结点  </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">NextSibling</span> <span class="params">()</span></span>;       <span class="comment">//将当前结点的下一个兄弟置为当前结点     </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Parent</span> <span class="params">()</span></span>;    <span class="comment">//将当前结点的双亲置为当前结点      </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span> <span class="params">(T value)</span></span>;       <span class="comment">//搜索含value的结点, 使之成为当前结点     </span></span><br><span class="line">……    <span class="comment">//树的其他公共操作 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子女-兄弟链表常用操作的实现 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;  <span class="title">bool</span> <span class="title">Tree</span>&lt;T&gt;:</span>:Parent () &#123; <span class="comment">//置当前结点的双亲结点为当前结点      TreeNode&lt;T&gt; *p = current;      </span></span><br><span class="line"><span class="keyword">if</span> (current == <span class="literal">NULL</span> || current == root)         </span><br><span class="line">&#123; current = <span class="literal">NULL</span>;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;                 <span class="comment">//空树或根无双亲    </span></span><br><span class="line"><span class="keyword">return</span> FindParent (root, p);     <span class="comment">//从根开始找*p的双亲结点 </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">Tree</span>&lt;T&gt;:</span>: FindParent (TreeNode&lt;T&gt; *t, TreeNode&lt;T&gt; *p) &#123; <span class="comment">//在根为*t的树中找*p的双亲, 并置为当前结点     </span></span><br><span class="line">TreeNode&lt;T&gt; *q = t-&gt;firstChild;     <span class="comment">//*q是*t长子      </span></span><br><span class="line"><span class="keyword">bool</span> succ;     </span><br><span class="line"><span class="keyword">while</span> (q != <span class="literal">NULL</span> &amp;&amp; q != p) &#123;   <span class="comment">//扫描兄弟链          </span></span><br><span class="line"><span class="keyword">if</span> ((succ = FindParent (q, p)) == <span class="literal">true</span>)               </span><br><span class="line"><span class="keyword">return</span> succ; <span class="comment">//递归搜索以*q为根的子树        </span></span><br><span class="line">q = q-&gt;nextSibling;      &#125; </span><br><span class="line"><span class="keyword">if</span> (q != <span class="literal">NULL</span> &amp;&amp; q == p) &#123;           </span><br><span class="line">current = t;  <span class="keyword">return</span> <span class="literal">true</span>;      &#125;      </span><br><span class="line"><span class="keyword">else</span> &#123; current = <span class="literal">NULL</span>;  <span class="keyword">return</span> <span class="literal">false</span>; &#125;   <span class="comment">//未找到 &#125;; </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">Tree</span>&lt;T&gt;:</span>:FirstChild () &#123; <span class="comment">//在树中找当前结点的长子, 并置为当前结点     </span></span><br><span class="line"><span class="keyword">if</span> (current &amp;&amp; current-&gt;firstChild )          </span><br><span class="line">&#123; current = current-&gt;firstChild;  <span class="keyword">return</span> <span class="literal">true</span>; &#125;     </span><br><span class="line">current = <span class="literal">NULL</span>; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;  </span></span><br><span class="line"><span class="class"> <span class="title">bool</span> <span class="title">Tree</span>&lt;T&gt;:</span>:NextSibling () &#123; <span class="comment">//在树中找当前结点的兄弟, 并置为当前结点      </span></span><br><span class="line"> <span class="keyword">if</span> (current &amp;&amp; current-&gt;nextSibling) &#123;           </span><br><span class="line"> current = current-&gt;nextSibling;           </span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>;      &#125;      </span><br><span class="line"> current = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>树、森林与二叉树的转换</strong> </p>
<p>树：兄弟关系       二叉树：双亲和右孩子 </p>
<p>树：双亲和长子   二叉树：双亲和左孩子 </p>
<p><strong>树转换为二叉树</strong><br>⑴加线——树中所有相邻兄弟之间加一条连线。</p>
<p>⑵去线——对树中的每个结点，只保留它与第一个 孩子结点之间的连线，删去它与其它孩子结点之间 的连线。  </p>
<p>⑶层次调整——以根结点为轴心，将树顺时针转动 一定的角度，使之层次分明。 </p>
<p>将一般树化为二叉树表示就是用树的子女-兄 弟表示来存储树的结构。</p>
<p>森林与二叉树表示的转换可以借助树的二叉树 表示来实现。 </p>
<p><strong>森林转换为二叉树</strong>  </p>
<p>⑴ 将森林中的每棵树转换成二叉树；</p>
<p>⑵ 从第二棵二叉树开始，依次把后一棵二叉树的根 结点作为前一棵二叉树根结点的右孩子，当所有二 叉树连起来后，此时所得到的二叉树就是由森林转 换得到的二叉树。 </p>
<p><strong>二叉树转换为树或森林</strong><br>⑴ 加线——若某结点x是其双亲y的左孩子，则把结点x 的右孩子、右孩子的右孩子、……，都与结点y用线连 起来 </p>
<p>⑵ 去线——删去原二叉树中所有的双亲结点与右孩子结 点的连线</p>
<p>⑶ 层次调整——整理由⑴、⑵两步所得到的树或森林， 使之层次分明。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//树的先根次序遍历的递归算法 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;  <span class="title">void</span> <span class="title">Tree</span>&lt;T&gt;:</span>: PreOrder ( <span class="keyword">void</span> (*visit) (BinTreeNode&lt;T&gt; *t) ) &#123;  <span class="comment">//以当前指针current为根, 先根次序遍历      </span></span><br><span class="line"><span class="keyword">if</span> (!IsEmpty ()) &#123;          <span class="comment">//树非空          </span></span><br><span class="line">visit (current);  <span class="comment">//访问根结点           </span></span><br><span class="line">TreeNode&lt;T&gt; *p = current;     <span class="comment">//暂存当前指针          </span></span><br><span class="line">current = current-&gt;firstChild;  <span class="comment">//第一棵子树          </span></span><br><span class="line"><span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;               </span><br><span class="line">PreOrder (visit); <span class="comment">//递归先根遍历子树             </span></span><br><span class="line">current = current-&gt;nextSibling;  &#125;          </span><br><span class="line">current = p;   <span class="comment">//恢复当前指针    &#125;</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//树的后根次序遍历的递归算法 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Tree</span>&lt;T&gt; :</span>:  PostOrder (<span class="keyword">void</span> (*visit) (BinTreeNode&lt;T&gt; *t)) &#123; <span class="comment">//以当前指针current为根, 按后根次序遍历树   </span></span><br><span class="line"><span class="keyword">if</span> ( ! IsEmpty () ) &#123;                         <span class="comment">//树非空           </span></span><br><span class="line">TreeNode&lt;T&gt; *p = current;     <span class="comment">//保存当前指针          </span></span><br><span class="line">current = current-&gt;firstChild;   <span class="comment">//第一棵子树           </span></span><br><span class="line"><span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;        <span class="comment">//逐棵子树             </span></span><br><span class="line">PostOrder (visit);               </span><br><span class="line">current = current-&gt;nextSibling;           &#125;        </span><br><span class="line">current = p;           <span class="comment">//恢复当前指针       </span></span><br><span class="line">visit (current);        <span class="comment">//访问根结点      &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先（层次次序）遍历 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;  <span class="title">void</span> <span class="title">Tree</span>&lt;T&gt;:</span>: LevelOrder(<span class="keyword">void</span> (*visit) (BinTreeNode&lt;T&gt; *t) ) &#123; </span><br><span class="line"><span class="comment">//按广度优先次序分层遍历树, 树的根结点是 //当前指针current。         </span></span><br><span class="line">Queue&lt;TreeNode&lt;T&gt;*&gt; Q; TreeNode&lt;T&gt; *p; <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;        <span class="comment">//树不空       </span></span><br><span class="line">p = current;                             <span class="comment">//保存当前指针           </span></span><br><span class="line">Q.EnQueue (current);             <span class="comment">//根结点进队列    &#125;  </span></span><br><span class="line"><span class="keyword">while</span> (!Q.IsEmpty ()) &#123;   </span><br><span class="line">Q.DeQueue (current);        <span class="comment">//退出队列   </span></span><br><span class="line">visit (current);                    <span class="comment">//访问之  </span></span><br><span class="line">current = current-&gt;firstChild; </span><br><span class="line"><span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;  </span><br><span class="line">Q.EnQueue (current); </span><br><span class="line">current = current-&gt;nextSibling; &#125;  </span><br><span class="line">current = p; <span class="comment">//恢复算法开始的当前指针 &#125; </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>森林的遍历</strong> </p>
<p>森林的遍历也分为深度优先遍历和广度优先 遍历，深度优先遍历又可分为先根次序遍历 和后根次序遍历。 </p>
<p>森林的先根次序遍历的结果序列 相当于对应二叉树的前序遍历结果。 </p>
<p>森林的后根次序遍历的结果序列 相当于对应二叉树中序遍历的结果。</p>
<h2 id="Huffman树"><a href="#Huffman树" class="headerlink" title="Huffman树"></a>Huffman树</h2><p><strong>带权路径长度 (Weighted Path Length, WPL)</strong></p>
<p>在很多应用问题中为树的叶结点赋予一个权值，用于表示出现频度、概率值等。因此，在问题处理中把叶结点定义得不同于非叶结点，把叶结点看成“外结点”，非叶结点看成“内结点”。这样的二叉树称为扩充二叉树。<br>扩充二叉树中只有度为 2 的内结点和度为 0的外结点。根据二叉树的性质，有 n 个外结点就有 n-1 个内结点，总结点数为2n-1。</p>
<p>若一棵扩充二叉树有 n 个外结点，第 i 个外结点的权值为wi，它到根的路径长度为li，则该外结点到根的带权路径长度为wi*li。<br>扩充二叉树的带权路径长度定义为树的各外结点到根的带权路径长度之和。</p>
<p>WPL=wi*li（求和，i从1到n）</p>
<p>对于同样一组权值，如果放在外结点上，组织方式不同，带权路径长度也不同。</p>
<p>带权路径长度达到最小的扩充二叉树即为Huffman树。<br>在Huffman树中，权值大的结点离根最近。</p>
<p><strong>Huffman树的构造算法</strong></p>
<p>1.由给定 n 个权值 {w0, w1, w2, …, wn-1}，构造 具有 n 棵扩充二叉树的森林 F = { T0, T1, T2,<br>    …, Tn-1 }，其中每棵扩充二叉树 Ti 只有一个带权值 wi 的根结点, 其左、右子树均为空。    </p>
<p>2.重复以下步骤, 直到 F 中仅剩一棵树为止：</p>
<p>在 F 中选取两棵根结点的权值最小的扩充二叉树,    做为左、右子树构造一棵新的二叉树。置新的二叉树的根结点的权值为其左、右子树上根结点的权值之和。</p>
<p>在 F 中删去这两棵二叉树。</p>
<p>把新的二叉树加入 F。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Huffman树的类定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"heap.h"</span></span></span><br><span class="line"><span class="keyword">const</span>  <span class="keyword">int</span> DefaultSize = <span class="number">20</span>;	<span class="comment">//缺省权值集合大小</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">HuffmanNode</span> &#123;</span>		<span class="comment">//树结点的类定义</span></span><br><span class="line">     E data;				<span class="comment">//结点数据</span></span><br><span class="line">	 HuffmanNode&lt;T, E&gt; *parent;</span><br><span class="line">     HuffmanNode&lt;T, E&gt; *leftChild, *rightChild;	          </span><br><span class="line">                                       <span class="comment">//左、右子女和父结点指针</span></span><br><span class="line">	 HuffmanNode () : Parent(<span class="literal">NULL</span>), leftChild(<span class="literal">NULL</span>),</span><br><span class="line">          rightChild(<span class="literal">NULL</span>) &#123; &#125;	<span class="comment">//构造函数</span></span><br><span class="line">HuffmanNode (E elem,                  <span class="comment">//构造函数</span></span><br><span class="line">         HuffmanNode&lt;T, E&gt; *pr = <span class="literal">NULL</span>, </span><br><span class="line">         HuffmanNode&lt;T, E&gt; *left = <span class="literal">NULL</span>,		</span><br><span class="line">	     HuffmanNode&lt;T, E&gt; *right = <span class="literal">NULL</span>) </span><br><span class="line">             : data (elem), parent (pr), leftChild (left),  </span><br><span class="line">               rightChild (right) &#123; &#125;	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,  <span class="title">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">HuffmanTree</span> &#123;</span>		<span class="comment">//Huffman树类定义</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     HuffmanTree (E w[], <span class="keyword">int</span> n);	<span class="comment">//构造函数</span></span><br><span class="line">～HuffmanTree() &#123; <span class="function"><span class="keyword">delete</span> <span class="title">Tree</span><span class="params">(root)</span></span>;&#125;  <span class="comment">//析构函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">     HuffmanNode&lt;T, E&gt; *root;	     <span class="comment">//树的根</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">deleteTree</span> <span class="params">(HuffmanNode&lt;T, E&gt; *t)</span></span>;			<span class="comment">//删除以 t 为根的子树</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">mergeTree</span> <span class="params">(HuffmanNode&lt;T, E&gt;&amp; ht1, 		HuffmanNode&lt;T, E&gt;&amp; ht2,   </span></span></span><br><span class="line">          HuffmanNode&lt;T, E&gt; *&amp; parent)；</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立Huffman树的算法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">HuffmanTree</span>&lt;T, E&gt;:</span>:HuffmanTree (E w[], <span class="keyword">int</span> n) &#123;</span><br><span class="line"><span class="comment">//给出 n 个权值w[1]～w[n], 构造Huffman树</span></span><br><span class="line">     minHeap&lt;T, E&gt; hp; 	 <span class="comment">//使用最小堆存放森林</span></span><br><span class="line">     HuffmanNode&lt;T, E&gt; *parent, &amp;first, &amp;second; </span><br><span class="line">     HuffmanNode&lt;T, E&gt; *NodeList = </span><br><span class="line">             <span class="keyword">new</span> HuffmanNode&lt;T,E&gt;[n];    <span class="comment">//森林</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">          	NodeList[i].data = w[i+<span class="number">1</span>];</span><br><span class="line">		NodeList[i].leftChild = <span class="literal">NULL</span>;         </span><br><span class="line">          NodeList[i].rightChild = <span class="literal">NULL</span>;</span><br><span class="line">          NodeList[i].parent = <span class="literal">NULL</span>;</span><br><span class="line">          hp.Insert(NodeList[i]);	<span class="comment">//插入最小堆中</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;	<span class="comment">//n-1趟, 建Huffman树</span></span><br><span class="line">          hp.Remove (first); 		<span class="comment">//根权值最小的树</span></span><br><span class="line">          hp.Remove (second);	<span class="comment">//根权值次小的树</span></span><br><span class="line">		merge (first, second, parent);	<span class="comment">//合并</span></span><br><span class="line">          hp.Insert (*parent);		<span class="comment">//重新插入堆中</span></span><br><span class="line">          root = parent;		<span class="comment">//建立根结点</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">HuffmanTree</span>&lt;T, E&gt;:</span>:</span><br><span class="line">mergeTree (HuffmanNode&lt;T, E&gt;&amp; bt1, 	</span><br><span class="line">         HuffmanNode&lt;T, E&gt;&amp; bt2, </span><br><span class="line">         HuffmanNode&lt;T, E&gt; *&amp; parent) &#123;</span><br><span class="line">     parent = <span class="keyword">new</span> E;</span><br><span class="line">     parent-&gt;leftChild = &amp;bt1;</span><br><span class="line">     parent-&gt;rightChild = &amp;bt2;</span><br><span class="line">	 parent-&gt;data.key =</span><br><span class="line"> 	        bt1.root-&gt;data.key+bt2.root-&gt;data.key;</span><br><span class="line">     bt1.root-&gt;parent = bt2.root-&gt;parent = parent; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//采用静态链表的Huffman树</span></span><br><span class="line">     <span class="keyword">const</span>  <span class="keyword">int</span> n = <span class="number">20</span>;</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">int</span> m = <span class="number">2</span>*n<span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">         <span class="keyword">float</span> weight;</span><br><span class="line">         <span class="keyword">int</span> parent, lchild, rchild;</span><br><span class="line">     &#125; HTNode;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">typedef</span> HTNode HuffmanTree[m];</span><br><span class="line"><span class="comment">//建立Huffman树的算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateHuffmanTree</span> <span class="params">(HuffmanTree T,  </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">float</span> fr[ ], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) T[i].weight = fr[i];</span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        T[i].parent = T[i].lchild = T[i].rchild = <span class="number">-1</span>;</span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">for</span> (i = n; i &lt; m; i++) &#123;           <span class="comment">//求n-1次根</span></span><br><span class="line">          <span class="keyword">int</span> min1 = min2 = MaxNum;</span><br><span class="line">          <span class="keyword">int</span> pos1, pos2;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)    <span class="comment">//检测前 i 棵树</span></span><br><span class="line"><span class="keyword">if</span> (T[j].parent == <span class="number">-1</span>)          <span class="comment">//可参选的树根</span></span><br><span class="line">                    <span class="keyword">if</span> (T[j].weight &lt; min1) &#123;            <span class="comment">//选最小</span></span><br><span class="line">                         pos2 = pos1;  min2 = min1;</span><br><span class="line">                         pos1 = j;  min1 = T[j].weight;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (T[j].weight &lt; min2)      <span class="comment">//选次小</span></span><br><span class="line">                         &#123; pos2 = j;  min2 = T[j].weight; &#125;</span><br><span class="line">          T[i].lchild = pos1;  T[i].rchild = pos2;</span><br><span class="line">          T[i].weight = T[pos1].weight+T[pos2].weight;</span><br><span class="line">          T[pos1].parent = T[pos2].parent = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>最佳判定树</strong></p>
<p>利用Huffman树，可以在构造判定树（决策树）时让平均判定（比较）次数达到最小。<br>判定树是一棵扩展二叉树，外结点是比较结果，内结点是比较过程，外结点所带权值是概率。</p>
<p><strong>Huffman编码</strong></p>
<p>主要用途是实现数据压缩。设给出一段报文：<br>CAST  CAST  SAT  AT  A  TASA<br>字符集合是 { C, A, S, T }，各个字符出现的频度（次数）是 W＝{ 2, 7, 4, 5 }。<br>若给每个字符以等长编码（2位二进制足够）<br>A : 00   T : 10    C : 01    S : 11<br>则总编码长度为 ( 2+7+4+5 ) * 2 = 36。</p>
<p>若按各个字符出现的概率不同而给予不等长编码，可望减少总编码长度。</p>
<p>各字符出现概率为{ 2/18, 7/18, 4/18, 5/18 },化整为 { 2, 7, 4, 5 }。以它们为各叶结点上的权值, 建立Huffman树。左分支赋 0，右分支赋 1，得Huffman编码(变长编码)。</p>
<p>A : 0    T : 10     C : 110    S : 111</p>
<p>它的总编码长度：7<em>1+5</em>2+( 2+4 )*3 = 35。比等长编码的情形要短。<br>总编码长度正好等于Huffman树的带权路径长度WPL。<br>Huffman编码是一种前缀编码，即任一个二进制编码不是其他二进制编码的前缀。解码时不会混淆。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><strong>堆的定义</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200616163839640-1199111818.png" alt=""></p>
<p>完全二叉树的数组表示<br>Ki &lt;=K(2i+1) &amp;&amp; Ki &gt;= K(2i+2)</p>
<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200616163930670-126115786.png" alt=""></p>
<p>完全二叉树的数组表示<br>Ki &gt;= K(2i+1)  &amp;&amp; Ki &gt;= K(2i+2)</p>
<p><strong>以最小堆为例</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最小堆的类定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; <span class="title">class</span> <span class="title">MinHeap</span> :</span></span><br><span class="line">     <span class="keyword">public</span>  MinPQ &lt;Type&gt; &#123;		</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">     MinHeap ( <span class="keyword">int</span> maxSize );</span><br><span class="line">     MinHeap ( Type arr[ ], <span class="keyword">int</span> n );</span><br><span class="line">     ~MinHeap ( ) &#123; <span class="keyword">delete</span> [ ] heap; &#125;</span><br><span class="line">     <span class="keyword">const</span> MinHeap&lt;Type&gt; &amp; <span class="keyword">operator</span> = </span><br><span class="line">          ( <span class="keyword">const</span> MinHeap &amp;R );	</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">Insert</span> <span class="params">( <span class="keyword">const</span> Type &amp;x )</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">RemoveMin</span> <span class="params">( Type &amp;x )</span></span>;   </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span> <span class="params">( )</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">            </span>&#123; <span class="keyword">return</span> CurrentSize == <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">IsFull</span> <span class="params">( )</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">            </span>&#123; <span class="keyword">return</span> CurrentSize == MaxHeapSize; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span> <span class="params">( )</span> </span>&#123; CurrentSize = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">enum</span> &#123; DefaultSize = <span class="number">10</span> &#125;;</span><br><span class="line">    Type *heap;                 			</span><br><span class="line">    <span class="keyword">int</span> CurrentSize;				</span><br><span class="line">    <span class="keyword">int</span> MaxHeapSize;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FilterDown</span> <span class="params">( <span class="keyword">int</span> i, <span class="keyword">int</span> m )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FilterUp</span> <span class="params">( <span class="keyword">int</span> i )</span></span>;</span><br><span class="line">&#125;<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; <span class="title">MinHeap</span> &lt;Type&gt; :</span>:</span><br><span class="line">MinHeap ( <span class="keyword">int</span> maxSize ) &#123;<span class="comment">//根据给定大小maxSize,建立堆对象</span></span><br><span class="line">    MaxHeapSize = DefaultSize &lt; maxSize ? </span><br><span class="line">            maxSize : DefaultSize;	       <span class="comment">//确定堆大小</span></span><br><span class="line">    heap = <span class="keyword">new</span> Type [MaxHeapSize]; <span class="comment">//创建堆空间</span></span><br><span class="line">    CurrentSize = <span class="number">0</span>;                              <span class="comment">//初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆的建立</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; <span class="title">MinHeap</span> &lt;Type&gt; :</span>: </span><br><span class="line">MinHeap ( Type arr[ ], <span class="keyword">int</span> n ) &#123;<span class="comment">//根据给定数组中的数据和大小,建立堆对象    </span></span><br><span class="line">MaxHeapSize = DefaultSize &lt; n ? n : DefaultSize;</span><br><span class="line">    heap = <span class="keyword">new</span> Type [MaxHeapSize]; </span><br><span class="line">    heap = arr;               <span class="comment">//数组传送</span></span><br><span class="line">    CurrentSize = n;       <span class="comment">//当前堆大小</span></span><br><span class="line">    <span class="keyword">int</span> currentPos = (CurrentSize<span class="number">-2</span>)/<span class="number">2</span>;   <span class="comment">//最后非叶</span></span><br><span class="line">    <span class="keyword">while</span> ( currentPos &gt;= <span class="number">0</span> ) &#123;       <span class="comment">//从下到上逐步扩大,形成堆</span></span><br><span class="line">        FilterDown ( currentPos, CurrentSize<span class="number">-1</span> );</span><br><span class="line">        <span class="comment">//从currentPos开始,到CurrentSize为止, 调整</span></span><br><span class="line">        currentPos--;				</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最小堆的向下调整算法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; <span class="title">void</span> <span class="title">MinHeap</span>&lt;Type&gt; :</span>: </span><br><span class="line">FilterDown ( <span class="keyword">int</span> start, <span class="keyword">int</span> EndOfHeap ) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = start,   j = <span class="number">2</span>*i+<span class="number">1</span>;        <span class="comment">// j 是 i 的左子女</span></span><br><span class="line">    Type temp = heap[i];</span><br><span class="line">    <span class="keyword">while</span> ( j &lt;= EndOfHeap ) &#123;</span><br><span class="line">         <span class="keyword">if</span> ( j &lt; EndOfHeap &amp;&amp; heap[j].key &gt;</span><br><span class="line">            heap[j+<span class="number">1</span>].key )  j++;    <span class="comment">//两子女中选小者</span></span><br><span class="line">         <span class="keyword">if</span> ( temp.key &lt;= heap[j].key ) <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">else</span> &#123; heap[i] = heap[j];  i = j;   j = <span class="number">2</span>*j+<span class="number">1</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[i] = temp;				</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//堆的插入</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; <span class="title">int</span> <span class="title">MinHeap</span>&lt;Type&gt; :</span>:</span><br><span class="line">Insert ( <span class="keyword">const</span> Type &amp;x ) &#123;</span><br><span class="line"><span class="comment">//在堆中插入新元素 x</span></span><br><span class="line">    <span class="keyword">if</span> ( CurrentSize == MaxHeapSize )     <span class="comment">//堆满</span></span><br><span class="line">       &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"堆已满"</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="keyword">return</span> <span class="number">0</span>; &#125;	</span><br><span class="line">    heap[CurrentSize] = x;           <span class="comment">//插在表尾  </span></span><br><span class="line">    FilterUp (CurrentSize);          <span class="comment">//向上调整为堆</span></span><br><span class="line">    CurrentSize++;                       <span class="comment">//堆元素增一</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最小堆的向上调整算法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; <span class="title">void</span> <span class="title">MinHeap</span>&lt;Type&gt; :</span>:</span><br><span class="line">FilterUp ( <span class="keyword">int</span> start ) &#123;</span><br><span class="line"><span class="comment">//从 start 开始,向上直到0,调整堆</span></span><br><span class="line">    <span class="keyword">int</span> j = start,  i = (j<span class="number">-1</span>)/<span class="number">2</span>;    <span class="comment">// i 是 j 的双亲</span></span><br><span class="line">    Type temp = heap[j];</span><br><span class="line">    <span class="keyword">while</span> ( j &gt; <span class="number">0</span> ) &#123;      </span><br><span class="line">        <span class="keyword">if</span> ( heap[i].key &lt;= temp.key ) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;  heap[j] = heap[i];  j = i;  i = (i <span class="number">-1</span>)/<span class="number">2</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最小堆的删除算法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; <span class="title">int</span> <span class="title">MinHeap</span> &lt;Type&gt; :</span>:</span><br><span class="line">RemoveMin ( Type &amp;x ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !CurrentSize )</span><br><span class="line">      &#123; <span class="built_in">cout</span> &lt;&lt; “ 堆已空 <span class="string">" &lt;&lt; endl;  return 0; &#125;</span></span><br><span class="line"><span class="string">    x = heap[0];             //最小元素出队列</span></span><br><span class="line"><span class="string">    heap[0] = heap[CurrentSize-1];	    </span></span><br><span class="line"><span class="string">    CurrentSize--;        //用最小元素填补</span></span><br><span class="line"><span class="string">    FilterDown ( 0, CurrentSize-1 );</span></span><br><span class="line"><span class="string">    //从0号位置开始自顶向下调整为堆</span></span><br><span class="line"><span class="string">    return 1;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="补充：函数指针"><a href="#补充：函数指针" class="headerlink" title="补充：函数指针"></a>补充：函数指针</h2><p>函数是一段程序，运行时与变量一样占用内存，也就有 一个起始地址，即指向此函数的指针。 </p>
<p>函数指针定义格式:  类型名 （*函数名）（形参表）[=函数名]; </p>
<p>如：若有函数：int fun(int,char);         </p>
<p>则：int (*p)(int, char);    p=fun;         </p>
<p>或     int (* p)(int,char)=fun;  //p为指向函数fun的指针 </p>
<p>注：函数名为指针常量，不可改变；函数指针一般用作 函数参数，用来简化有规律的函数调用。 例：使用函数名作函数参数 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a-b;&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">plus</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span>  </span>&#123;<span class="keyword">return</span> a+b;&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span>  </span>&#123;<span class="keyword">return</span> a*b;&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span>  </span>&#123;<span class="keyword">return</span> a/b;&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">op</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> (*p)(<span class="keyword">int</span>,<span class="keyword">int</span>) )</span> </span>&#123;    <span class="keyword">return</span> p(a,b);    &#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( )</span> </span>&#123;    </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"5+3="</span>&lt;&lt;op(<span class="number">5</span>,<span class="number">3</span>,plus)&lt;&lt;<span class="built_in">endl</span>;      </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"5-3="</span>&lt;&lt;op(<span class="number">5</span>,<span class="number">3</span>,minus)&lt;&lt;<span class="built_in">endl</span>;      </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"5*3="</span>&lt;&lt;op(<span class="number">5</span>,<span class="number">3</span>,multiply)&lt;&lt;<span class="built_in">endl</span>;      </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"5/3="</span>&lt;&lt;op(<span class="number">5</span>,<span class="number">3</span>,&amp;divide)&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>课内学习</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构笔记（第二章）</title>
    <url>/2021/05/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h2 id="第二章：线性结构之线性表"><a href="#第二章：线性结构之线性表" class="headerlink" title="第二章：线性结构之线性表"></a><strong>第二章：线性结构之线性表</strong></h2><p>数据的逻辑结构 ：</p>
<ul>
<li><p>集合</p>
</li>
<li><p>线性结构—&gt;线性表、栈、队列、优先队列</p>
</li>
<li><p>树结构</p>
</li>
<li><p>图结构</p>
</li>
</ul>
<p>线性表的存储结构 ：</p>
<ul>
<li><p>线性表的基于数组的存储表示叫做顺序表（SeqList），线性表的基于指针的存储表示叫做链表（LinkedList）（单链表、双链表、循环链表等）</p>
</li>
<li><p>数据的操作：插入、删除、修改、检索、排序等</p>
</li>
<li><p>注意其算法时间复杂度 </p>
</li>
</ul>
<h3 id="顺序表（SeqList）"><a href="#顺序表（SeqList）" class="headerlink" title="顺序表（SeqList）"></a><strong>顺序表（SeqList）</strong></h3><p>存储要点：</p>
<ul>
<li><p>用一段地址连续的存储单元</p>
</li>
<li><p>依次存储线性表中的数据元素</p>
</li>
</ul>
<p>用什么属性来描述顺序表：</p>
<ul>
<li><p>存储空间的起始位置</p>
</li>
<li><p>顺序表的容量（最大长度）</p>
</li>
<li><p>顺序表的当前长度</p>
</li>
</ul>
<p>顺序表的优点：</p>
<p>⑴ 无需为元素之间的逻辑关系而增加额外存储空间；</p>
<p>⑵ 随机存取：可以快速地存取表中任一位置的元素。</p>
<p>顺序表的缺点：</p>
<p>⑴ 插入和删除操作需要移动大量元素；</p>
<p>⑵ 表的容量难以确定，表的容量难以扩充；</p>
<p>⑶ 造成存储空间的碎片。</p>
<h5 id="顺序表的静态存储和动态存储"><a href="#顺序表的静态存储和动态存储" class="headerlink" title="顺序表的静态存储和动态存储"></a>顺序表的静态存储和动态存储</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    T data[maxSize];     <span class="comment">//顺序表的静态存储表示</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125; SeqList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    T *data;                  <span class="comment">//顺序表的动态存储表示</span></span><br><span class="line">    <span class="keyword">int</span> maxSize, n;</span><br><span class="line">&#125; SeqList;</span><br></pre></td></tr></table></figure>

<h5 id="顺序表-SeqList-类的定义"><a href="#顺序表-SeqList-类的定义" class="headerlink" title="顺序表(SeqList)类的定义"></a>顺序表(SeqList)类的定义</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> defaultsize=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;	</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SeqList</span>:</span> <span class="keyword">public</span> LinearList&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">      T *data;       <span class="comment">//顺序表存储数组</span></span><br><span class="line">	   <span class="keyword">int</span> MaxSize;	 <span class="comment">//最大允许长度	</span></span><br><span class="line">	   <span class="keyword">int</span> last; 	         <span class="comment">//当前最后元素下标</span></span><br><span class="line">	   <span class="function"><span class="keyword">void</span> <span class="title">reSize</span><span class="params">(<span class="keyword">int</span> newSize)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	   SeqList ( <span class="keyword">int</span> sz= defaultSize );</span><br><span class="line">	   SeqList(SeqList&lt;T&gt;&amp; L);</span><br><span class="line">	   ~SeqList ( ) &#123; <span class="keyword">delete</span> [ ] data; &#125;	</span><br><span class="line">	   <span class="function"><span class="keyword">int</span> <span class="title">Size</span><span class="params">()</span><span class="keyword">const</span></span>&#123;<span class="keyword">return</span> maxSize;&#125;	</span><br><span class="line">	   <span class="function"><span class="keyword">int</span> <span class="title">Length</span> <span class="params">( )</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> last+<span class="number">1</span>; &#125;</span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">Search</span> <span class="params">( T&amp; x )</span> <span class="keyword">const</span></span>;         <span class="comment">//查找</span></span><br><span class="line">	   <span class="function"><span class="keyword">int</span> <span class="title">Locate</span> <span class="params">( <span class="keyword">int</span> i )</span> <span class="keyword">const</span></span>;	        <span class="comment">//定位</span></span><br><span class="line">	   <span class="function"><span class="keyword">bool</span> <span class="title">getData</span><span class="params">(<span class="keyword">int</span> i,T&amp; x)</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">	   </span>&#123;<span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;i&lt;=last+<span class="number">1</span>) &#123;x=data[i<span class="number">-1</span>];<span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">	   <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line">	   <span class="function"><span class="keyword">void</span> <span class="title">setData</span> <span class="params">(<span class="keyword">int</span> i, T&amp;  x)</span></span></span><br><span class="line"><span class="function">	   </span>&#123;<span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; i&lt;=last+<span class="number">1</span>) &#123;  data[i<span class="number">-1</span>]=x;  &#125; </span><br><span class="line">	   <span class="function"><span class="keyword">int</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> i, T &amp; x)</span></span>;       <span class="comment">//插入</span></span><br><span class="line">	   <span class="function"><span class="keyword">int</span> <span class="title">Remove</span> <span class="params">(<span class="keyword">int</span> i, T &amp; x )</span></span>;	       <span class="comment">//删除	</span></span><br><span class="line">	   <span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span> <span class="params">( )</span> </span>&#123; <span class="keyword">return</span> (last ==<span class="number">-1</span>)?<span class="literal">true</span>:<span class="literal">false</span>; &#125;	</span><br><span class="line">	   <span class="function"><span class="keyword">bool</span> <span class="title">IsFull</span> <span class="params">( )</span> </span>&#123; <span class="keyword">return</span> last == MaxSize<span class="number">-1</span>?<span class="literal">true</span>:<span class="literal">false</span>; &#125;</span><br><span class="line">	   <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span>;</span><br><span class="line">	   <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>;</span><br><span class="line">	   SeqList&lt;T&gt; <span class="keyword">operator</span>=(SeqList&lt;T&gt;&amp; L);</span><br><span class="line">           &#125;;</span><br></pre></td></tr></table></figure>

<h5 id="顺序表部分公共操作的实现"><a href="#顺序表部分公共操作的实现" class="headerlink" title="顺序表部分公共操作的实现"></a>顺序表部分公共操作的实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;	          //构造函数</span></span><br><span class="line"><span class="class"> <span class="title">SeqList</span>&lt;T&gt; :</span>: SeqList ( <span class="keyword">int</span> sz ) &#123;    </span><br><span class="line">     <span class="keyword">if</span> ( sz &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">	      MaxSize = sz; </span><br><span class="line">         last = <span class="number">-1</span>;			</span><br><span class="line">	      data = <span class="keyword">new</span> T [MaxSize];</span><br><span class="line">          <span class="keyword">if</span> ( data == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">              <span class="built_in">cerr</span>&lt;&lt;<span class="string">"存储分配失败！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">             <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">          &#125;		</span><br><span class="line">	  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;	     //复制构造函数</span></span><br><span class="line"><span class="class"> <span class="title">SeqList</span>&lt;T&gt; :</span>: SeqList( SeqList&lt;T&gt;&amp; L )&#123;    </span><br><span class="line">maxSize=L.Size();</span><br><span class="line">last=L.Length()<span class="number">-1</span>;</span><br><span class="line">T value;</span><br><span class="line">data=<span class="keyword">new</span> T[maxSize];</span><br><span class="line"><span class="keyword">if</span> ( data == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">              <span class="built_in">cerr</span>&lt;&lt;<span class="string">"存储分配失败！"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=last+<span class="number">1</span>;i++)</span><br><span class="line">&#123; L.getData(i,value);data[i<span class="number">-1</span>]=value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;	     //重定义大小</span></span><br><span class="line"><span class="class"><span class="title">void</span>  <span class="title">SeqList</span>&lt;T&gt; :</span>: reSize(<span class="keyword">int</span> newSize)&#123;    </span><br><span class="line"><span class="keyword">if</span>(newSize&lt;=<span class="number">0</span>)&#123;<span class="built_in">cerr</span>&lt;&lt;<span class="string">"无效的数组大小"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(newSize!=maxSize)&#123;</span><br><span class="line">	T *newarray=<span class="keyword">new</span> T[newSize];</span><br><span class="line">	<span class="keyword">if</span> ( newarray == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">              <span class="built_in">cerr</span>&lt;&lt;<span class="string">"存储分配失败！"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="built_in">exit</span>(<span class="number">1</span>);          &#125;</span><br><span class="line">	<span class="keyword">int</span> n=last+<span class="number">1</span>;</span><br><span class="line">	T *srcptr=data;</span><br><span class="line">	T *destptr=newarray;</span><br><span class="line">	<span class="keyword">while</span>(n- -)*destptr++=*srcptr++;</span><br><span class="line">	<span class="keyword">delete</span> []data;</span><br><span class="line">	data=newarray; maxSize=newSize;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;	</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">SeqList</span>&lt;T&gt; :</span>: search ( T &amp; x ) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="comment">//搜索函数：在顺序表中从头查找结点值等于</span></span><br><span class="line"><span class="comment">//给定值x的结点所在位置，如果没找到返回0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>  i = <span class="number">0</span>; i &lt;= last ; i++)</span><br><span class="line">	<span class="keyword">if</span> (data[i]==x) <span class="keyword">return</span> i+<span class="number">1</span> ;		</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;					</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; //顺序表的表项的插入<span class="title">insert</span>算法</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">SeqList</span>&lt;T&gt; :</span>: Insert (T&amp; x, <span class="keyword">int</span> i ) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (last+<span class="number">1</span> &gt;= MaxSize|| (i &lt; <span class="number">0</span> || i &gt; last + <span class="number">1</span>) ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = last; j &gt;= i; j- -)  data[j+<span class="number">1</span>] = data[j]; </span><br><span class="line"></span><br><span class="line"> data[i] = x;</span><br><span class="line"> last++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; //<span class="title">Remove</span>:</span>从顺序表中删除第i项，其值赋给x</span><br><span class="line"></span><br><span class="line"> <span class="keyword">bool</span> SeqList&lt;T&gt; :: Remove ( <span class="keyword">int</span> i, T&amp; x ) &#123;</span><br><span class="line"> <span class="comment">//在表中删除已有元素 x	</span></span><br><span class="line">	<span class="keyword">if</span>(last==<span class="number">-1</span> ||i&lt;<span class="number">1</span> || i&gt;last+<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;	x=data[i<span class="number">-1</span>]; </span><br><span class="line">	<span class="keyword">for</span> ( <span class="keyword">int</span> j = i; j &lt;= last; j++ )  </span><br><span class="line">                data[j<span class="number">-1</span>] = data[j];</span><br><span class="line">	last- - ;	</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;	               <span class="comment">//成功删除	</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; //顺序表的输入算法</span></span><br><span class="line"><span class="class"> <span class="title">void</span> <span class="title">SeqList</span>&lt;T&gt; :</span>:input() &#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;“请输入元素个数减一<span class="string">";</span></span><br><span class="line"><span class="string">	while(1)&#123;</span></span><br><span class="line"><span class="string">		cin&gt;&gt;last;</span></span><br><span class="line"><span class="string">		if(last&lt;=maxSize-1)break;</span></span><br><span class="line"><span class="string">		cout&lt;&lt;"</span>个数输入有误<span class="string">";</span></span><br><span class="line"><span class="string">                     &#125;</span></span><br><span class="line"><span class="string">          cout&lt;&lt;“0:”&lt;&lt;endl;</span></span><br><span class="line"><span class="string">	for(int i=0;i&lt;=last; i++)</span></span><br><span class="line"><span class="string">		&#123;cin&gt;&gt;data[i]; cout&lt;&lt;i+1&lt;&lt;endl;&#125;           	</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">template &lt;class T&gt; //顺序表的输出算法</span></span><br><span class="line"><span class="string"> void SeqList&lt;T&gt; ::output() &#123;</span></span><br><span class="line"><span class="string">	cout&lt;&lt;"</span>当前元素最后位置为<span class="string">"&lt;&lt;last+1&lt;&lt;endl;</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	for(int i=0;i&lt;=last;i++)</span></span><br><span class="line"><span class="string">		&#123;cout&lt;&lt;"</span>#<span class="string">"&lt;&lt;i+1&lt;&lt;"</span>:<span class="string">"&lt;&lt;data[i]&lt;&lt;endl;&#125;               	</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="顺序表的应用：集合的“并”运算"><a href="#顺序表的应用：集合的“并”运算" class="headerlink" title="顺序表的应用：集合的“并”运算"></a>顺序表的应用：集合的“并”运算</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span> <span class="params">( SeqList&lt;<span class="keyword">int</span>&gt; &amp; A, SeqList&lt;<span class="keyword">int</span>&gt; &amp; B)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> n = A.Length ( ), x;</span><br><span class="line">     <span class="keyword">int</span> m = B.Length ( );</span><br><span class="line">     <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; =m; i++ ) &#123;</span><br><span class="line">	 B.getData(i,x);         <span class="comment">//在B中取一元素</span></span><br><span class="line">	 <span class="keyword">int</span> k = A.Search (x);     <span class="comment">//在A中搜索它</span></span><br><span class="line">	 <span class="keyword">if</span> ( k == <span class="number">0</span> )              <span class="comment">//若未找到插入它</span></span><br><span class="line">             &#123; A.Insert (n, x);  n++; &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">SeqList&lt;<span class="keyword">int</span>&gt; s1,s2;</span><br><span class="line">s1.input();</span><br><span class="line">s2.input();</span><br><span class="line">Union(s1,s2);</span><br><span class="line">s1.output();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="顺序表的应用：集合的“交”运算"><a href="#顺序表的应用：集合的“交”运算" class="headerlink" title="顺序表的应用：集合的“交”运算"></a>顺序表的应用：集合的“交”运算</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Intersection</span> <span class="params">( SeqList&lt;<span class="keyword">int</span>&gt; &amp; A,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 SeqList&lt;<span class="keyword">int</span>&gt; &amp; B )</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> n = A.Length ( );</span><br><span class="line">     <span class="keyword">int</span> m = B.Length ( );  <span class="keyword">int</span> i = <span class="number">1</span>, x;</span><br><span class="line">     <span class="keyword">while</span> ( i &lt; =n ) &#123;</span><br><span class="line">	A.<span class="function"><span class="built_in">get</span> <span class="title">Data</span><span class="params">(i, x)</span></span>;      <span class="comment">//在A中取一元素</span></span><br><span class="line"> 	<span class="keyword">int</span> k = B.search (x);    <span class="comment">//在B中搜索它	</span></span><br><span class="line">	<span class="keyword">if</span> ( k == <span class="number">0</span> ) &#123; A.Remove (i,x);  n- - ; &#125;</span><br><span class="line">	                               <span class="comment">//未找到在A中删除它</span></span><br><span class="line">        <span class="keyword">else</span> i++;</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h5 id="测试后的一份完整代码"><a href="#测试后的一份完整代码" class="headerlink" title="测试后的一份完整代码"></a>测试后的一份完整代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DefaultSize 100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; <span class="title">class</span> <span class="title">SeqList</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SeqList( <span class="keyword">int</span> <span class="built_in">size</span> = DefaultSize )&#123;</span><br><span class="line">	assert ( <span class="built_in">size</span> &gt;= <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">size</span> &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">       MaxSize = <span class="built_in">size</span>;  last = <span class="number">-1</span>;</span><br><span class="line">       data = <span class="keyword">new</span> Type[MaxSize];</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    ~SeqList() &#123; <span class="keyword">delete</span>[] data; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> last + <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">( Type &amp; x )</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">IsIn</span> <span class="params">( Type &amp; x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Insert</span> <span class="params">( Type &amp; x, <span class="keyword">int</span> i )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Remove</span> <span class="params">( Type &amp; x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Next</span> <span class="params">( Type &amp; x )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Prior</span> <span class="params">( Type &amp; x )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> last == <span class="number">-1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">IsFull</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> last == MaxSize - <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function">Type <span class="title">Get</span><span class="params">( <span class="keyword">int</span> i )</span> </span>&#123; <span class="keyword">return</span> i &lt; <span class="number">0</span> || i &gt; last ? <span class="literal">NULL</span>:data[i]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type *data;</span><br><span class="line">    <span class="keyword">int</span> MaxSize;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*template &lt; class Type &gt;</span></span><br><span class="line"><span class="comment"> SeqList &lt;Type&gt;::SeqList( int size = DefaultSize ) &#123;</span></span><br><span class="line"><span class="comment">    assert ( size &gt;= 0 );</span></span><br><span class="line"><span class="comment">    if ( size &gt; 0 ) &#123;</span></span><br><span class="line"><span class="comment">       MaxSize = size;  last = -1;</span></span><br><span class="line"><span class="comment">       data = new Type[MaxSize];</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Type</span> &gt; <span class="title">int</span> <span class="title">SeqList</span> &lt;Type&gt;:</span>:Find( Type &amp; x ) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( i &lt;= last &amp;&amp; data[i] != x ) i++;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt; last ) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Type</span> &gt; <span class="title">int</span> <span class="title">SeqList</span> &lt;Type&gt;:</span>:IsIn( Type &amp; x ) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, found = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( i &lt;= last &amp;&amp; !found)</span><br><span class="line">	<span class="keyword">if</span> ( data[i] != x ) i++;</span><br><span class="line">	<span class="keyword">else</span> found = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Type</span> &gt; <span class="title">int</span> <span class="title">SeqList</span> &lt;Type&gt;:</span>:Insert( Type &amp; x, <span class="keyword">int</span> i ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( i &lt; <span class="number">0</span> || i &gt; last+<span class="number">1</span> || last == MaxSize - <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">	last++;</span><br><span class="line">	<span class="keyword">for</span> ( <span class="keyword">int</span> j = last; j &gt; i; j-- ) data[j] = data[j<span class="number">-1</span>];</span><br><span class="line">	data[i] = x;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Type</span> &gt; <span class="title">int</span> <span class="title">SeqList</span> &lt;Type&gt;:</span>:Remove( Type &amp; x ) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = Find(x);</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= <span class="number">0</span> ) &#123;</span><br><span class="line">	last--;</span><br><span class="line">	<span class="keyword">for</span> ( <span class="keyword">int</span> j = i; j &lt;= last; j++ ) data[j] = data[j+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Type</span> &gt; <span class="title">int</span> <span class="title">SeqList</span> &lt;Type&gt;:</span>:Next( Type &amp; x ) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = Find(x);</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= <span class="number">0</span> &amp;&amp; i &lt; last ) <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Type</span> &gt; <span class="title">int</span> <span class="title">SeqList</span> &lt;Type&gt;:</span>:Prior( Type &amp; x ) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = Find(x);</span><br><span class="line">    <span class="keyword">if</span> ( i &gt; <span class="number">0</span> &amp;&amp; i &lt;= last ) <span class="keyword">return</span> i<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Type</span> &gt; <span class="title">void</span> <span class="title">Union</span>( <span class="title">SeqList</span> &lt;Type&gt; &amp; <span class="title">LA</span>, <span class="title">SeqList</span> &lt;Type&gt; &amp; <span class="title">LB</span> ) &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n = LA.Length(); <span class="keyword">int</span> m = LB.Length();</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i &lt;= m; i++ ) &#123;</span><br><span class="line">	Type x = LB.Get(i);</span><br><span class="line">	<span class="keyword">int</span> k = LA.Find(x);</span><br><span class="line">	<span class="keyword">if</span> ( k == <span class="number">-1</span> ) &#123; LA.Insert( x, n );  n++;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Type</span> &gt; <span class="title">void</span> <span class="title">Intersection</span> ( <span class="title">SeqList</span> &lt;Type&gt; &amp; <span class="title">LA</span>, <span class="title">SeqList</span> &lt;Type&gt; &amp; <span class="title">LB</span> ) &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n = LA.Length();  <span class="keyword">int</span> m = LB.Length();  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( i &lt; n ) &#123;</span><br><span class="line">	Type x = LA.Get(i);</span><br><span class="line">	<span class="keyword">int</span> k = LB.Find(x);</span><br><span class="line">	<span class="keyword">if</span> ( k == <span class="number">-1</span> ) &#123; LA.Remove(x); n--; &#125;</span><br><span class="line">	<span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Type</span> &gt; <span class="title">void</span> <span class="title">SeqList</span> &lt;Type&gt;:</span>:Print() &#123;</span><br><span class="line">    <span class="keyword">if</span> ( last == <span class="number">-1</span> ) <span class="built_in">cout</span>&lt;&lt;<span class="string">"It is empty"</span> ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=last; <span class="built_in">cout</span> &lt;&lt; <span class="string">"  data["</span> &lt;&lt; i++ &lt;&lt; <span class="string">"] = "</span> &lt;&lt; data[i] );</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> length;</span><br><span class="line">SeqList&lt;<span class="keyword">int</span>&gt;* sq=<span class="keyword">new</span> SeqList&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入元素个数"</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;length;</span><br><span class="line"><span class="keyword">int</span> result;</span><br><span class="line"><span class="comment">//cout&lt;&lt;length;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=length;i++)&#123;</span><br><span class="line">  result=sq-&gt;Insert(i,i<span class="number">-1</span>);</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;result&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">sq-&gt;Print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表（Linked-List）"><a href="#链表（Linked-List）" class="headerlink" title="链表（Linked List）"></a><strong>链表（Linked List）</strong></h3><h4 id="单链表-Singly-Linked-List"><a href="#单链表-Singly-Linked-List" class="headerlink" title="单链表 (Singly Linked List)"></a>单链表 (Singly Linked List)</h4><p>单链表是最简单的链表，也叫线性链表，它用指针表示结点间的逻辑关系。特点：</p>
<ul>
<li>每个元素(表项)由结点(Node)构成。数据域和指针域。</li>
</ul>
<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200616104433123-1891202710.png" alt=""></p>
<ul>
<li>线性结构（first为头指针）</li>
</ul>
<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200616104631953-336018282.png" alt=""></p>
<ul>
<li><p>结点可以连续，可以不连续存储</p>
</li>
<li><p>结点数据元素顺序与物理顺序可能不一致。元素之间的逻辑关系用指针表示</p>
</li>
<li><p>表扩充很方便</p>
</li>
</ul>
<h5 id="单链表的类定义"><a href="#单链表的类定义" class="headerlink" title="单链表的类定义"></a>单链表的类定义</h5><p>多个类表达一个概念(单链表)：</p>
<ul>
<li>链表结点(ListNode)类型</li>
</ul>
<ul>
<li>链表(List)类型</li>
</ul>
<p>定义两种类型关系的方式：</p>
<ul>
<li>嵌套方式</li>
</ul>
<ul>
<li>继承方式</li>
</ul>
<ul>
<li>复合方式**</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、嵌套类（不合适）</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> &#123;</span>           <span class="comment">//链表类定义(嵌套方式)</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">………               <span class="comment">//链表操作</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LinkNode</span> &#123;</span>     <span class="comment">//嵌套链表结点类</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> data;      <span class="comment">//可被两个类的成员访问</span></span><br><span class="line">        LinkNode *link;		</span><br><span class="line">    &#125;;</span><br><span class="line">    LinkNode *first ;    <span class="comment">//表头指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、继承方式（不合适）</span><br><span class="line">链表类和链表结点类定义(继承方式)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkNode</span> &#123;</span>	   <span class="comment">//链表结点类	</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> data;		       </span><br><span class="line">    LinkNode * link;          	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> :</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkNode</span> &#123;</span>	                   <span class="comment">//链表类, 继承链表结点类的数据和操作	</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     LinkNode *first;       <span class="comment">//表头指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、复合类 </span><br><span class="line">（友元类不具有对称性）</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span>;</span>	     <span class="comment">//链表类定义（复合方式）</span></span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">LinkNode</span> &#123;</span>	        <span class="comment">//链表结点类	</span></span><br><span class="line"> <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span>;</span>	       <span class="comment">//链表类为其友元类</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     <span class="keyword">int</span> data;		   <span class="comment">//结点数据, 整型	</span></span><br><span class="line">     LinkNode * link;        <span class="comment">//结点指针		</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">List</span> &#123;</span>	                   <span class="comment">//链表类		</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     LinkNode *first;       <span class="comment">//表头指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">复合类<span class="number">2</span>: 用<span class="class"><span class="keyword">struct</span>定义<span class="title">linkNode</span>类（最佳）</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">LinkNode</span> &#123;</span>	   <span class="comment">//链表结点类	</span></span><br><span class="line">    <span class="keyword">int</span>  data;		       </span><br><span class="line">    LinkNode * link;          	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> &#123;</span>	                   <span class="comment">//链表类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">     LinkNode *first;       <span class="comment">//表头指针</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">……</span><br><span class="line">&#125;;<span class="comment">//虽然结构使得LinkNode失去了封装性，但是所有属于List对象的LinkNode结点只能用first 进行访问</span></span><br></pre></td></tr></table></figure>

<h5 id="单链表中的插入与删除（part-1）"><a href="#单链表中的插入与删除（part-1）" class="headerlink" title="单链表中的插入与删除（part 1）"></a>单链表中的插入与删除（part 1）</h5><p>插入：单链表（a1,a2,a3……an）希望在ai之后插入新元素x</p>
<p>第一种情况：在第一个结点前插入</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">LinkNode* newnode=<span class="keyword">new</span> LinkNode(x);   </span><br><span class="line">newnode-&gt;link = first ;    </span><br><span class="line">first = newnode;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200616104723343-454143529.png" alt=""></p>
<p>第二种情况：在链表中间插入(p指向ai)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">newnode-&gt;link = p-&gt;link;	</span><br><span class="line">p-&gt;link = newnode</span><br></pre></td></tr></table></figure>

<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200616104804992-219153062.png" alt=""></p>
<p>第三种情况：在链表末尾插入（ p指向ai ）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">newnode-&gt;link = p-&gt;link;	</span><br><span class="line">p-&gt;link = newnode；</span><br></pre></td></tr></table></figure>

<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200616104844203-81481135.png" alt=""></p>
<p>从上面的分析看出，后两种情况（即在表中间插入和在表尾插入)的操作是一样的，可以合并处理，但首节点前插入操作不同。（因为首节点没有前驱）</p>
<ul>
<li>删除:在单链表中删除ai结点</li>
</ul>
<p>第一种情况: 删除表中第一个元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">del=first;first=first-&gt;link;<span class="comment">//del指向被删结点</span></span><br><span class="line"><span class="keyword">delete</span> del;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200616104913723-696347379.png" alt=""></p>
<p>第二种情况: 删除表中或表尾元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">del=p-&gt;link;</span><br><span class="line">p-&gt;link=del-&gt;link;</span><br><span class="line">（或p-&gt;link=p-&gt;link-&gt;plink）</span><br><span class="line"><span class="keyword">delete</span> del;</span><br><span class="line"><span class="comment">//  用P指向被删结点前一个结点，del指向被删结点</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200616104923604-1948319084.png" alt=""></p>
<h5 id="单链表中的插入与删除（part-2）"><a href="#单链表中的插入与删除（part-2）" class="headerlink" title="单链表中的插入与删除（part 2）"></a>单链表中的插入与删除（part 2）</h5><p>在带附加头结点的单链表第一个结点前插入新结点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">newnode-&gt;link = p-&gt;link; </span><br><span class="line">p-&gt;link = newnode;</span><br><span class="line"><span class="comment">//  在空表或非空表的第1个结点前插入可以统一操作</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200616104930936-478014406.png" alt=""></p>
<p>在带附加头结点的单链表中删除第一个结点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">del = p-&gt;link;</span><br><span class="line">p-&gt;link = del-&gt;link;</span><br><span class="line"><span class="keyword">delete</span> del; </span><br><span class="line"><span class="comment">// 用P指向被删结点前一个结点，del指向被删结点</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200616105007622-1405334918.png" alt=""></p>
<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200616105014338-611324035.png" alt=""></p>
<h5 id="带附加头结点的单链表类"><a href="#带附加头结点的单链表类" class="headerlink" title="带附加头结点的单链表类"></a>带附加头结点的单链表类</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;  //结点结构定义</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">LinkNode</span> &#123;</span>	</span><br><span class="line">T data;                         <span class="comment">//结点数据 </span></span><br><span class="line">LinkNode&lt;T&gt; *link;    <span class="comment">//结点链接指针</span></span><br><span class="line"></span><br><span class="line">LinkNode(LinkNode&lt;T&gt; *ptr=<span class="literal">NULL</span> )      	 	&#123;link=ptr; &#125;  <span class="comment">//	仅初始化指针成员的构造函数</span></span><br><span class="line"> </span><br><span class="line">LinkNode (<span class="keyword">const</span> T&amp; item, LinkNode&lt;T&gt; *ptr=<span class="literal">NULL</span> ) &#123;data=item;link=ptr;</span><br><span class="line">      &#125; </span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;  //链表类</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">List</span> ：<span class="title">public</span> <span class="title">LinearList</span>&lt;T&gt;&#123;</span>    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    LinkNode&lt;T&gt; *first; <span class="comment">//链表的头指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">List () &#123; first = <span class="keyword">new</span> LinkNode&lt;T&gt;; &#125;</span><br><span class="line">List (<span class="keyword">const</span> T&amp; x) &#123;  first = <span class="keyword">new</span> LinkNode&lt;T&gt; (x ); &#125;</span><br><span class="line">List (List&lt;T&gt;&amp; L);</span><br><span class="line">~List () &#123; makeEmpty(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span> <span class="params">( )</span></span>;	<span class="comment">//将链表置为空表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">( )</span><span class="keyword">const</span></span>;	<span class="comment">//计算链表的长度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LinkNode&lt;T&gt; *<span class="title">getHead</span><span class="params">()</span><span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> first; &#125;</span><br><span class="line"><span class="function">LinkNode&lt;T&gt; *<span class="title">Search</span><span class="params">( T x )</span></span>;	</span><br><span class="line">      <span class="comment">//搜索含数据x的元素</span></span><br><span class="line"><span class="function">LinkNode&lt;T&gt; * <span class="title">Locate</span><span class="params">( <span class="keyword">int</span> i )</span></span>;</span><br><span class="line">	   <span class="comment">//搜索第 i 个元素的地址</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span>  <span class="title">GetData</span> <span class="params">( <span class="keyword">int</span> i, T&amp; x )</span></span>;				 </span><br><span class="line">      <span class="comment">//取出表中第 i 个元素的值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> i ,T&amp; x)</span></span>;	 </span><br><span class="line">      <span class="comment">//将x插在表中第 i 个元素后</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Remove</span> <span class="params">(<span class="keyword">int</span> i ,T&amp; x)</span></span>;</span><br><span class="line">	  <span class="comment">//删除第i个元素，x返回该元素的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span>  <span class="title">IsEmpty</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> first-&gt;link==<span class="literal">NULL</span>?<span class="literal">true</span>:<span class="literal">false</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span>  <span class="title">IsFull</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>;</span><br><span class="line">List&lt;T&gt;&amp; <span class="keyword">operator</span>=(List&lt;T&gt;&amp; L);</span><br><span class="line">&#125;;   <span class="comment">//list类定义到此结束</span></span><br></pre></td></tr></table></figure>

<h5 id="链表类部分操作的实现"><a href="#链表类部分操作的实现" class="headerlink" title="链表类部分操作的实现"></a>链表类部分操作的实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">List</span> &lt;T&gt; :</span>:List(List&lt;T&gt;&amp; L) &#123; <span class="comment">//复制构造函数</span></span><br><span class="line">T value;    </span><br><span class="line">LinkNode&lt;T&gt; *srcptr=L.getHead();</span><br><span class="line">LinkNode&lt;T&gt; *destptr=first=<span class="keyword">new</span> LinkNode&lt;T&gt;;</span><br><span class="line"><span class="keyword">while</span> ( srcptr-&gt;link != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"> 	value=srcptr-&gt;link-&gt;data;</span><br><span class="line">	destptr-&gt;link=<span class="keyword">new</span> LinkNode&lt;T&gt;(value);</span><br><span class="line">	destptr=destptr-&gt;link;</span><br><span class="line">	srcptr = strptr-&gt;link; </span><br><span class="line">&#125;</span><br><span class="line">destptr-&gt;link=<span class="literal">NULL</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; //置空表</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">List</span> &lt;T&gt; :</span>: MakeEmpty ( ) &#123;</span><br><span class="line"><span class="comment">//删去链表中除附加头结点外的所有其他结点</span></span><br><span class="line"><span class="comment">//即把表变为有附加头结点的空表</span></span><br><span class="line">    LinkNode&lt;T&gt; *q;</span><br><span class="line">    <span class="keyword">while</span> ( first-&gt;link != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"> 	     q = first-&gt;link;  first-&gt;link = q-&gt;link;	<span class="comment">//将表头结点后第一个结点q从链中摘下</span></span><br><span class="line">	     <span class="keyword">delete</span> q;        <span class="comment">//释放它 </span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;//链表长度</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">List</span>&lt;T&gt; :</span>: Length ( ) <span class="keyword">const</span> &#123;</span><br><span class="line">                                <span class="comment">//求单链表的长度</span></span><br><span class="line">     LinkNode&lt;T&gt; *p = first-&gt;link;</span><br><span class="line">               <span class="comment">//检测指针 p 指示第一个结点</span></span><br><span class="line">     <span class="keyword">int</span> count = <span class="number">0</span>; </span><br><span class="line">     <span class="keyword">while</span> ( p != <span class="literal">NULL</span> ) &#123;      <span class="comment">//逐个结点检测</span></span><br><span class="line">       count++; </span><br><span class="line">       p = p-&gt;link;</span><br><span class="line">&#125;			</span><br><span class="line">     <span class="keyword">return</span> count; <span class="comment">//注意count的初始化和返回值之间的关系</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; //搜索</span></span><br><span class="line"><span class="class"><span class="title">LinkNode</span>&lt;T&gt; *<span class="title">List</span> &lt;T&gt; :</span>: Search (T x ) &#123;</span><br><span class="line"><span class="comment">//在链表中从头搜索其数据值为x的结点 </span></span><br><span class="line">     LinkNode&lt;T&gt; * p = first-&gt;link;</span><br><span class="line">     <span class="comment">//检测指针 p 指示第一个结点</span></span><br><span class="line">     <span class="keyword">while</span> ( p != <span class="literal">NULL</span> )</span><br><span class="line">            <span class="keyword">if</span> ( p-&gt;data == x ) <span class="keyword">break</span>; </span><br><span class="line">         <span class="keyword">else</span> p = p-&gt;link;</span><br><span class="line">     <span class="keyword">return</span> p; </span><br><span class="line">     <span class="comment">// p 在搜索成功时返回找到的结点地址</span></span><br><span class="line">     <span class="comment">// p 在搜索不成功时返回空值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; //定位</span></span><br><span class="line"><span class="class"><span class="title">LinkNode</span>&lt;T&gt; *<span class="title">List</span>&lt;T&gt; :</span>: Locate ( <span class="keyword">int</span> i ) &#123;</span><br><span class="line"><span class="comment">//定位函数。返回表中第 i 个元素的地址</span></span><br><span class="line"><span class="comment">//若 i &lt; 0或 i 超出，则返回NULL</span></span><br><span class="line">    <span class="keyword">if</span> ( i &lt; <span class="number">0</span> ) <span class="keyword">return</span> <span class="literal">NULL</span>;   <span class="comment">// i 值不合理</span></span><br><span class="line">    LinkNode&lt;T&gt; * p =first; </span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> ( p != <span class="literal">NULL</span> &amp;&amp; k &lt; i ) </span><br><span class="line">       &#123;p = p-&gt;link ; k++;&#125;	    <span class="comment">//找第 i 个结点 </span></span><br><span class="line">    <span class="keyword">return</span> p;    <span class="comment">//返回第 i 个结点地址或NULL</span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; //取值</span></span><br><span class="line"><span class="class"><span class="title">bool</span> * <span class="title">List</span>&lt;T&gt; :</span>: GetData ( <span class="keyword">int</span> i, T&amp; x ) &#123;</span><br><span class="line">                            <span class="comment">//取出链表中当前元素的值</span></span><br><span class="line"><span class="keyword">if</span> (i&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;     </span><br><span class="line">LinkNode&lt;T&gt; *p = Locate ( i );</span><br><span class="line">                           <span class="comment">// p 指向链表第 i 个结点</span></span><br><span class="line">     <span class="keyword">if</span> ( p == <span class="literal">NULL</span> )</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;		</span><br><span class="line">     <span class="keyword">else</span> &#123; x=p-&gt;data; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;  //单链表的实现———插入</span></span><br><span class="line"><span class="class"> <span class="title">bool</span>  <span class="title">LinkList</span>&lt;T&gt; :</span>: Insert(<span class="keyword">int</span> i, T&amp;  x) <span class="comment">//在第i个位置后插入x</span></span><br><span class="line"> &#123;</span><br><span class="line">     LinkNode&lt;T&gt; * p=Locate(i);</span><br><span class="line">     <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span> ;      <span class="comment">//没有找到</span></span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        s = <span class="keyword">new</span> LinkNode&lt;T&gt;(x);   <span class="comment">//申请一个结点s</span></span><br><span class="line">       <span class="keyword">if</span>(s==null)&#123;<span class="built_in">cerr</span>&lt;&lt;<span class="string">"store is error"</span>&lt;&lt;<span class="built_in">endl</span>; <span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">        s-&gt;link= p-&gt;link;</span><br><span class="line">        p-&gt;link = s;   <span class="comment">//结点s插入结点p之后</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;  //删除</span></span><br><span class="line"><span class="class"><span class="title">bool</span>   <span class="title">List</span>&lt;T&gt; :</span>: Remove ( <span class="keyword">int</span> i ,T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"> LinkNode&lt;T&gt; *p = Locate (i<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="literal">NULL</span> || p-&gt;link == <span class="literal">NULL</span>)  <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">  </span><br><span class="line">  LinkNode&lt;T&gt; *q= p-&gt;link; </span><br><span class="line">   x = q-&gt;data;         </span><br><span class="line">   p-&gt;link = q-&gt;link;              </span><br><span class="line">   <span class="keyword">delete</span> q;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; //重载</span></span><br><span class="line"><span class="class"><span class="title">List</span>&lt;T&gt;&amp; <span class="title">List</span>&lt;T&gt; :</span>: Operator= (List&lt;T&gt;&amp; L) &#123;</span><br><span class="line"><span class="comment">//赋值操作，A=B，A是调用者，B是实参</span></span><br><span class="line">T value;    </span><br><span class="line">LinkNode&lt;T&gt; *srcptr=L.getHead();</span><br><span class="line">LinkNode&lt;T&gt; *destptr=first=<span class="keyword">new</span> LinkNode&lt;T&gt;;</span><br><span class="line"><span class="keyword">while</span> ( srcptr-&gt;link != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"> 	value=srcptr-&gt;link-&gt;data;</span><br><span class="line">	destptr-&gt;link=<span class="keyword">new</span> LinkNode&lt;T&gt;(value);</span><br><span class="line">	destptr=destptr-&gt;link;</span><br><span class="line">	srcptr = strptr-&gt;link; </span><br><span class="line">&#125;</span><br><span class="line">destptr-&gt;link=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> * <span class="keyword">this</span>；<span class="comment">//加此句是使得表达式"A=B"的值为A，可做连续赋值  &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;class T&gt;  <span class="comment">//前插法建立单链表</span></span><br><span class="line"><span class="keyword">void</span> List &lt;T&gt; :: inputFront (T endTag ) &#123;</span><br><span class="line">LinkNode&lt;T&gt; *newNode;  T val;</span><br><span class="line">makeEmpty();     </span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;val;</span><br><span class="line"><span class="keyword">while</span> (val != endTag) &#123;</span><br><span class="line">	newNode = <span class="keyword">new</span> LinkNode&lt;T&gt;(val);</span><br><span class="line">	<span class="keyword">if</span>(newNode==<span class="literal">NULL</span>)</span><br><span class="line">		&#123;<span class="built_in">cerr</span>&lt;&lt;<span class="string">"error"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">	newNode-&gt;link=first-&gt;link;</span><br><span class="line">	first-&gt;link=newNode;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;val;</span><br><span class="line">    &#125;  &#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;  //后插法建立单链表</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">List</span> &lt;T&gt; :</span>: inputRear(T endTag ) &#123;</span><br><span class="line">LinkNode&lt;T&gt; *newNode，*last，T val;</span><br><span class="line">makeEmpty();     </span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;val; last=first;</span><br><span class="line"><span class="keyword">while</span> (val != endTag) &#123;</span><br><span class="line">	newNode = <span class="keyword">new</span> LinkNode&lt;T&gt;(val);</span><br><span class="line">	<span class="keyword">if</span>(newNode==<span class="literal">NULL</span>)</span><br><span class="line">		&#123;<span class="built_in">cerr</span>&lt;&lt;<span class="string">"error"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">	last-&gt;link=newNode;</span><br><span class="line">	last=newNode;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;val;</span><br><span class="line">    &#125;  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="单向循环链表（简称循环链表）"><a href="#单向循环链表（简称循环链表）" class="headerlink" title="单向循环链表（简称循环链表）"></a>单向循环链表（简称循环链表）</h4><p>循环链表1：将单链表的首尾相接，将终端结点的指针域由空指针改为指向开始结点，构成单循环链表，简称循环链表。</p>
<p>循环链表2：带尾指针的循环链表，在循环链表里设置last不仅仅有利于插入，删除也很方便。所以，在后面的循环链表的定义里，封装了两个指针first和last</p>
<p>循环链表3： 要使空表和非空表的处理一致，可附设头结点**</p>
<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200616105055940-357437200.png" alt=""></p>
<p>循环链表中没有明显的尾端，如何避免死循环？</p>
<p>循环条件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(单链表)p != <span class="literal">NULL</span>-&gt;p != first (循环链)</span><br><span class="line"></span><br><span class="line">(单链表）p-&gt;link != <span class="literal">NULL</span>-&gt;p-&gt;link != first(循环链)</span><br></pre></td></tr></table></figure>

<h5 id="循环链表类的定义"><a href="#循环链表类的定义" class="headerlink" title="循环链表类的定义"></a>循环链表类的定义</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;    //结点定义</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">CircLinkNode</span> &#123;</span></span><br><span class="line">T  data;			 <span class="comment">//结点数据</span></span><br><span class="line">CircLinkNode&lt;T&gt; *link;      <span class="comment">//链接指针</span></span><br><span class="line"></span><br><span class="line">CircLinkNode ( CircLinkNode&lt;T&gt; *next = <span class="literal">NULL</span> ) : </span><br><span class="line">    link ( next ) &#123; &#125;     </span><br><span class="line">CircLinkNode ( T d ,CircLinkNode&lt;T&gt; *next = <span class="literal">NULL</span> ) : data ( d ), link ( next ) &#123; &#125;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">CircList</span> ：<span class="title">pulic</span> <span class="title">LinearList</span>&lt;T&gt; &#123;</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">     CircLinkNode&lt;T&gt; *first, *last;</span><br><span class="line">     <span class="comment">//链表的表头指针、当前指针和表尾指针</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">     CircList ( <span class="keyword">const</span> T&amp; x );	</span><br><span class="line">     CircList ( CircList&lt;T&gt;&amp; L);			</span><br><span class="line">     ~CircList ( );				</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">Length</span> <span class="params">( )</span> <span class="keyword">const</span></span>;				</span><br><span class="line">     <span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span> <span class="params">( )</span> </span>&#123; <span class="keyword">return</span> first-&gt;link == first; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">CircLinkNode&lt;T&gt; * <span class="title">getHead</span><span class="params">( )</span><span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setHead</span><span class="params">(CircLinkNode&lt;T&gt; *p)</span></span>; </span><br><span class="line"><span class="function">CircLinkNode&lt;T&gt; * <span class="title">Search</span><span class="params">(T x)</span></span>;</span><br><span class="line"><span class="function">CircLinkNode&lt;T&gt; * <span class="title">Locate</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function">T *<span class="title">getData</span> <span class="params">( <span class="keyword">int</span> i )</span></span>;			</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">( <span class="keyword">int</span> i, T&amp; x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> i, T&amp; x )</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Remove</span> <span class="params">(<span class="keyword">int</span> i, T&amp; x )</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//循环链表与单链表的操作实现，最主要的不同就是扫描到链尾，遇到的不是NULL，而是表头first</span></span><br></pre></td></tr></table></figure>

<h5 id="循环链表类部分操作的实现"><a href="#循环链表类部分操作的实现" class="headerlink" title="循环链表类部分操作的实现"></a>循环链表类部分操作的实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; //循环链表的搜索算法</span></span><br><span class="line"><span class="class"><span class="title">CircListNode</span>&lt;T&gt; * <span class="title">CircList</span>&lt;T&gt;:</span>:Search( T x ) </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//在链表中从头搜索其数据值为 x 的结点</span></span><br><span class="line">     current = first-&gt;link;</span><br><span class="line">     <span class="keyword">while</span> ( current != first &amp;&amp; current-&gt;data != x )  </span><br><span class="line">         current = current-&gt;link;</span><br><span class="line">     <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;  //循环链表——插入</span></span><br><span class="line"><span class="class"> <span class="title">bool</span> <span class="title">CircList</span>&lt;T&gt; :</span>:Insert(<span class="keyword">int</span> i, T x)<span class="comment">//在i项后面插入一项</span></span><br><span class="line"> &#123;   <span class="keyword">if</span> i&lt;<span class="number">0</span> <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    CircLinkNode&lt;T&gt; *  p ;  <span class="keyword">int</span> count;   </span><br><span class="line">    <span class="keyword">if</span> (i==<span class="number">0</span>) &#123;p=first;count=<span class="number">0</span>&#125;<span class="keyword">else</span>&#123; p=first-&gt;link; count=<span class="number">1</span>;&#125;</span><br><span class="line"><span class="comment">//第一个位置特别处理。避免指针出界状态与初始状态重合</span></span><br><span class="line">     <span class="keyword">while</span> (p != first &amp;&amp; count &lt; i )</span><br><span class="line">     &#123;</span><br><span class="line">          p = p-&gt;link;    count++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (p == first&amp;&amp;i!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">else</span> &#123; </span><br><span class="line">          s = <span class="keyword">new</span> CircLinkNode&lt;T&gt;; s-&gt;data = x;  </span><br><span class="line">          s-&gt;link = p-&gt; link; p-&gt; link = s;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;     </span><br><span class="line"><span class="comment">//循环链表，循环指针结束条件不同于单链表，所以初始化不同。需要特别考虑第一个元素</span></span><br></pre></td></tr></table></figure>

<h5 id="用循环链表求解约瑟夫问题"><a href="#用循环链表求解约瑟夫问题" class="headerlink" title="用循环链表求解约瑟夫问题"></a>用循环链表求解约瑟夫问题</h5><p>约瑟夫问题的提法<br> n 个人围成一个圆圈，首先第 1 个人从 1 开始一个人一个人顺时针报数,  报到第 m 个人，令其出列。然后再从下一 个人开始，从 1 顺时针报数，报到第 m 个人，再令其出列，…，如此下去,  直到圆圈中只剩一个人为止。此人即为优胜者。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、带头结点的完整代码 </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;    //结点定义</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">CircLinkNode</span> &#123;</span></span><br><span class="line">T  data;			 <span class="comment">//结点数据</span></span><br><span class="line">CircLinkNode&lt;T&gt; *link;      <span class="comment">//链接指针</span></span><br><span class="line"></span><br><span class="line">CircLinkNode ( CircLinkNode&lt;T&gt; *next = <span class="literal">NULL</span> ):link ( next ) &#123; &#125;     </span><br><span class="line">CircLinkNode ( T d,CircLinkNode&lt;T&gt; *next = <span class="literal">NULL</span> ):data(d), link(next) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">CircList</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">     CircLinkNode&lt;T&gt; *first, *last;<span class="comment">//链表的表头指针、当前指针和表尾指针</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    	CircList()&#123;first=<span class="keyword">new</span> CircLinkNode&lt;T&gt;(); first-&gt;link=first;&#125;; </span><br><span class="line">     <span class="comment">//CircList ( const T&amp; x );	</span></span><br><span class="line">    <span class="comment">// CircList ( CircList&lt;T&gt;&amp; L);			</span></span><br><span class="line">    <span class="comment">// ~CircList ( );</span></span><br><span class="line">    <span class="comment">// void setHead(CircLinkNode&lt;T&gt; *p); </span></span><br><span class="line">    <span class="comment">// CircLinkNode&lt;T&gt; * Search(T x);</span></span><br><span class="line">    <span class="comment">// CircLinkNode&lt;T&gt; * Locate(int i);</span></span><br><span class="line">    <span class="comment">// T *getData ( int i );			</span></span><br><span class="line">    <span class="comment">// void setData( int i, T&amp; x);</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">insert</span> <span class="params">(<span class="keyword">int</span> i, T&amp; x )</span></span>; </span><br><span class="line">    <span class="comment">// bool Remove (int i, T&amp; x );</span></span><br><span class="line">	<span class="comment">//bool IsEmpty ( ) &#123; return first-&gt;link == first; &#125;</span></span><br><span class="line">    <span class="comment">// int Length ( ) const;				</span></span><br><span class="line">	   <span class="function">CircLinkNode&lt;T&gt; * <span class="title">getHead</span><span class="params">( )</span><span class="keyword">const</span></span>&#123;<span class="keyword">return</span> first;&#125;;</span><br><span class="line">	 <span class="comment">//void input(int i); //输入i个元素</span></span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">CircList</span>&lt;T&gt;:</span>:insert(<span class="keyword">int</span> i, T&amp; x)<span class="comment">//在i项后面插入一项</span></span><br><span class="line"> &#123;   <span class="keyword">if</span>(i&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    CircLinkNode&lt;T&gt; *  p,s ;  </span><br><span class="line">	<span class="keyword">int</span> count ;   </span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>) &#123;p=first;count=<span class="number">0</span>;&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;p=first-&gt;link;count=<span class="number">1</span>;&#125;  <span class="comment">//第一个位置特别处理。避免循环指针出界状态与初始状态重合</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span> (p != first &amp;&amp; count &lt; i )</span><br><span class="line">     &#123;</span><br><span class="line">          p = p-&gt;link; </span><br><span class="line">          count++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (p == first&amp;&amp;i!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">else</span> &#123; </span><br><span class="line">         <span class="comment">// s = new CircLinkNode&lt;T&gt;(); s-&gt;data = x;  </span></span><br><span class="line">         <span class="comment">// s-&gt;link = p-&gt;link; p-&gt;link = s;</span></span><br><span class="line">		  p-&gt;link=<span class="keyword">new</span> CircLinkNode&lt;T&gt;(x,p-&gt;link);</span><br><span class="line">		  <span class="built_in">cout</span>&lt;&lt;<span class="string">"input:"</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Josephus</span>(<span class="title">CircList</span>&lt;T&gt;&amp; <span class="title">Js</span>, <span class="title">int</span> <span class="title">n</span>, <span class="title">int</span> <span class="title">m</span>) &#123;</span></span><br><span class="line">    CircLinkNode&lt;T&gt; *p,*first, *pre = <span class="literal">NULL</span>;</span><br><span class="line">	first= Js.getHead(); </span><br><span class="line">	p=first-&gt;link; </span><br><span class="line">	<span class="keyword">if</span>(p==first) <span class="built_in">exit</span>(<span class="number">1</span>); <span class="comment">//表空退出</span></span><br><span class="line">     <span class="keyword">int</span> i, j;</span><br><span class="line">     <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++ ) &#123;     	<span class="comment">//执行n-1次</span></span><br><span class="line">		  </span><br><span class="line">		 <span class="keyword">if</span>(p==first)p=p-&gt;link;</span><br><span class="line">         <span class="keyword">for</span> ( j = <span class="number">1</span>; j &lt; m; j++) 		<span class="comment">//数m-1个人</span></span><br><span class="line">              &#123; </span><br><span class="line">			    pre = p;  p = p-&gt;link; </span><br><span class="line">		        <span class="keyword">if</span>(p==first)j--;</span><br><span class="line">		  &#125;</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; <span class="string">"出列的人是"</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">          pre-&gt;link = p-&gt;link;  <span class="keyword">delete</span> p;     	<span class="comment">//删去</span></span><br><span class="line">          p = pre-&gt;link; 		</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;		</span><br><span class="line">     CircList&lt;<span class="keyword">int</span>&gt; clist;</span><br><span class="line">     <span class="keyword">int</span> i,n,m;		</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入游戏者人数和报数间隔 : "</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++ ) clist.insert(i<span class="number">-1</span>, i);    <span class="comment">//约瑟夫环    </span></span><br><span class="line">	 <span class="comment">// inclist.input(n);  //函数需考虑第一个元素插入的特殊性</span></span><br><span class="line">     Josephus(clist, n, m);                 <span class="comment">//解决约瑟夫问题</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 不带头结点的完整代码</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;    //结点定义</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">CircLinkNode</span> &#123;</span></span><br><span class="line">T  data;			 <span class="comment">//结点数据</span></span><br><span class="line">CircLinkNode&lt;T&gt; *link;      <span class="comment">//链接指针</span></span><br><span class="line"></span><br><span class="line">CircLinkNode ( CircLinkNode&lt;T&gt; *next = <span class="literal">NULL</span> ):link ( next ) &#123; &#125;     </span><br><span class="line">CircLinkNode ( T&amp; d,CircLinkNode&lt;T&gt; *next = <span class="literal">NULL</span> ):data(d), link(next) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">CircList</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">     CircLinkNode&lt;T&gt; *first, *last;<span class="comment">//链表的表头指针、当前指针和表尾指针</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    	CircList()&#123;first=last=<span class="literal">NULL</span>;&#125;</span><br><span class="line">     <span class="comment">//CircList ( const T&amp; x );	</span></span><br><span class="line">    <span class="comment">// CircList ( CircList&lt;T&gt;&amp; L);			</span></span><br><span class="line">    <span class="comment">// ~CircList ( );</span></span><br><span class="line">	<span class="comment">// void setHead(CircLinkNode&lt;T&gt; *p); </span></span><br><span class="line">    <span class="comment">// CircLinkNode&lt;T&gt; * Search(T x);</span></span><br><span class="line">    <span class="comment">// CircLinkNode&lt;T&gt; * Locate(int i);</span></span><br><span class="line">    <span class="comment">// T *getData ( int i );			</span></span><br><span class="line">    <span class="comment">// void setData( int i, T&amp; x);</span></span><br><span class="line">    <span class="comment">//    bool insert (int i, T&amp; x ); </span></span><br><span class="line">    <span class="comment">// bool Remove (int i, T&amp; x );</span></span><br><span class="line">	<span class="comment">//bool IsEmpty ( ) &#123; return first-&gt;link == first; &#125;</span></span><br><span class="line">    <span class="comment">// int Length ( ) const;				</span></span><br><span class="line">		<span class="function">CircLinkNode&lt;T&gt; * <span class="title">getHead</span><span class="params">( )</span><span class="keyword">const</span></span>&#123;<span class="keyword">return</span> first;&#125;;</span><br><span class="line">	    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">(<span class="keyword">int</span> i)</span></span>; <span class="comment">//从空表开始，输入i个元素</span></span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">CircList</span>&lt;T&gt;:</span>:input(<span class="keyword">int</span> i)<span class="comment">//插入i项</span></span><br><span class="line">&#123; <span class="keyword">if</span>(i&lt;=<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">//makeEmpty(); 清空原表 </span></span><br><span class="line">   T temp;</span><br><span class="line">   <span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">  first=last=<span class="keyword">new</span> CircLinkNode&lt;T&gt;(temp); first-&gt;link=first; <span class="comment">//特别处理第一个元素</span></span><br><span class="line">  	<span class="built_in">cout</span>&lt;&lt;<span class="string">"输入元素"</span>&lt;&lt;temp&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=i;j++)</span><br><span class="line">  &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">    last-&gt;link=<span class="keyword">new</span> CircLinkNode&lt;T&gt;(temp,last-&gt;link);</span><br><span class="line">	last=last-&gt;link;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"输入元素"</span>&lt;&lt;temp&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Josephus</span>(<span class="title">CircList</span>&lt;T&gt;&amp; <span class="title">Js</span>, <span class="title">int</span> <span class="title">n</span>, <span class="title">int</span> <span class="title">m</span>) &#123;</span></span><br><span class="line">    CircLinkNode&lt;T&gt; *p,*first, *pre = <span class="literal">NULL</span>;</span><br><span class="line">	p=first= Js.getHead(); </span><br><span class="line">	<span class="keyword">if</span>(first==<span class="literal">NULL</span>) <span class="built_in">exit</span>(<span class="number">1</span>); <span class="comment">//表空退出</span></span><br><span class="line">     <span class="keyword">int</span> i, j;</span><br><span class="line">     <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++ ) &#123;     	<span class="comment">//执行n-1次</span></span><br><span class="line">		  </span><br><span class="line">         <span class="keyword">for</span> ( j = <span class="number">1</span>; j &lt; m; j++) 		<span class="comment">//数m-1个人</span></span><br><span class="line">              &#123; </span><br><span class="line">			    pre = p;  p = p-&gt;link; </span><br><span class="line">		  &#125;</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; <span class="string">"出列的人是"</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">          pre-&gt;link = p-&gt;link;  <span class="keyword">delete</span> p;     	<span class="comment">//删去</span></span><br><span class="line">          p = pre-&gt;link; 		</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;		</span><br><span class="line">     CircList&lt;<span class="keyword">int</span>&gt; clist;</span><br><span class="line">     <span class="keyword">int</span> n,m;		</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入游戏者人数和报数间隔 : "</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">     <span class="comment">//for (i = 1; i &lt;= n; i++ ) clist.insert(i-1, i);    //约瑟夫环    </span></span><br><span class="line">	 clist.input(n);  <span class="comment">//函数需考虑第一个元素插入的特殊性</span></span><br><span class="line">     Josephus(clist, n, m);                 <span class="comment">//解决约瑟夫问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="双向循环链表（简称双链表）"><a href="#双向循环链表（简称双链表）" class="headerlink" title="双向循环链表（简称双链表）"></a>双向循环链表（简称双链表）</h4><p>双向链表简称双链表，为了解决链表在前驱和后继方向都能遍历的线性链表。</p>
<p>双向链表通常采用带附加头结点的循环链表形式。</p>
<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200616105127911-1608277404.png" alt=""><br><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200616105138046-920392544.png" alt=""><br><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200616105146702-2122717864.png" alt=""><br><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200616105152814-708827332.png" alt=""></p>
<h5 id="双向循环链表类的定义"><a href="#双向循环链表类的定义" class="headerlink" title="双向循环链表类的定义"></a>双向循环链表类的定义</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">DblNode</span> &#123;</span>           <span class="comment">//链表结点的定义</span></span><br><span class="line">   T data;                                           <span class="comment">//数据</span></span><br><span class="line">   DblNode&lt;T&gt; * lLink, * rLink;     <span class="comment">//指针</span></span><br><span class="line">   </span><br><span class="line">  DblNode( DblNode&lt;T&gt; * left=<span class="literal">NULL</span>, DblNode&lt;T&gt; * right =<span class="literal">NULL</span> ) :   lLink (left), rLink (right)&#123; &#125;</span><br><span class="line">   DblNode (T value, DblNode&lt;T&gt; * left=<span class="literal">NULL</span>, </span><br><span class="line">        DblNode&lt;T&gt; *  right=<span class="literal">NULL</span> ) :</span><br><span class="line">         data (value), lLink (left), rLink (right) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">DblList</span>:</span>Public LinearList&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DblNode&lt;T&gt; * first;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DblList ( T uniqueVal );    <span class="comment">//构造函数</span></span><br><span class="line">    ~DblList ( );                             <span class="comment">//析构函数</span></span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">Length</span> <span class="params">( )</span> <span class="keyword">const</span></span>;                 <span class="comment">//计算长度</span></span><br><span class="line">     <span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span> <span class="params">( )</span>                    <span class="comment">//判链表空否</span></span></span><br><span class="line"><span class="function">        </span>&#123; <span class="keyword">return</span> first-&gt;rlink == first; &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">DblNode&lt;T&gt;* <span class="title">getHead</span><span class="params">( )</span><span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> first; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setHead</span><span class="params">(DblNode&lt;T&gt; *ptr)</span></span>&#123; first=ptr; &#125;</span><br><span class="line"><span class="function">DblNode&lt;T&gt;* <span class="title">Search</span><span class="params">(<span class="keyword">const</span> t&amp; x)</span></span>;</span><br><span class="line">     <span class="comment">//沿后继方向寻找等于x的结点</span></span><br><span class="line"><span class="function">DblNode&lt;T&gt; *<span class="title">Locate</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> d)</span></span>;</span><br><span class="line">    <span class="comment">//定位序号为i的结点，</span></span><br><span class="line">   <span class="comment">//d=0按前驱方向，否则按后继方向</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">int</span> i, T&amp; x,<span class="keyword">int</span> d )</span></span>;			</span><br><span class="line">   <span class="comment">//在第i个结点后插入一个包含值x的新结点</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Remove</span> <span class="params">(<span class="keyword">int</span> i, T&amp; x,<span class="keyword">int</span> d )</span></span>;	<span class="comment">//删除第i个结点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="双向循环链表的部分实现"><a href="#双向循环链表的部分实现" class="headerlink" title="双向循环链表的部分实现"></a>双向循环链表的部分实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; //-定位算法</span></span><br><span class="line"><span class="class"> <span class="title">DblNode</span>&lt;T&gt;* <span class="title">DblList</span>:</span>:Locate(<span class="keyword">int</span> i，<span class="keyword">int</span> d) &#123;</span><br><span class="line"><span class="comment">//定位第i个结点, d=0为前驱方向,否则为后继方向。</span></span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">if</span>(i==<span class="number">0</span>)<span class="keyword">return</span> first ; </span><br><span class="line">    DblNode&lt;T&gt; * current ;</span><br><span class="line">    <span class="keyword">if</span>(d==<span class="number">0</span>) current=first-&gt;lLink;</span><br><span class="line">    <span class="keyword">else</span> current=first-&gt;rLink;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">	 <span class="keyword">if</span> ( current == first )  <span class="keyword">break</span>; <span class="comment">//越界</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(d==<span class="number">0</span>) current = current-&gt;lLink;	</span><br><span class="line">                 <span class="keyword">else</span> current = current-&gt;rLink;	</span><br><span class="line">    <span class="keyword">if</span>(current != first) <span class="keyword">return</span> current;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除算法（非空表）</span></span><br><span class="line">current-&gt;rLink-&gt;lLink = current-&gt;lLink;        </span><br><span class="line">current-&gt;lLink-&gt;rLink = current-&gt;rLink;</span><br><span class="line"><span class="keyword">delete</span> current ;</span><br></pre></td></tr></table></figure>

<p>注意双向链表的插入：</p>
<p>双向循环链表的插入分前驱方向的插入和后继方向的插入。<br>要求在第i个结点之后插入新结点NewNode，则<br> 1.后继方向：从前往后找第i个结点current，在current之后插入NewNode<br> 2.前驱方向：从后往前找第i个结点current，在current之前插入NewNode。</p>
<h4 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h4><p>静态链表：用数组来表示单链表，用数组元素的下标来模拟单链表的指针。</p>
<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200616105223851-1301727002.png" alt=""></p>
<p>data：存储放数据元素；<br>next：也称游标，存储该元素的后继在数组的下标。</p>
<h5 id="静态链表的结构"><a href="#静态链表的结构" class="headerlink" title="静态链表的结构"></a>静态链表的结构</h5><p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200616105248685-1261349834.png" alt=""></p>
<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200616105300071-196894135.png" alt=""></p>
<p>0号是表头结点，link给出首元结点地址。<br>循环链表收尾时link = 0，回到表头结点。如果不是循环链表，收尾结点指针link=-1。<br>link指针是数组下标，因此是整数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态链表的存储结构定义如下：</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSize = <span class="number">100</span>;        <span class="comment">//100只是示例数据</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">DataType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">SNode</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">    DataType data;           <span class="comment">// DataType表示不确定的数据类型</span></span><br><span class="line">    <span class="keyword">int</span> next;                       <span class="comment">//指针域（也称游标）</span></span><br><span class="line">&#125; SList[MaxSize];</span><br></pre></td></tr></table></figure>

<h5 id="静态链表的应用——多项式-Polynomial"><a href="#静态链表的应用——多项式-Polynomial" class="headerlink" title="静态链表的应用——多项式 (Polynomial)"></a>静态链表的应用——多项式 (<strong>Polynomial</strong>)</h5><p>n阶多项式 Pn(x) 有 n+1 项。<br> 系数 a0, a1, a2, …, an<br> 指数 0, 1, 2, …, n。按升幂排列</p>
<p>多项式的存储表示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.用一维静态数组表示，下标就是指数，值是系数</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">	<span class="keyword">int</span> degree;		</span><br><span class="line">	<span class="keyword">float</span> coef [maxDegree+<span class="number">1</span>];</span><br><span class="line">Pn(x)可以表示为： </span><br><span class="line">      pl.degree = n</span><br><span class="line">      pl.coef[i] = ai <span class="comment">//0=&lt;i&lt;=n</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">//2.用一维动态数组存储多项式的系数，下标即指数</span></span><br><span class="line"><span class="keyword">private</span>: 	</span><br><span class="line"><span class="keyword">int</span> degree;</span><br><span class="line"><span class="keyword">float</span> * coef;</span><br><span class="line"></span><br><span class="line">Polynomial::Polynomial (<span class="keyword">int</span> sz) &#123;<span class="comment">//在构造函数里初始化并分配空间。</span></span><br><span class="line">		    degree = sz;</span><br><span class="line">		    coef = <span class="keyword">new</span> <span class="keyword">float</span> [degree + <span class="number">1</span>];</span><br><span class="line">  	        &#125;</span><br><span class="line"><span class="comment">//以上两种存储表示适用于指数连续排列的多项式。对于指数跳跃很大的稀疏多项式来说则太浪费空间了。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.设一元多项式多大可能阶为maxDegree，当前的多项式的最高阶为n。数组元素存放非零项的系数和指数,下标不再是指数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.用链表表示多项式，每个项term为如下结构：	</span></span><br><span class="line">Term |coef|<span class="built_in">exp</span>|link|</span><br><span class="line">优点是： 多项式的项数可以动态地增长，不存在存储溢出问题，也不浪费空间。 插入、删除方便。</span><br></pre></td></tr></table></figure>

<p>多项式(polynomial)类的链表定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Term</span> &#123;</span>	            <span class="comment">//多项式结点定义	</span></span><br><span class="line">    <span class="keyword">float</span> coef;	            <span class="comment">//系数		</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">exp</span>;		            <span class="comment">//指数</span></span><br><span class="line">    Term *link;		  <span class="comment">//链接指针</span></span><br><span class="line">    </span><br><span class="line">   Term (<span class="keyword">float</span> c, <span class="keyword">int</span> e, Term *next = <span class="literal">NULL</span>)</span><br><span class="line">        &#123; coef = c;  <span class="built_in">exp</span> = e;  link = next;&#125;</span><br><span class="line">	<span class="function">Term *<span class="title">InsertAfter</span> <span class="params">( <span class="keyword">float</span> c, <span class="keyword">int</span> e)</span></span>; </span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp;, </span><br><span class="line">                  <span class="keyword">const</span> Term&amp; );</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function">Term *<span class="title">Term::InsertAfter</span> <span class="params">( <span class="keyword">float</span> c, <span class="keyword">int</span> e )</span> </span>&#123;</span><br><span class="line"><span class="comment">//在调用此函数的对象后插入一个新项</span></span><br><span class="line">     link = <span class="keyword">new</span> Term (c, e, link);	</span><br><span class="line">                	       <span class="comment">//创建一个新结点，自动链接</span></span><br><span class="line">		                 <span class="comment">//插入到this结点后面</span></span><br><span class="line">     <span class="keyword">return</span> link;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polynomial</span> &#123;</span>			<span class="comment">//多项式类的定义</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Polynomal() &#123; first = <span class="keyword">new</span> Term(<span class="number">0</span>, <span class="number">-1</span>); &#125;	<span class="comment">//构造函数</span></span><br><span class="line">	Polynomal ( Polynomal&amp; R);            <span class="comment">//复制构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">maxOrder</span><span class="params">()</span></span>;	  			  <span class="comment">//计算最大阶数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Term *first;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp;, </span><br><span class="line">           <span class="keyword">const</span> Polynomal&amp; );</span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span> &gt;&gt; ( istream&amp;, </span><br><span class="line">          Polynomal&amp; );</span><br><span class="line">    <span class="keyword">friend</span> Polynomial <span class="keyword">operator</span> + ( Polynomial&amp; A, Polynomial&amp; B );</span><br><span class="line">    <span class="keyword">friend</span> Polynomial <span class="keyword">operator</span> * ( Polynomial&amp; A, Polynomial&amp; B);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>多项式的相加：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Polynomial <span class="keyword">operator</span> + </span><br><span class="line">    (Polynomial &amp; A, Polynomial &amp; B) &#123;</span><br><span class="line">    Term *pa, *pb, *pc, *p;</span><br><span class="line">     <span class="keyword">float</span>  temp; </span><br><span class="line">     Polynomal C; </span><br><span class="line">     pc=C.getHead( );</span><br><span class="line">     pa = A.getHead( )-&gt;link;   </span><br><span class="line">     pb = B.getHead( )-&gt;link;   <span class="comment">//检测指针pa和pb都指</span></span><br><span class="line">                     <span class="comment">//向自己所指多项式链表第一个结点</span></span><br><span class="line">                     </span><br><span class="line"><span class="keyword">while</span> ( pa!=<span class="literal">NULL</span> &amp;&amp; pb!=Null )&#123;①</span><br><span class="line">	<span class="keyword">if</span>(pa-&gt;<span class="built_in">exp</span>==pb-&gt;<span class="built_in">exp</span>)&#123;②</span><br><span class="line">		temp=pa-&gt;coef+pb-&gt;coef;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">fabs</span>(temp)&gt;<span class="number">0.001</span>)</span><br><span class="line">			pc=pc-&gt;InsertAfter(temp,pa-&gt;<span class="built_in">exp</span>);</span><br><span class="line">		pa=pa-&gt;link;  pb=pb-&gt;link; ②&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pa-&gt;<span class="built_in">exp</span> &lt; pb-&gt;<span class="built_in">exp</span>) &#123;③</span><br><span class="line">		pc=pc-&gt;InsertAfter(pa-&gt;coef, pa-&gt;<span class="built_in">exp</span>);</span><br><span class="line">		pa=pa-&gt;link ;</span><br><span class="line">         		&#125; ③</span><br><span class="line">		<span class="keyword">else</span> &#123;④</span><br><span class="line">			pc=pc-&gt;InsertAfter(pb-&gt;coef, pb-&gt;<span class="built_in">exp</span>) ;</span><br><span class="line">			pb=pb-&gt;link;</span><br><span class="line">			&#125; ④</span><br><span class="line">&#125; ①</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下代码是把余下的A或B部分链到C的后面。</span></span><br><span class="line"><span class="keyword">if</span>(pa!=<span class="literal">NULL</span>) p=pa; </span><br><span class="line"><span class="keyword">else</span> p=pb;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">	pc=pc-&gt;InsertAfter(p-&gt;coef, p-&gt;<span class="built_in">exp</span>);</span><br><span class="line">	p=p-&gt;link;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>课内学习</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构笔记（第九章）</title>
    <url>/2021/05/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="第九章-排序"><a href="#第九章-排序" class="headerlink" title="第九章 排序"></a>第九章 排序</h1><p>排序：将一组杂乱无章的数据按一定的规律顺次排列起来。<br>数据表(datalist): 它是待排序数据元素的有限集合。</p>
<p>排序的时间开销: 是衡量算法好坏的最重要的标志。排序的时间开销可用算法执行中的数据比较次数与数据移动次数来衡量。</p>
<p>排序算法的稳定性: 如果在元素序列中有两 个元素r[i]和r[j],<br>它们的关键码 k[i] == k[j] , 且在排序之前, 元素r[i]排在r[j]前面。<br>如果在排序之后, 元素r[i]仍在元素r[j]的前面,  则称这个排序方法是稳定的, 否则是不稳定的。</p>
<p>算法执行时所需的附加存储:   评价算法好坏的另一标准</p>
<p><strong>排序算法的存储结构</strong></p>
<p>从操作角度看，排序是线性结构的一种操作，待排序记录可以用顺序存储结构或链式存储结构存储。</p>
<p>假定1：采用顺序存储结构。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>  r[n+<span class="number">1</span>];   </span><br><span class="line"><span class="comment">//待排序记录存储在r[1]~r[n]，r[0]留做他用</span></span><br></pre></td></tr></table></figure>

<p>假定2：将待排序的记录序列排序为升序序列。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">待排序数据表的类定义</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>  DefaultSize = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Element</span> &#123;</span>			<span class="comment">//数据表元素定义</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T  key;				<span class="comment">//排序码</span></span><br><span class="line">   <span class="comment">// field otherdata;			//其他数据成员</span></span><br><span class="line">    Element&lt;T&gt;&amp; <span class="keyword">operator</span> = (Element&lt;T&gt;&amp; x) &#123;</span><br><span class="line">        key = x.key;  otherdata = x.otherdata;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> == (Element&lt;T&gt;&amp; x) </span><br><span class="line">        &#123; <span class="keyword">return</span> key == x.key; &#125;	<span class="comment">//判*this与x相等</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;= (Element&lt;T&gt;&amp; x)</span><br><span class="line">        &#123; <span class="keyword">return</span> key &lt;= x.key; &#125;	<span class="comment">//判*this小于或等于x</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;= (Element&lt;T&gt;&amp; x)</span><br><span class="line">        &#123; <span class="keyword">return</span> key &gt;= x.key; &#125;	<span class="comment">//判*this大于或等于x bool operator &gt; (Element&lt;T&gt;&amp; x)</span></span><br><span class="line">        &#123; <span class="keyword">return</span> key &gt; x.key; &#125;	<span class="comment">//判*this大于x</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Element&lt;T&gt;&amp; x)</span><br><span class="line">        &#123; <span class="keyword">return</span> key &lt; x.key; &#125;	<span class="comment">//判*this小于x</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">dataList</span> &#123;</span>			<span class="comment">//数据表类定义</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Element &lt;T&gt;* Vector;		<span class="comment">//存储排序元素的向量</span></span><br><span class="line">    <span class="keyword">int</span> maxSize; 			<span class="comment">//向量中最大元素个数</span></span><br><span class="line">    <span class="keyword">int</span> currentSize; 			<span class="comment">//当前元素个数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    datalist (<span class="keyword">int</span> maxSz = DefaultSize) :     <span class="comment">//构造函数</span></span><br><span class="line">        maxSize(maxSz), currentSize(<span class="number">0</span>) </span><br><span class="line">        &#123; Vector = <span class="keyword">new</span> Element&lt;T&gt;[maxSize]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> currentSize; &#125;	    <span class="comment">//取表长度</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Swap</span> <span class="params">(Element&lt;T&gt;&amp; x, Element&lt;T&gt;&amp; y)</span></span></span><br><span class="line"><span class="function">        </span>&#123; Element&lt;T&gt; temp = x;  x = y;  y = temp; &#125;</span><br><span class="line">    Element&lt;T&gt;&amp; <span class="keyword">operator</span> [](<span class="keyword">int</span> i) 	<span class="comment">//取第i个元素</span></span><br><span class="line">        &#123; <span class="keyword">return</span> Vector[i]; &#125; 		</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Partition</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> low, <span class="keyword">const</span> <span class="keyword">int</span> high)</span></span>;</span><br><span class="line">							<span class="comment">//快速排序划分</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>排序方法分类</strong></p>
<p><strong>内部排序</strong></p>
<p>策略不同：</p>
<p>插入排序（希尔排序）<br>交换排序（冒泡，快速排序）<br>选择排序（堆排序）<br>归并排序（二路归并）<br>分配排序（基数排序）</p>
<p>工作量不同：</p>
<p>简单的排序方法O(n2)<br>先进的排序方法O(nlogn)<br>基数排序O( d(n+radix ) )</p>
<p>内部排序的过程是一个逐步扩大记录的有序序列长度的过程。</p>
<h2 id="插入排序-Insert-Sorting"><a href="#插入排序-Insert-Sorting" class="headerlink" title="插入排序 (Insert Sorting)"></a><strong>插入排序</strong> <strong>(Insert Sorting)</strong></h2><p>基本方法是：每步将一个待排序的元素，按其排序码大小，插入到前面已经排好序的一组元素的适当位置上, 直到元素全部插入为止。</p>
<p>5种插入排序方法：<br>    (1) 直接插入排序;<br>    (2) 折半插入排序;<br>    (3) 2-路插入排序;<br>    (4) 表插入排序;<br>    (5) 希尔排序  </p>
<h3 id="直接插入排序-Insert-Sort"><a href="#直接插入排序-Insert-Sort" class="headerlink" title="直接插入排序 (Insert Sort)"></a><strong>直接插入排序</strong> <strong>(Insert Sort)</strong></h3><p><strong>基本思想是 :</strong> 当插入第i (i≥1) 个元素时，前面的V[0], V[1], …, V[i-1]已经排好序。这时，用V[i]的排序码与V[i-1], V[i-2], …的排序码顺序进行比较，找到插入位置即将V[i]插入，原来位置上的元素向后顺移。</p>
<p><strong>关键问题(1)</strong>如何构造初始的有序序列？</p>
<p><strong>解决方法：</strong><br>将第1个记录看成是初始有序表，然后从第2个记录起依次插入到这个有序表中，直到将第n个记录插入。所以，大循环进行n-1次插入</p>
<p><strong>关键问题(2)</strong>如何查找待插入记录的插入位置?</p>
<p><strong>解决方法：</strong><br>在i-1个记录的有序区中插入记录r[i]，首先顺序查找r[i]的正确插入位置，然后将r[i]插入到相应位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接插入排序的算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span> <span class="params">(dataList&lt;T&gt;&amp; L, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="comment">//依次将元素L.Vector[i]按其排序码插入到有序表</span></span><br><span class="line"><span class="comment">//L.Vector[left],…,L.Vector[i-1]中,使得</span></span><br><span class="line"><span class="comment">//L.Vector[left]到L.Vector[i]有序。</span></span><br><span class="line">    Element&lt;T&gt; temp;  <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = left+<span class="number">1</span>; i &lt;= right; i++)</span><br><span class="line">        <span class="keyword">if</span> (L[i] &lt; L[i<span class="number">-1</span>]) &#123;</span><br><span class="line">		temp = L[i];  j = i<span class="number">-1</span>;	</span><br><span class="line"> 		<span class="keyword">do</span> &#123;  L[j+<span class="number">1</span>] = L[j];  j--; &#125; </span><br><span class="line">		<span class="keyword">while</span> (j &gt;= left &amp;&amp; temp &lt; L[j]);</span><br><span class="line">		L[j+<span class="number">1</span>] = temp;  </span><br><span class="line">        &#125;   &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>算法分析</strong><br>设待排序元素个数为currentSize = n, 则该算法的主程序执行n-1趟。<br>排序码比较次数和元素移动次数与元素排序码的初始排列有关。</p>
<p>最好情况下，排序前元素已按排序码从小到大有序，每趟只需与前面有序元素序列的最后一个元素比较1次，总的排序码比较次数为 n-1, 元素移动次数为0。<br>最坏情况下, 第 i 趟时第 i 个元素必须与前面 i 个元素都做排序码比较, 并且每做1次比较就要做1次数据移动。则总排序码比较次数KCN和元素移动次数RMN分别为</p>
<p>KCN=n^2-2   RMN=n^2-2</p>
<p>注意到，在插入第 i（i＞1）个记录时，前面的 i-1 个记录已经排好序，则在寻找插入位置时，可以用折半（二分）查找来代替顺序查找，从而减少比较次数。</p>
<p>平均情况下排序的时间复杂度为 o(n2)。直接插入排序是一种稳定的排序方法。</p>
<h3 id="折半插入排序-Binary-Insertsort"><a href="#折半插入排序-Binary-Insertsort" class="headerlink" title="折半插入排序 (Binary Insertsort)"></a>折半插入排序 <strong>(Binary</strong> Insertsort)</h3><p><strong>基本思想是</strong> : 设在顺序表中有一 个元素序列 V[0], V[1], …, V[n-1]。其中, V[0], V[1], …, V[i-1] 是已经排好序的元素。在插入V[i] 时, 利用折半搜索法寻找V[i] 的插入位置</p>
<p>折半插入排序-关键之处：插入位置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (temp &lt; L[middle])	  <span class="comment">//插入值小于中点值</span></span><br><span class="line"></span><br><span class="line"> high = middle<span class="number">-1</span>;	  <span class="comment">//向左缩小区间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> low = middle+<span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//折半插入排序的算法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dataList.h"</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BinaryInsertSort</span> (<span class="title">dataList</span>&lt;T&gt;&amp; <span class="title">L</span>, </span></span><br><span class="line"><span class="class">       <span class="title">const</span> <span class="title">int</span> <span class="title">left</span>, <span class="title">const</span> <span class="title">int</span> <span class="title">right</span>) &#123;</span></span><br><span class="line"><span class="comment">//利用折半搜索, 在L.Vector[left]到L.Vector[i-1]中</span></span><br><span class="line"><span class="comment">//查找L.Vector[i]应插入的位置, 再进行插入。</span></span><br><span class="line">    Element&lt;T&gt; temp;  </span><br><span class="line">    <span class="keyword">int</span> i, low, high, middle, k;</span><br><span class="line">    <span class="keyword">for</span> (i = left+<span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (L[i] &lt; L[i<span class="number">-1</span>]) &#123;</span><br><span class="line">     temp = L[i];  low = left;  high = i<span class="number">-1</span>; </span><br><span class="line">     <span class="keyword">while</span> (low &lt;= high) &#123;	<span class="comment">//折半搜索插入位置</span></span><br><span class="line">    middle = (low+high)/<span class="number">2</span>;	<span class="comment">//取中点</span></span><br><span class="line"><span class="keyword">if</span> (temp &lt; L[middle])	  <span class="comment">//插入值小于中点值</span></span><br><span class="line">                high = middle<span class="number">-1</span>;	  <span class="comment">//向左缩小区间</span></span><br><span class="line">            <span class="keyword">else</span> low = middle+<span class="number">1</span>;	  <span class="comment">//否则, 向右缩小区间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (k = i<span class="number">-1</span>; k &gt;= low; k--) L[k+<span class="number">1</span>] = L[k];</span><br><span class="line">	                                          <span class="comment">//成块移动,空出插入位置</span></span><br><span class="line">	    L[low] = temp;	     <span class="comment">//插入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>算法分析</strong><br>折半搜索比顺序搜索快, 所以折半插入排序就平均性能来说比直接插入排序要快。</p>
<p>在插入第 i 个元素时，需要经过 [log(2) i] +1 次排序码比较, 才能确定它应插入的位置。因此，将 n 个元素(为推导方便, 设为 n=2k ) 用折半插入排序所进行的排序码比较次数为：n*log(2) n。</p>
<p>折半插入排序是一个稳定的排序方法。</p>
<p>折半插入排序的元素移动次数与直接插入排序相同，依赖于元素的初始排列</p>
<h3 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序 (Merge Sort)"></a>归并排序 (Merge Sort)</h3><p>归并，是将两个或两个以上的有序表合并成一个新的有序表。<br>元素序列L1中有两个有序表Vector[left..mid]和Vector[mid+1..right]。它们可归并成一个有序表, 存于另一元素序列L2的Vector[left..right] 中。这种方法称为两路归并 (2-way merging)。<br>变量 i 和 j 分别是表Vector[left..mid]和Vector [mid+1..right]的检测指针。k 是存放指针。当 i 和 j 都在两个表的表长内变化时, 根据对应项的排序码的大小,   依次把排序码小的元素排放到新表 k 所指位置中；当 i 与 j 中有一个已经超出表长时，将另一 个表中的剩余部分照抄到新表中。</p>
<p><strong>迭代的归并排序算法</strong></p>
<p>迭代的归并排序算法就是利用两路归并过程进行排序。</p>
<p><strong>其基本思想是：</strong><br>设初始元素序列有 n 个元素，首先把它看成是 n 个长度为 1 的有序子序列（归并项），做两两归并，得到 [n/2] 个长度为 2 的归并项（最后一个归并项的长度为1）；再做两两归并，得到 [n/4] 个长度为 4 的归并项（最后一个归并项长度可以短些）…，如此重复，最后得到一个长度为 n 的有序序列。</p>
<p><strong>两路归并算法</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dataList.h"</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">merge</span> (<span class="title">dataList</span>&lt;T&gt;&amp; <span class="title">L1</span>, <span class="title">dataList</span>&lt;T&gt;&amp; <span class="title">L2</span>,</span></span><br><span class="line"><span class="class">            <span class="title">const</span> <span class="title">int</span> <span class="title">left</span>, <span class="title">const</span> <span class="title">int</span> <span class="title">mid</span>, <span class="title">const</span> <span class="title">int</span> <span class="title">right</span>) &#123;</span></span><br><span class="line"><span class="comment">//L1.Vector[left..mid]与L1.Vector[mid+1..right]是两</span></span><br><span class="line"><span class="comment">//个有序表, 将这两个有序表归并成一个有序表</span></span><br><span class="line"><span class="comment">//L2.Vector[left..right]</span></span><br><span class="line">    <span class="keyword">int</span> k, i, j; </span><br><span class="line">    i = left;  j = mid+<span class="number">1</span>;  k = left;</span><br><span class="line">		<span class="comment">//s1, s2是检测指针, t是存放指针   </span></span><br><span class="line"> <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right)	   <span class="comment">//两两比较</span></span><br><span class="line">        <span class="keyword">if</span> (L1[i] &lt;= L1[j]) </span><br><span class="line">            L2[k++] = L1[i++];</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            L2[k++] = L1[j++];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) L2[k++] = L1[i++];</span><br><span class="line">		<span class="comment">//若第一个表未检测完,复制</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) L2[k++] = L1[j++];</span><br><span class="line">		<span class="comment">//若第二个表未检测完,复制</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>一趟归并排序的算法</strong></p>
<p>设L1.Vector[0..n-1]中 n 个记录已经分为一些长度为 len 的归并项，将这些归并项两两归并成长度为2len的归并项, 结果放到L2[ ]中。<br>如果n不是2len的整数倍，则一趟归并到最后，可能遇到两种情形：<br>剩下一个长度为len的归并项和另一个长度不足len的归并项,  可用merge算法将它们归并成一个长度小于 2len 的归并项。<br>只剩下一个归并项，其长度小于或等于 len, 将它直接复制到结果表中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">MergePass</span> (<span class="title">dataList</span>&lt;T&gt;&amp; <span class="title">L1</span>, <span class="title">datalist</span>&lt;T&gt;&amp; <span class="title">L2</span>, </span></span><br><span class="line"><span class="class">       <span class="title">const</span> <span class="title">int</span> <span class="title">len</span>) &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j, n = L1.Length();</span><br><span class="line">    <span class="keyword">while</span> (i+<span class="number">2</span>*len &lt;= n<span class="number">-1</span>) &#123;</span><br><span class="line">         merge (L1, L2, i, i+len<span class="number">-1</span>, i+<span class="number">2</span>*len<span class="number">-1</span>);</span><br><span class="line">         i += <span class="number">2</span> * len;                <span class="comment">//循环两两归并</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i+len &lt;= n<span class="number">-1</span>)</span><br><span class="line">        merge (L1, L2, i, i+len<span class="number">-1</span>, n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">for</span> (j = i; j &lt;= n<span class="number">-1</span>; j++) L2[j] = L1[j];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//(两路)归并排序的主算法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">MergeSort</span> (<span class="title">dataList</span>&lt;T&gt;&amp; <span class="title">L</span>) &#123;</span></span><br><span class="line"><span class="comment">//按元素排序码非递减的顺序对表L中元素排序</span></span><br><span class="line">    <span class="keyword">int</span> n = L.Length();</span><br><span class="line">    <span class="function">dataList&lt;T&gt; &amp; <span class="title">tempList</span> <span class="params">(n)</span></span>;		<span class="comment">//创建临时表</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt; n) &#123;</span><br><span class="line">        MergePass (L, tempList, len);   len *= <span class="number">2</span>;	</span><br><span class="line">	    MergePass (tempList, L, len);   len *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在迭代的归并排序算法中, 函数MergePass()做一趟两路归并排序, 要调用merge()函数    O(n/len) 次, 函数MergeSort()调用MergePass()正好[log（2）n]次，而每次merge()要执行比较O(len)次, 所以算法总的时间复杂度为O(n*log (2) n)。<br>归并排序占用附加存储较多, 需要另外一个与原待排序元素数组同样大小的辅助数组。这是这个算法的缺点。<br>归并排序是一个稳定的排序方法。</p>
<p><strong>递归归并(merge)排序</strong></p>
<p><strong>基本思想：</strong>将待排序元素分成大小大致相同的2个子集合，分别对2个子集合进行排序，最终将排好序的子集合合并成为所要求的排好序的集合。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(Type a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (left&lt;right) &#123;<span class="comment">//至少有2个元素</span></span><br><span class="line">      <span class="keyword">int</span> i=(left+right)/<span class="number">2</span>;  <span class="comment">//取中点</span></span><br><span class="line">      mergeSort(a, left, i);</span><br><span class="line">      mergeSort(a, i+<span class="number">1</span>, right);</span><br><span class="line">      merge(a, b, left, i, right);  <span class="comment">//合并到数组b</span></span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法如下</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   temlplate  &lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="class">   <span class="title">void</span> <span class="title">MergeSort</span>(<span class="title">Type</span> <span class="title">a</span>[], <span class="title">int</span> <span class="title">left</span>, <span class="title">int</span> <span class="title">right</span>)</span></span><br><span class="line"><span class="class">  &#123;</span>   <span class="keyword">if</span> (<span class="number">1</span>eft &lt; right)  <span class="comment">//至少有2个元素</span></span><br><span class="line">       <span class="keyword">int</span> i = (left + right ) /<span class="number">2</span>; <span class="comment">//取中点</span></span><br><span class="line">       MergeSort(a, <span class="number">1</span>eft, i)；</span><br><span class="line">       MergeSort(a, i+<span class="number">1</span>, right)；</span><br><span class="line">       Merge(a, b, <span class="number">1</span>eft, i, right)；<span class="comment">//从a合并到数组b</span></span><br><span class="line">&#125; &#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">//MergeSort(a, i+1, right)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">merge</span>(<span class="title">T</span> <span class="title">C</span>[], <span class="title">T</span> <span class="title">d</span>[] ,<span class="title">int</span> <span class="title">l</span>, <span class="title">int</span> <span class="title">m</span> , <span class="title">int</span> <span class="title">r</span>)</span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">//把c[l:m],c[m+1,r]归并到d[l,r]</span></span><br><span class="line">    <span class="keyword">int</span>: i=l,  <span class="comment">//第—段的游标</span></span><br><span class="line">           j=m+<span class="number">1</span>, <span class="comment">//第二段的游标</span></span><br><span class="line">           k=l;     <span class="comment">//结果的游标</span></span><br><span class="line">  <span class="comment">//只要段中存在i和j,则不断进行归并</span></span><br><span class="line"> <span class="keyword">while</span> ((i&lt;=m)&amp;&amp;(j&lt;=r))</span><br><span class="line">    <span class="keyword">if</span> c[i]&lt;=c[j]   d[k++]=C[i++]：</span><br><span class="line">    <span class="keyword">else</span> d[k++]=C[j++]：</span><br><span class="line"> <span class="comment">//考虑余下的部分</span></span><br><span class="line"> <span class="keyword">if</span> (i&gt;m)  <span class="keyword">for</span> (<span class="keyword">int</span> q=j; q&lt;=r;q++)</span><br><span class="line">                   d[k++]=c[q]；</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">int</span> q=i ;q&lt;=m；q++)</span><br><span class="line">            d[k++]=c[q]；&#125;</span><br></pre></td></tr></table></figure>

<p><strong>T(n)=a*(nlog n)</strong></p>
<p><strong>递归的链表归并排序</strong></p>
<p>与快速排序类似，归并排序也可以利用划分为子序列的方法递归实现。<br><strong>算法的思路是：</strong></p>
<p>首先把整个待排序序列划分为两个长度大致相等的部分，分别称之为左子表和右子表。对这些子表分别递归地进行排序，然后再把排好序的两个子表进行归并。<br>图示：待排序元素序列的排序码为 { 21, 25, 49, 25*,16, 08 }，先是进行子表划分，待到子表中只有一个元素时递归到底。再实施归并，逐步退出递归调用的过程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态链表的两路归并算法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"staticList.h"</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">ListMerge</span> (<span class="title">staticLinkedList</span>&lt;T&gt;&amp; <span class="title">L</span>, <span class="title">int</span> <span class="title">s1</span>, <span class="title">int</span> <span class="title">s2</span>) &#123;</span></span><br><span class="line"><span class="comment">//两个有序链表中第一个结点的下标分别为s1和s2</span></span><br><span class="line"><span class="comment">//将它们归并, 得到一个有序链表, 并返回其第一个</span></span><br><span class="line"><span class="comment">//结点的下标。L[0]是工作单元。</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>,  i = s1,  j = s2; </span><br><span class="line">    <span class="keyword">while</span> (i != <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>)		<span class="comment">//做两两比较</span></span><br><span class="line">        <span class="keyword">if</span> (L[i].key &lt;= L.[j].key)		<span class="comment">//i所指排序码小</span></span><br><span class="line">         &#123; L[k].link = i;  k = i;  i = L[i].link; &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            &#123; L[k].link = j;  k = j;  j = L[j].link; &#125;</span><br><span class="line">	    <span class="keyword">if</span> (i == <span class="number">0</span>) L[k].link = j;	<span class="comment">//i链检测完, j链接上</span></span><br><span class="line">	    <span class="keyword">else</span> L[k].link = i;		<span class="comment">//j链检测完, i链接上</span></span><br><span class="line">	    <span class="keyword">return</span> L[<span class="number">0</span>].link;		<span class="comment">//返回结果链头指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>递归的归并排序算法</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">rMergeSort</span> (<span class="title">staticLinkedlist</span>&lt;T&gt;&amp; <span class="title">L</span>,</span></span><br><span class="line"><span class="class">       <span class="title">const</span> <span class="title">int</span> <span class="title">left</span>, <span class="title">const</span> <span class="title">int</span> <span class="title">right</span>) &#123;</span></span><br><span class="line"><span class="comment">//对链表L.Vector[left..right]进行排序。各个结点中</span></span><br><span class="line"><span class="comment">//的链域link应初始化为0，rMergeSort返回排序后</span></span><br><span class="line"><span class="comment">//链表第一个结点的下标，L.Vector[0]是工作单元</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> ListMerge (L, rMergeSort (L,left, mid),</span><br><span class="line">             rMegerSort (L, mid+<span class="number">1</span>,right));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>链表的归并排序方法的递归深度为O(log2n)，元素排序码的比较次数为O(nlog2n)。<br>链表的归并排序方法是一种稳定的排序方法。</p>
<h3 id="链表插入排序"><a href="#链表插入排序" class="headerlink" title="链表插入排序"></a>链表插入排序</h3><p> <strong>基本思想是：</strong>在每个元素的结点中增加一个链接指针数据成员 link。<br> 对于数组中的一组元素V[1], …, V[n], 若V[1], …<br>    …, V[i-1]已经通过指针link,  按其排序码从小到大链接起来。现要插入V[i], i = 2, 3, …, n,  则必须在前面 i-1 个链接起来的元素当中，循链检测比较，找到V[i] 应插入的位置，把V[i] 链入，并修改相应链接指针。从而得到V[1], …, V[i]的一个通过指针排好的链表。<br> 如此重复执行，直到把V[n]也插入到链表中排好序为止。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于链表排序的静态链表的类定义</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> DefaultSize = <span class="number">10</span>;	<span class="comment">//在staticList.h文件中 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">Element</span> &#123;</span>			<span class="comment">//静态链表元素类定义</span></span><br><span class="line">    T key;				<span class="comment">//排序码，其它信息略</span></span><br><span class="line">    <span class="keyword">int</span> link;				<span class="comment">//结点的链接指针</span></span><br><span class="line">	Element () : link(<span class="number">0</span>) &#123; &#125; 	<span class="comment">//构造函数</span></span><br><span class="line">	Element (T x, <span class="keyword">int</span> next = <span class="number">0</span>) : key(x), link(next) &#123; &#125;</span><br><span class="line">						<span class="comment">//构造函数	</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">staticLinkedList</span> &#123;</span>		<span class="comment">//静态链表的类定义</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	staticLinkedList (<span class="keyword">int</span> sz = DefaultSize) &#123;</span><br><span class="line">        maxSize = sz;  n = <span class="number">0</span>; </span><br><span class="line">        Vector = <span class="keyword">new</span> Element&lt;T&gt;[sz];</span><br><span class="line">    &#125;</span><br><span class="line">	Element&lt;T&gt;&amp; <span class="keyword">operator</span> [](<span class="keyword">int</span> i) &#123;<span class="keyword">return</span> Vector[i];&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Element&lt;T&gt; *Vector;		<span class="comment">//存储元素的向量</span></span><br><span class="line">	<span class="keyword">int</span> maxSize;	     		<span class="comment">//最大元素个数</span></span><br><span class="line">    <span class="keyword">int</span> n;				<span class="comment">//当前元素个数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//链表插入排序的算法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"staticList.h"</span></span></span><br><span class="line"><span class="keyword">const</span> T maxData;		<span class="comment">//排序码集合中的最大值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">insertSort</span> (<span class="title">staticLinkedList</span>&lt;T&gt;&amp; <span class="title">L</span>) &#123;</span></span><br><span class="line"><span class="comment">//对L.Vector[1],...,L.Vector[n]按其排序码key排序,</span></span><br><span class="line"><span class="comment">//L.Vector[0] 做为排序后各个元素所构成的有序循</span></span><br><span class="line"><span class="comment">//环链表的附加头结点使用</span></span><br><span class="line">    L[<span class="number">0</span>].key = maxData;   </span><br><span class="line">    L[<span class="number">0</span>].link = <span class="number">1</span>;   L[<span class="number">1</span>].link = <span class="number">0</span>;</span><br><span class="line">				<span class="comment">//形成只有一个元素的循环链表</span></span><br><span class="line"><span class="keyword">int</span> i, pre, p;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++) &#123;	</span><br><span class="line">		<span class="comment">//每趟向有序链表中插入一个结点</span></span><br><span class="line">        p = L[<span class="number">0</span>].link;			<span class="comment">//p是链表检测指针</span></span><br><span class="line">        pre = <span class="number">0</span>;			<span class="comment">//pre指向p的前驱</span></span><br><span class="line">        <span class="keyword">while</span> (L[p].key &lt;= L[i].key)    <span class="comment">//循链找插入位置</span></span><br><span class="line">            &#123; pre = p;  p = L[p].link; &#125;</span><br><span class="line">        L[i].link = p;  L[pre].link = i;   <span class="comment">//结点i链入</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>算法分析</strong><br>使用链表插入排序, 每插入一个元素, 最大排序码比较次数等于链表中已排好序的元素个数, 最小排序码比较次数为1。故总的排序码比较次数最小为 n-1，最大为n*(n-1)/2</p>
<p>用链表插入排序时，元素移动次数为0。但为了实现链表插入，在每个元素中增加了一个链域 link，并使用了Vector[0] 作为链表的表头结点,  用了 n 个附加域和一个附加元素。</p>
<p>算法在Vector[pre].key == Vector[i].key时，将Vector[i]插在Vector[pre]的后面，所以，链表插入排序方法是稳定的。</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p><strong>基本思想：</strong>将整个待排序记录分割成若干个子序列，在子序列内分别进行直接插入排序，待整个序列中的记录基本有序时，对全体记录进行直接插入排序。</p>
<p>分割待排序记录的目的?</p>
<ol>
<li>减少待排序记录个数；</li>
<li>使整个序列向基本有序发展</li>
</ol>
<p>子序列的构成不能是简单地“逐段分割”，而是将相距某个“增量”的记录组成一个子序列。</p>
<p><strong>子序列划分方法</strong><br> 1、将排序序列分为gap个组，各组内进行直接排序。<br>将全部元素分为 gap 个子序列，所有距离为 gap 的元素放<br>在同一个子序列中。<br> 2、然后缩小间隔 gap, 重复上述工作。直到最后取 gap == 1，<br>算法最后一步将所有元素放在同一个序列中排序为止。</p>
<p><strong>关键问题(1)</strong>应如何分割待排序记录？</p>
<p><strong>解决方法：</strong><br>将相隔某个“增量”的记录组成一个子序列。<br>增量应如何取？<br>Gap的取法有多种。希尔最早提出的方法是gap1= [n/2 ] ，gap= [gap/2 ],直到gap = 1 。knuth 提出取 gap = [gap/3]+1。还有人提出都取奇数为好，也有人提出各 gap 互质为好</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//算法描述：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> gap=n/<span class="number">2</span>; gap&gt;=<span class="number">1</span>; gap=gap/<span class="number">2</span>) </span><br><span class="line">&#123;  以gap为增量，进行组内直接插入排序；&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键问题(2)</strong>子序列内如何进行直接插入排序？</p>
<p><strong>解决方法：</strong><br>在插入记录r[i]时，自r[i-gap]起往前跳跃式（跳跃幅度为gap）搜索待插入位置。<br>在搜索过程中，记录后移也是跳跃gap个位置。<br>在整个序列中，前gap个记录分别是gap个子序列中的第一个记录，所以从第gap+1个记录开始进行插入。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//希尔排序的算法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shellsort</span> <span class="params">(dataList&lt;T&gt;&amp; L, <span class="keyword">const</span> <span class="keyword">int</span> left, <span class="keyword">const</span> <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"> </span>&#123; <span class="keyword">int</span> i, j, gap = right-left+<span class="number">1</span>; <span class="comment">//增量的初始值为待排序个数</span></span><br><span class="line">	Element&lt;T&gt; temp;</span><br><span class="line">    <span class="keyword">do</span> &#123;  	gap = gap/<span class="number">3</span>+<span class="number">1</span>;			<span class="comment">//求下一增量值</span></span><br><span class="line">        		<span class="keyword">for</span> (i = left+gap; i &lt;= right; i++)</span><br><span class="line">           	 	<span class="keyword">if</span> (L[i] &lt; L[i-gap]) &#123;		<span class="comment">//逆序</span></span><br><span class="line">                			temp = L[i];  j = i-gap;</span><br><span class="line">                			<span class="keyword">do</span> &#123;</span><br><span class="line">                   				 L[j+gap] = L[j];  j = j-gap;</span><br><span class="line">                			&#125; <span class="keyword">while</span> (j &gt;= left &amp;&amp; temp &lt; L[j]);</span><br><span class="line">               			L[j+gap] = temp;	<span class="comment">//将vector[i]回送</span></span><br><span class="line">           		&#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (gap &gt; <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//for循环里gap换成1得到直接插入的代码</span></span><br></pre></td></tr></table></figure>

<p><strong>算法分析</strong></p>
<p>想要弄清排序码比较次数和元素移动次数与增量选择之间的依赖关系，并给出完整的数学分析，还没有人能够做到。<br>Knuth利用大量实验统计资料得出 : 当 n 很大时，排序码平均比较次数和元素平均移动次数大约在 n^1.25 到 1.6*n^1.25 的范围内。这是在利用直接插入排序作为子序列排序方法的情况下得到的。<br>希尔排序是一种不稳定的排序方法。</p>
<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><p>交换排序的主要操作是交换，其主要思想是：在待排序列中选两个记录，将它们的关键码相比较，如果反序（即排列顺序与排序后的次序正好相反），则交换它们的存储位置</p>
<p>交换排序的主要算法有：</p>
<p>  1)  起泡排序<br>  2)  快速排序</p>
<h3 id="起泡排序-Bubble-Sort"><a href="#起泡排序-Bubble-Sort" class="headerlink" title="起泡排序(Bubble Sort)"></a>起泡排序(Bubble Sort)</h3><p><strong>基本思想：</strong>两两比较相邻记录的关键码，如果反序则交换，直到没有反序的记录为止。<br>优点：每趟结束时，不仅能挤出一个最小（大）值到最前（后）面位置，还能同时部分理顺其他元素；一旦下趟没有交换发生，还可以提前结束排序。 </p>
<p><strong>基本方法是</strong>：设待排序元素序列中的元素个数为 n。顺次两两比较V[j-1].key和V[j].key。如果发生逆序，则交换V[j-1]和V[j]。</p>
<p>第一趟：比较A[n-2]和A[n-1],如果A[n-2]大，则交换它两。然后再比较现在的A[n-3]和A[n-2],一直到A[0]和A[1].经过第一趟，最小的值冒到了最后A[0]</p>
<p>第二趟：对A[1]~A[n-1]做同样的操作，第二趟结束时，整个序列的第二小元素冒到了A[1]<br>……<br>第n-1趟，比较A[n-2]和A[n-1]。</p>
<p>其实，在某一趟比较过程中，如果没有发生过交换，则本趟完成即可结束排序算法。所以用exchange记录是否发生过交换，如果没发生过则提前退出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//起泡排序的算法</span></span><br><span class="line">type  <span class="keyword">int</span> T;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span> <span class="params">(T V[], <span class="keyword">int</span> n )</span> </span>&#123;</span><br><span class="line">   <span class="keyword">bool</span> exchange ;   <span class="keyword">int</span> i , j ;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n ; i++)&#123;</span><br><span class="line">	exchange = <span class="literal">false</span>;		    	<span class="comment">//标志为0假定未交换</span></span><br><span class="line">	<span class="keyword">for</span> ( j = n<span class="number">-1</span>;  j &gt;= i;  j--)     </span><br><span class="line"> 		<span class="keyword">if</span> (V[j<span class="number">-1</span>] &gt; V[j]) &#123; 	<span class="comment">//逆序</span></span><br><span class="line">                T temp=V[j<span class="number">-1</span>];  V[j<span class="number">-1</span>]=V[j]; V[j]=temp<span class="comment">//交换</span></span><br><span class="line">	            exchange = <span class="literal">true</span>;      <span class="comment">//标志置为1,有交换</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">if</span>(exchange==<span class="literal">false</span>) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>起泡排序需要一个附加元素以实现元素值的对换。起泡排序是一个稳定的排序方法。</p>
<p><strong>算法分析</strong><br>第i趟对待排序元素序列V[i-1],V[i],,V[n-1]进行排序，结果将该序列中排序码最小的元素交换到序列的第一个位置(i-1)。</p>
<p>最多做n-1趟起泡就能把所有元素排好序。<br>在元素的初始已经按升序排好序时，此算法只执行n-1次排序码比较，不移动。这是最好的情形。</p>
<p>最坏的情形是算法执行n-1趟起泡,第i趟 (1≤ in) 做n-i次排序码比较, 执行n-i次元素交换。在最坏情形下总的排序码比较次数KCN和元素移动次数RMN为：</p>
<p>KCN= 1/2  * n(n-1)       RMN=3/2  *n(n-1)</p>
<h3 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序 (Quick Sort)"></a>快速排序 (Quick Sort)</h3><p><strong>基本思想：</strong></p>
<p>对于输入a[ p: r ]，按以下步骤进行排序：<br>(1)分解:取a中的一个元素为支点(pivot) 将a[p: r ]划分成3段::<br>     a[p: q-1],  a[q ],  a[ q+1:r],  使得<br>      a[ p:q-1]中任一元素a[q],<br>      a[q+1: r]中任一元素 a[q]; 下标q 在划分过程中确定。<br>(2)递归求解:递归调用快速排序法分别对a[p:q-1]和a[q+1:r ]排序。直到每个子表的元素只剩一个或0个。此时便为有序序列了。</p>
<p>优点：因为每趟可以确定不止一个元素的位置，而且呈指数增加，所以特别快！<br>前提：顺序存储结构 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速排序的算法</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dataList.h"</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">QuickSort</span> (<span class="title">dataList</span>&lt;T&gt;&amp; <span class="title">L</span>,  <span class="title">int</span> <span class="title">left</span>,  <span class="title">int</span> <span class="title">right</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//对Vector[left..right]进行排</span></span><br><span class="line"><span class="keyword">if</span> (left &lt; right) &#123;		<span class="comment">//元素序列长度大于1时</span></span><br><span class="line">        <span class="keyword">int</span> pivotpos = L.Partition (left, right);    <span class="comment">//划分</span></span><br><span class="line">        QuickSort (L, left, pivotpos<span class="number">-1</span>);</span><br><span class="line">        QuickSort (L, pivotpos+<span class="number">1</span>, right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p><strong>关键问题⑴：</strong>如何选择轴值？</p>
<p>选择轴值的方法：<br>1.使用第一个记录的关键码；<br>2.选取序列中间记录的关键码；<br>3.比较序列中第一个记录、最后一个记录和中间记录的关键码，取关键码居中的作为轴值并调换到第一个记录的位置；<br>4.随机选取轴值。</p>
<p>选取不同轴值的后果：<br>决定两个子序列的长度，子序列的长度最好相等。</p>
<p><strong>关键问题⑵：</strong>如何实现一次划分？</p>
<p>方法1：当基准点为第一个元素时，执行一次循环，关键码小于基准点的左移，关键码大于基准点的右移</p>
<p>方法2：是采用从两头向中间交替式逼近法；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">dataList</span>&lt;T&gt;:</span>:Partition (<span class="keyword">const</span> <span class="keyword">int</span> low, <span class="keyword">const</span> <span class="keyword">int</span> high) &#123;</span><br><span class="line"><span class="comment">//数据表类的共有函数</span></span><br><span class="line">    <span class="keyword">int</span> pivotpos = low;</span><br><span class="line">    Element&lt;T&gt; pivot = Vector[low];<span class="comment">//基准元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = low+<span class="number">1</span>; i &lt;= high; i++)</span><br><span class="line"> 			                <span class="comment">//检测整个序列, 进行划分</span></span><br><span class="line">      <span class="keyword">if</span> (Vector[i] &lt; pivot) &#123;</span><br><span class="line">            pivotpos++;</span><br><span class="line">            <span class="keyword">if</span> (pivotpos != i)   </span><br><span class="line">                Swap(Vector[pivotpos],Vector[i]);</span><br><span class="line">        &#125;				<span class="comment">//小于基准的交换到左侧去</span></span><br><span class="line">    Vector[low] = Vector[pivotpos];</span><br><span class="line">    Vector[pivotpos] = pivot;								<span class="comment">//将基准元素就位	</span></span><br><span class="line">    <span class="keyword">return</span> pivotpos;	<span class="comment">//返回基准元素位置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参考代码：一趟划分过程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">( SqList &amp;L,  <span class="keyword">int</span> low,  <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    L.r[<span class="number">0</span>] = L.r[low];</span><br><span class="line">    pivitkey = L.r[low].key;</span><br><span class="line">    <span class="keyword">while</span>( low &lt; high)&#123;</span><br><span class="line">         <span class="keyword">while</span>( low &lt; high &amp;&amp; L.r[high].key &gt;= pivotkey)  --high;</span><br><span class="line">         L.r[low] = L.r[high];</span><br><span class="line">         <span class="keyword">while</span>( low &lt; high &amp;&amp; L.r[low].key &lt;= pivotkey)  ++low;</span><br><span class="line">         L.r[high] = L.r[low];</span><br><span class="line">    &#125;</span><br><span class="line">    L.r[low] = L.r[<span class="number">0</span>];   </span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>快速排序的时间性能分析</strong></p>
<p>快速排序的递归执行过程可以用递归树描述。快速排序的趟数取决于递归树的高度。</p>
<p>最好情况：<br>每一次划分对一个记录定位后，该记录的左侧子表与右侧子表的长度相同，为O(nlog (2) n)。</p>
<p>最坏情况：<br>每次划分只得到一个比上一次划分少一个记录的子序列（另一个子序列为空），为 O(n^2)。</p>
<p>平均情况：为O(nlog (2) n)。</p>
<p>可以证明，函数quicksort的平均计算时间也是O(nlog2n)。实验结果表明: 就平均计算时间而言，快速排序是内排序方法中最好的一个。</p>
<p>快速排序是递归的，需要有一个栈存放每层递归调用时的指针和参数。</p>
<p>最坏情况下其排序速度退化到简单排序的水平, 比直接插入排序还慢。占用附加存储(栈)将达到O(n)。<br>改进办法: 取每个待排序元素序列的第一个元素、最后一个元素和位置接近正中的 3 个元素，取其排序码居中者作为基准元素。</p>
<p>快速排序是一种不稳定的排序方法。<br>对于 n 较大的平均情况而言, 快速排序是“快速”的, 但是当 n 很小时, 这种排序方法往往比其它简单排序方法还要慢。快速排序不适合对小规模的序列进行排序。</p>
<h3 id="选择排序-Select-Sort"><a href="#选择排序-Select-Sort" class="headerlink" title="选择排序(Select Sort)"></a>选择排序(Select Sort)</h3><p><strong>基本思想是</strong>: 每一趟 (例如第 i 趟, i = 0, 1, …, n-2) 在后面 n-i 个待排序元素中选出排序码最小的元素，作为有序元素序列的第 i 个元素。待到第 n-2 趟作完，待排序元素只剩下1个,  就不用再选了。</p>
<p><strong>直接选择排序的基本步骤是：</strong><br>1 在一组元素 V[i]～V[n-1] 中选择具有最小排序码的元素；<br>2 若它不是这组元素中的第一个元素, 则将它与这组元素中的第一个元素对调;<br>3 在这组元素中剔除这个具有最小排序码的元素。在剩下的元素V[i+1] ～ V[n-1]中重复执行第1、2步, 直到剩余元素只有一个为止。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接选择排序的算法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dataList.h"</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">SelectSort</span> (<span class="title">dataList</span>&lt;T&gt;&amp; <span class="title">L</span>, </span></span><br><span class="line"><span class="class">          <span class="title">const</span> <span class="title">int</span> <span class="title">left</span>, <span class="title">const</span> <span class="title">int</span> <span class="title">right</span>) &#123;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = i;        <span class="comment">//在L[i]到L[n-1]找最小排序码元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>;  j &lt;= right;  j++) </span><br><span class="line">            <span class="keyword">if</span> (L[j] &lt; L[k]) k = j;</span><br><span class="line">        <span class="keyword">if</span> (k != i) Swap (L[i], L[k]);	<span class="comment">//交换 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>直接选择排序的排序码比较次数 KCN 与元素的初始排列无关。<br>设有 n 个元素，则第 i 趟从n-i个记录中挑选最小元素所需的比较次数总是 n-i-1 次。<br>总的排序码比较次数为 n(n-1)/2</p>
<p>元素移动次数与元素序列初始排列有关。正序最少RMN = 0。反序为 RMN = 3(n-1)</p>
<p>直接选择排序是一种不稳定的排序方法</p>
<p><strong>链表直接选择排序</strong></p>
<p>若待排序的数据元素顺序存放于单链表中，每一趟排序先在链表中选择关键码值最大的元素，将它从链中摘下，再插入一个初始为空的新链表的首部。<br>当所有元素都从原链表中摘下并插入到新链表中，则新链表中元素已经有序链接起来。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表直接选择排序的算法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"staticList.h"</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">selectSort</span> (<span class="title">staticLinkedList</span>&lt;T&gt;&amp; <span class="title">L</span>) &#123;</span></span><br><span class="line"><span class="comment">//L.Vector[0]作为表头结点使用，L.Vector[1].data</span></span><br><span class="line"><span class="comment">//到L.Vector[n].data存放数据</span></span><br><span class="line">    <span class="keyword">int</span> f = L[<span class="number">0</span>].link, p, q, r, s;  </span><br><span class="line">    L[<span class="number">0</span>].link = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (f != <span class="number">0</span>) &#123;     		<span class="comment">//原始链表未扫描完</span></span><br><span class="line">        p = s = f;  q = r = <span class="number">0</span>;		<span class="comment">//s指示当前最大元素</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L[p].data &gt; L[s].data ) &#123; s = p;  r = q; &#125;</span><br><span class="line">                <span class="comment">//记忆当前找到的排序码最大结点</span></span><br><span class="line">          q = p;  p = L[p].link;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">if</span> (s == f ) f = L[f].link; 	    <span class="comment">//结点s从链中摘下</span></span><br><span class="line">        <span class="keyword">else</span> L[r].link = L[s].link;</span><br><span class="line">        L[s].link = L[<span class="number">0</span>].link;</span><br><span class="line">        L[<span class="number">0</span>].link = s;</span><br><span class="line">	     <span class="comment">//结点s插入到结果链表的前端</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="堆排序-Heap-Sort"><a href="#堆排序-Heap-Sort" class="headerlink" title="堆排序 (Heap Sort)"></a>堆排序 (Heap Sort)</h2><p>利用堆及其运算, 可以很容易地实现选择排序的思路。<br><strong>堆排序分为两个步骤</strong><br>根据初始输入数据，利用堆的调整算法  siftDown( ) 形成初始堆;  通过一系列的元素交换和重新调整堆进行排序。<br>为了实现元素按排序码从小到大排序，要求建立最大堆。 </p>
<p>大根堆：对应的完全二叉树中，任意一个节点的关键字都大于或等于它的孩子节点的关键字。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最大堆的向下调整算法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">siftDown</span> (<span class="title">dataList</span>&lt;T&gt;&amp; <span class="title">L</span>, <span class="title">const</span> <span class="title">int</span> <span class="title">start</span>, <span class="title">const</span> <span class="title">int</span> <span class="title">m</span>)&#123;</span></span><br><span class="line"><span class="comment">//私有函数: 从结点start开始到m自上向下比较, </span></span><br><span class="line"><span class="comment">//如果子女的值大于双亲的值, 则相互交换, 将一</span></span><br><span class="line"><span class="comment">//个集合局部调整为最大堆。</span></span><br><span class="line">    <span class="keyword">int</span> i = start;  <span class="keyword">int</span> j = <span class="number">2</span>*i+<span class="number">1</span>;	 <span class="comment">//j是i的左子女</span></span><br><span class="line">	Element&lt;T&gt; temp = L[i];	 <span class="comment">//暂存子树根结点</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= m) &#123;		   	 <span class="comment">//逐层比较</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; m &amp;&amp; L[j] &lt; L[j+<span class="number">1</span>]) j++;</span><br><span class="line"> 					  <span class="comment">//让j指向两子女中的大者</span></span><br><span class="line">	    <span class="keyword">if</span> (temp &gt;= L[j]) <span class="keyword">break</span>;	 <span class="comment">//temp排序码大不调整</span></span><br><span class="line">        <span class="keyword">else</span> &#123;			    <span class="comment">//否则子女中的大者上移</span></span><br><span class="line">            L[i] = L[j];</span><br><span class="line">		  i = j;  j = <span class="number">2</span>*j+<span class="number">1</span>;  	    <span class="comment">//i下降到子女位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	L[i] = temp;		    <span class="comment">//temp放到合适位置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>基于初始堆进行堆排序</strong></p>
<p>最大堆堆顶具有最大值，将L.Vector[0]与L.Vector[n-1]对调,<br>再对前面的n-1个元素,  使用堆的调整算法siftDown(L, 0, n-2)，重新建立最大堆。<br>依次对调L.Vector[0]和L.Vector[n-2]，再调用siftDown(L, 0, n-3), 对前面的n-2个元素重新调整…。<br>如此反复执行，最后得到全部排序好的元素序列。这个算法即堆排序算法。</p>
<p><strong>堆排序的算法</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">HeapSort</span> (<span class="title">dataList</span>&lt;T&gt;&amp; <span class="title">L</span>) &#123;</span></span><br><span class="line"><span class="comment">//对表L.Vector[0]到L.Vector[n-1]进行排序, 使得表</span></span><br><span class="line"><span class="comment">//中各个元素按其排序码非递减有序</span></span><br><span class="line">    <span class="keyword">int</span> i, n = L.length();</span><br><span class="line">    <span class="keyword">for</span> (i = (n<span class="number">-2</span>)/<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) 	<span class="comment">//将表转换为堆</span></span><br><span class="line">        siftDown (L, i, n<span class="number">-1</span>);	</span><br><span class="line">    <span class="keyword">for</span> (i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;		<span class="comment">//对表排序</span></span><br><span class="line">        L.Swap(<span class="number">0</span>, i);  siftDown (L, <span class="number">0</span>, i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>堆排序分析</strong></p>
<p>对高度为h的堆，一次“筛选”所需进行的关键字比较的次数至多为2(h-1)。<br>对n个关键字，建成高度为h=[  log(2) n     +1] 的堆，所需关键字比较次数不超过4n<br>调整“堆顶”n-1 次，总共进行的关键字比较的次数不超过：2n*([log (2)  n])</p>
<p>因此，堆排序的时间复杂度为O(nlogn)。<br>空间复杂度为O(1)，不稳定。</p>
<p><strong>数据结构经典算法启示</strong></p>
<p>在操作系统中，将多个进程放在一个队列中，每个进程有一个优先级，总是出队优先级最高的进程执行。<br>采用优先队列，用堆来实现！</p>
<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200617103125269-21472180.png" alt=""></p>
<p>锦标赛排序、基数排序没整理。以后用到了再说.</p>
]]></content>
      <categories>
        <category>课内学习</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构笔记（第三章）</title>
    <url>/2021/05/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h2 id="第三章：线性结构之栈和队列"><a href="#第三章：线性结构之栈和队列" class="headerlink" title="第三章：线性结构之栈和队列"></a>第三章：线性结构之栈和队列</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>1.栈的定义：只允许在一端插入和删除 的线性表。 允许插入和删除的一端称为栈顶 (top)，另一端称栈底(bottom) 。</p>
<p>2.栈的特点：后进先出 (LIFO) 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//栈的抽象数据类型 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;   //此程序放入<span class="title">stack</span>.<span class="title">h</span>  </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Stack</span> &#123;</span>            <span class="comment">//栈的类定义 </span></span><br><span class="line"><span class="keyword">public</span>:      </span><br><span class="line">Stack( )&#123; &#125;;                <span class="comment">//构造函数      </span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Push</span><span class="params">(T&amp; x)</span> </span>= <span class="number">0</span>;                <span class="comment">//进栈      </span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(T&amp; x)</span> </span>= <span class="number">0</span>;           <span class="comment">//出栈      </span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">getTop</span><span class="params">(T&amp; x)</span><span class="keyword">const</span> </span>= <span class="number">0</span>; <span class="comment">//取栈顶      </span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">( )</span> <span class="keyword">const</span></span>= <span class="number">0</span>;      <span class="comment">//判栈空      </span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsFull</span><span class="params">( )</span> <span class="keyword">const</span></span>= <span class="number">0</span>;         <span class="comment">//判栈满       </span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">( )</span><span class="keyword">const</span> </span>=<span class="number">0</span>; </span><br><span class="line">&#125;； 栈</span><br></pre></td></tr></table></figure>

<h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><p> 基于数组的存储表示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//栈的数组存储表示 — 顺序栈 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;                            //P89程序3.2 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> “stack.h”                  <span class="comment">//P88栈的类定义 </span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> stackIncrement=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SeqStack</span> :</span> <span class="keyword">public</span> Stack&lt;T&gt; &#123;     <span class="comment">//顺序栈类定义 </span></span><br><span class="line"><span class="keyword">private</span>:           </span><br><span class="line">T *elements;          <span class="comment">//栈元素存放数组      </span></span><br><span class="line"><span class="keyword">int</span> top;                        <span class="comment">//栈顶指针      </span></span><br><span class="line"><span class="keyword">int</span> maxSize;                                 <span class="comment">//栈最大容量      </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">overflowProcess</span><span class="params">()</span></span>;             <span class="comment">//栈的溢出处理 </span></span><br><span class="line"><span class="keyword">public</span>:      </span><br><span class="line">SeqStack(<span class="keyword">int</span> sz =<span class="number">50</span>);                <span class="comment">//构造函数      </span></span><br><span class="line">～SeqStack() &#123; <span class="keyword">delete</span> []elements; &#125;   <span class="comment">//析构函数      </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span>;       </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(T&amp; x)</span></span>;                        <span class="comment">//出栈      </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">getTop</span><span class="params">(T&amp; x)</span></span>;             <span class="comment">//取栈顶内容      </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> top == <span class="number">-1</span>; &#125;      </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsFull</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> top == maxSize<span class="number">-1</span>; &#125;     </span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">getSize</span><span class="params">( )</span><span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> top+<span class="number">1</span> ; &#125;    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeEmpty</span><span class="params">( )</span></span>&#123;top=<span class="number">-1</span> ; &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序栈的操作</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">SeqStack</span>&lt;T&gt;:</span>:overflowProcess() &#123;   </span><br><span class="line"><span class="comment">//私有函数：当栈满则执行扩充栈存储空间处理  </span></span><br><span class="line">T *newArray = <span class="keyword">new</span> T[maxSize+stackIncrement];         <span class="comment">//创建更大的存储数 </span></span><br><span class="line"><span class="keyword">if</span>(newArray==<span class="literal">NULL</span>)&#123;<span class="built_in">cerr</span>&lt;&lt;“失败”&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>); &#125;  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= top; i++)           </span><br><span class="line">newArray[i] = elements[i];   </span><br><span class="line">maxSize += stackIncrement ;        </span><br><span class="line"><span class="keyword">delete</span> [ ]elements;       </span><br><span class="line">elements = newArray;     <span class="comment">//改变elements指针 </span></span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">SeqStack</span>&lt;T&gt;:</span>:Push(<span class="keyword">const</span> T&amp; x) &#123;    </span><br><span class="line"><span class="comment">//若栈不满, 则将元素x插入该栈栈顶, 否则溢出处理    </span></span><br><span class="line"><span class="keyword">if</span> (IsFull() == <span class="literal">true</span>) overflowProcess();       <span class="comment">//栈满    </span></span><br><span class="line">elements[++top] = x;                             <span class="comment">//栈顶指针先加1, 再进栈</span></span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">SeqStack</span>&lt;T&gt;:</span>:Pop(T&amp; x) &#123; </span><br><span class="line"><span class="comment">//函数退出栈顶元素并返回栈顶元素的值    </span></span><br><span class="line"><span class="keyword">if</span> (IsEmpty() == <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">false</span>;   </span><br><span class="line">x = elements[top--];<span class="comment">//先取值，然后栈顶指针减1       </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;                              <span class="comment">//退栈成功 </span></span><br><span class="line">&#125;;   </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">SeqStack</span>&lt;T&gt;:</span>:getTop(T&amp; x) &#123; <span class="comment">//若栈不空则函数返回该栈栈顶元素的地址   </span></span><br><span class="line"><span class="keyword">if</span> (IsEmpty() == <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">x = elements[top];     </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>双栈共享一个栈空间</strong> </p>
<p> 两个栈共享一个数组空间V[maxSize] </p>
<p> 设立栈顶指针数组 t[2] 和栈底指针数组 b[2]  </p>
<p>​    t[i]和b[i]分别指示第 i 个栈的栈顶与栈底 </p>
<p> 初始 t[0] = b[0] = -1,   t[1] = b[1] = maxSize   </p>
<p> 栈满条件：t[0]+1 == t[1]           //栈顶指针相遇 </p>
<p> 栈空条件：t[0] = b[0]或t[1] = b[1]  //退到栈底 </p>
<h4 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h4><p>基于链表的存储表示</p>
<p>链式栈不需要附加头结点，因为栈是特殊的线性表，只能在栈顶（即链表头部）插入或删除，所以 不需要附加头结点。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链式栈 (LinkedStack)类的定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">LinkedStack</span> :</span> <span class="keyword">public</span> Stack&lt;T&gt; &#123; <span class="comment">//链式栈类定义    </span></span><br><span class="line"><span class="keyword">private</span>:   LinkNode&lt;T&gt; *top;                         <span class="comment">//栈顶指针   </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(ostream&amp; os, StackNode &lt;T&gt; *ptr)</span></span>; <span class="comment">//递归输出栈的所有元素 </span></span><br><span class="line"><span class="keyword">public</span>:      </span><br><span class="line">LinkedStack( ) : top(<span class="literal">NULL</span>) &#123; &#125;               <span class="comment">//构造函数;说明链式栈无无附加头结点 </span></span><br><span class="line">~LinkedStack( ) &#123; makeEmpty( ); &#125;           <span class="comment">//析构函数   </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(T x)</span></span>;                   <span class="comment">//进栈      </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(T&amp; x)</span></span>;                 <span class="comment">//退栈      </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">getTop</span><span class="params">(T&amp; x)</span> <span class="keyword">const</span></span>;             <span class="comment">//取栈顶                </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">( )</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> top == <span class="literal">NULL</span>; &#125;      </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">( )</span><span class="keyword">const</span></span>;                     <span class="comment">//求栈中元素个数      </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeEmpty</span><span class="params">()</span></span>;   <span class="comment">//清空栈的内容      </span></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os,            </span><br><span class="line">LinkedStack&lt;T&gt;&amp; s) &#123; &#125;                          </span><br><span class="line"><span class="comment">//输出栈元素的重载操作 &lt;&lt;           </span></span><br><span class="line"><span class="comment">//书上的参数SeqStack应为LinkedStack </span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//链式栈类操作-求个数 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">LinkedStack</span>&lt;T&gt;:</span>:getSize( )<span class="keyword">const</span>&#123;  </span><br><span class="line">LinkNode&lt;T&gt; *p=top; </span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>) &#123;k++; p=p-&gt;link;&#125; <span class="comment">//p94书上的while语句里用的top应为p。 </span></span><br><span class="line"><span class="keyword">return</span> k; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//链式栈类操作-置空 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkedStack</span>&lt;T&gt;:</span>:makeEmpty( ) &#123;  </span><br><span class="line"><span class="comment">//逐次删去链式栈中的元素直至栈顶指针为空。     </span></span><br><span class="line">LinkNode&lt;T&gt; *p;  </span><br><span class="line"><span class="keyword">while</span> (top != <span class="literal">NULL</span>)            <span class="comment">//逐个结点释放         </span></span><br><span class="line">&#123; p = top;  top = top-&gt;link;  <span class="keyword">delete</span> p; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//链式栈类操作-进栈 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkedStack</span>&lt;T&gt;:</span>:Push(<span class="keyword">const</span> T&amp; x) &#123; </span><br><span class="line"><span class="comment">//将元素值x插入到链式栈的栈顶,即链头。     </span></span><br><span class="line">top = <span class="keyword">new</span> StackNode&lt;T&gt; (x, top);     </span><br><span class="line"><span class="comment">//创建新结点//同时插入到top前面，然后top指向新 结点即新栈顶   </span></span><br><span class="line"><span class="comment">//类似于P76InsertAfter里link=new Term(c,e,link);      </span></span><br><span class="line">assert (top != <span class="literal">NULL</span>);       <span class="comment">//创建失败退出 </span></span><br><span class="line"><span class="comment">//assert断言机制，若参数条件满足继续执行否则 </span></span><br><span class="line"><span class="comment">//出错处理，终止执行 </span></span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//链式栈类操作-出栈 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">LinkedStack</span>&lt;T&gt;:</span>:Pop(T&amp; x) &#123; <span class="comment">//删除栈顶结点, 返回被删栈顶元素的值。      </span></span><br><span class="line"><span class="keyword">if</span> (IsEmpty() == <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//栈空返回     </span></span><br><span class="line">LinkNode&lt;T&gt; *p = top;  <span class="comment">//暂存栈顶元素   </span></span><br><span class="line">top = top-&gt;link;       <span class="comment">//退栈顶指针   </span></span><br><span class="line">x = p-&gt;data;   </span><br><span class="line"><span class="keyword">delete</span> p;          <span class="comment">//释放结点      </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//链式栈类操作-获取栈顶元素值 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">bool</span> </span></span><br><span class="line"><span class="class"><span class="title">LinkedStack</span>&lt;T&gt;:</span>:getTop(T&amp; x) <span class="keyword">const</span> &#123;    </span><br><span class="line"><span class="keyword">if</span> (IsEmpty() == <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//栈空返回   </span></span><br><span class="line">x = top-&gt;data;                       <span class="comment">//返回栈顶元素的值      </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//链式栈类操作-输出 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">ostream</span>&amp; <span class="title">operator</span> &lt;&lt; (ostream&amp; os, LinkedStack&lt;T&gt;&amp; s) &#123; //从栈顶开始逐个输出 </span></span><br><span class="line"><span class="class">os&lt;&lt;“栈中元素个数=”&lt;&lt;s.getSize( )&lt;&lt;endl; </span></span><br><span class="line"><span class="class">StackNode&lt;T&gt; *p=s.top;         //书上S.top应为s.top </span></span><br><span class="line"><span class="class">int i=0;   </span></span><br><span class="line"><span class="class">while(p!=NULL) &#123;  </span></span><br><span class="line"><span class="class">os&lt;&lt;++i&lt;&lt;“:”&lt;&lt;p-&gt;data&lt;&lt;endl;  </span></span><br><span class="line"><span class="class">p=p-&gt;link;&#125; </span></span><br><span class="line"><span class="class">return os; </span></span><br><span class="line"><span class="class">&#125;  </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//链式栈类操作-递归输出 </span></span><br><span class="line"><span class="class">template &lt;class T&gt; </span></span><br><span class="line"><span class="class">void LinkedStack&lt;T&gt;::output(ostream&amp; os,      </span></span><br><span class="line"><span class="class">StackNode&lt;T&gt; *ptr) &#123;     </span></span><br><span class="line"><span class="class">int i=1；     //递归输出栈中所有元素（沿链逆向输出）  </span></span><br><span class="line"><span class="class">if (ptr != NULL) &#123;     </span></span><br><span class="line"><span class="class">if (ptr-&gt;link != NULL)                </span></span><br><span class="line"><span class="class">output(os, ptr-&gt;link, i++);    </span></span><br><span class="line"><span class="class">os &lt;&lt; i &lt;&lt; “ : ” &lt;&lt; ptr-&gt;data &lt;&lt; endl;                    </span></span><br><span class="line"><span class="class">//递归结束条件ptr-&gt;link != NULL，                  </span></span><br><span class="line"><span class="class">//输出最后一个元素，然后沿链逐个返回输出 </span></span><br><span class="line"><span class="class">  &#125; </span></span><br><span class="line"><span class="class">&#125;;</span></span><br></pre></td></tr></table></figure>

<h4 id="栈的应用：括号匹配"><a href="#栈的应用：括号匹配" class="headerlink" title="栈的应用：括号匹配"></a>栈的应用：括号匹配</h4><p>如从左向右扫描，则每个右括号将与最近遇到的未匹配的左括号匹配。 </p>
<p>把从左向右扫描到的左括号放入栈中，在后续扫描中遇到右括号时，就将它与栈顶的左括号 （如果存在）相匹配，同时在栈顶删除该左括号。<br><strong>分析可能出现的不匹配的情况</strong> </p>
<p>1．到目前左括号少即：到来的是右括号而栈中无左括号在等待（栈是空的） </p>
<p>2．到结束右括号少。即：栈中还有左括弧没等到和它相匹配的右括弧 </p>
<p><strong>算法的设计思想</strong> </p>
<p>1)凡出现左括弧，则进栈； </p>
<p>2)凡出现右括弧，首先检查栈是否空若栈空，则表明“右括弧”多了，不匹配，否则“左括弧出栈”；      </p>
<p>3）表达式检验结束时，若栈空，则匹配正确 否则说明左括弧多了,不匹配。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMatchedPairs</span><span class="params">(<span class="keyword">char</span>* expression)</span></span>&#123;   </span><br><span class="line"><span class="function">Stack&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(maxLength)</span></span>;   </span><br><span class="line"><span class="keyword">int</span> j, length=<span class="built_in">strlen</span>(expression);   </span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">1</span>; i&lt;length; i++) &#123;      </span><br><span class="line"><span class="keyword">if</span> ( expression[i<span class="number">-1</span>]==‘(’ )  s.Push(i);   </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( expression[i<span class="number">-1</span>]==‘)’ ) &#123;           </span><br><span class="line"><span class="keyword">if</span> ( s.Pop(j)==<span class="literal">true</span> )             </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;j&lt;&lt;“与”&lt;&lt;i&lt;&lt;“匹配”&lt;&lt;<span class="built_in">endl</span>;           </span><br><span class="line"><span class="keyword">else</span>             </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;“没有与”&lt;&lt;i&lt;&lt;“匹配的左括号”&lt;&lt;<span class="built_in">endl</span>;         </span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">while</span> ( s.IsEmpty( )==<span class="literal">false</span> ) &#123;     </span><br><span class="line">s.Pop(j);     </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;“没有与”&lt;&lt;j&lt;&lt;“匹配的左括号”&lt;&lt;<span class="built_in">endl</span>; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="栈的应用：表达式求值"><a href="#栈的应用：表达式求值" class="headerlink" title="栈的应用：表达式求值"></a>栈的应用：表达式求值</h4><p>一个表达式由操作数（亦称运算对象）、操作符（亦称运算符）和分界符组成。 </p>
<p> 算术表达式有三种表示： </p>
<p> 中缀(infix)表示        &lt;操作数&gt; &lt;操作符&gt; &lt;操作数&gt;，如 A+B； </p>
<p> 前缀(prefix)表示     &lt;操作符&gt; &lt;操作数&gt; &lt;操作数&gt;，如 +AB； </p>
<p> 后缀(postfix)表示    &lt;操作数&gt; &lt;操作数&gt; &lt;操作符&gt;，如 AB+； </p>
<p><strong>表达式</strong> </p>
<p>中缀表达式    a + b * ( c - d ) - e / f </p>
<p>后缀表达式    a b c d - * + e f / - </p>
<p>前缀表达式    - + a * b – c d / e f </p>
<p>结论</p>
<p>1）操作数之间的相对次序不变 </p>
<p>2）运算符之间的的相对次序不同 </p>
<p>3）前缀式的运算规则为：     </p>
<p>连续出现的两个操作数和在它们之前且紧靠它们的运算符 构成一个最小表达式； </p>
<p>4）后缀式的运算规则为： </p>
<p>运算符在式中出现的顺序恰为表达式的运算顺序； 每个运算符和在它之前出现且紧靠它的两个操作数构成一个最小 表达式； </p>
<p><strong>算术表达式运算规则</strong> </p>
<p>运算规则： </p>
<p>先左后右，先乘除后加减，先括弧内后括弧外 。</p>
<p>例如：4+2*3-10/5=4+6-10/5=10-10/5= 10-2=8              </p>
<p>​            4 2 3 * + 10 5 / -  = 8</p>
<p>实现方法讲解: </p>
<ul>
<li><p>中缀表达式直接求值法 </p>
<p> 借助于栈：OPND栈和OPTR栈       </p>
<p> 操作数入OPND栈，算符入OPTR栈 </p>
</li>
<li><p>中缀变后缀表达式求值：   </p>
<p> 运算符顺序变化，需存储“等待中” 的运算符    </p>
<p> 需将当前运算符与等待中最后一个运算符比较   </p>
</li>
</ul>
<p><strong>如何从中缀表达式求得后缀式？</strong> </p>
<p> 利用堆栈存储“等待中”的运算符实现中缀变后缀表达式,为了实现这种转换，需要考虑各操作符在栈 内和栈外的优先级</p>
<p> 对原表达式中出现的每一个运算符是否即刻 进行运算取决于在它后面出现的运算符 </p>
<p> 如果它的优先数“高或等于”后面的运算， 则它的运算先进行， </p>
<p> 否则就得等待在它之后出现的所有优先数高 于它的“运算”都完成之后再进行。 </p>
<p><strong>从原表达式求得后缀式的规则为 :</strong></p>
<p>1) 设立运算符栈； </p>
<p>2) 设表达式的结束符为“#”，预设运算符栈 的栈底为“#”； </p>
<p>3) 若当前字符是操作数，则直接发送给后缀式； </p>
<p>4) 若当前字符为运算符且优先数高于栈顶运算 符，则进栈，否则退出栈顶运算符发送给后 缀式； </p>
<p>5) 若当前字符是结束符，则自栈顶至栈底依次 将栈中所有运算符发送给后缀式； </p>
<p>注意： </p>
<p>一般作为相同运算符，先出现的比后出现的 优先级高； </p>
<p>先出现的运算符优先级低于“(”，高于“)”； </p>
<p>优先权相等的仅有“(”和“)”、“#”。 </p>
<p> #：作为表达式结束符，通常在表达式之前 加一“#”使之成对，当出现“#”=“#”时，表 明表达式求值结束，“#”的优先级最低。<br>任意相继出现的算符θ1和θ2，都要比较优先权 关系。  一般任意两个相继出现的两个算符θ1和θ2之间 的优先关系至多有下面三种之一： θ1&lt;θ2    θ2的优先权高于θ1 θ1=θ2   二者优先权相等 θ1&gt;θ2    θ2的优先权低于θ1  </p>
<p><strong>中缀式转换为后缀式的算法 :</strong></p>
<p>（isp叫做栈内(in stack priority)优先数; icp叫做栈外(in coming priority)优先数。操作符优先数相等的情况只出现在括号配对或 栈底的“#”号与输入流最后的“#”号配对时。） </p>
<p>操作符栈初始化，将符号‘#’进栈。然后读 入中缀表达式字符流的首字符ch。 </p>
<p> 重复执行以下步骤，直到栈为空，停止循 环。 </p>
<p> 若ch是操作数直接输出，读入下一个字 符ch。 </p>
<p> 若ch是操作符，判断ch的优先级icp和位 于栈顶的操作符op的优先级isp：<br> 若 icp(ch) &gt; isp(op)，令ch进栈，读入下一 个字符ch。 </p>
<p> 若 icp(ch) &lt; isp(op)，退栈并输出。 </p>
<p> 若 icp(ch) == isp(op)，退栈但不输出，若 退出的是“(”号读入下一个字符ch。 </p>
<p> 算法结束，输出序列即为所需的后缀表达式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postfix</span> <span class="params">( expression e )</span> </span>&#123;   </span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s;   </span><br><span class="line"><span class="keyword">char</span> ch, op;    </span><br><span class="line">s.Push ( ‘#’ );   </span><br><span class="line"><span class="built_in">cin</span>.Get ( ch ); </span><br><span class="line"><span class="keyword">while</span> ( ! s.IsEmpty( )) <span class="comment">// 课本代码有问题  </span></span><br><span class="line"><span class="comment">//循环条件也可以为while(ch!=‘#’||s.getTop()!=‘#’) </span></span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">isdigit</span> ( ch ) )            </span><br><span class="line">        &#123; <span class="built_in">cout</span> &lt;&lt; ch;  <span class="built_in">cin</span>.Get ( ch ); &#125;        </span><br><span class="line">        <span class="keyword">else</span> &#123;             </span><br><span class="line">        <span class="keyword">if</span> ( isp ( s.GetTop( ) ) &lt; icp ( ch ) ) c</span><br><span class="line">             &#123; s.Push ( ch );  <span class="built_in">cin</span>.Get ( ch ); </span><br><span class="line">             &#125;           </span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> ( isp ( s.GetTop( ) ) &gt; icp ( ch ) )              </span><br><span class="line">             &#123; s.Pop(op);   </span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt; op; </span><br><span class="line">             &#125;            </span><br><span class="line">             <span class="keyword">else</span> &#123; s.Pop(op);                  </span><br><span class="line">             <span class="keyword">if</span> ( op == ‘(’ ) <span class="built_in">cin</span>.Get ( ch ); &#125;   </span><br><span class="line">             &#125;</span><br><span class="line">             &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> &#123;</span> <span class="comment">//模拟一个简单计算器 </span></span><br><span class="line"><span class="keyword">public</span>:           </span><br><span class="line">  Calculator(<span class="keyword">int</span> sz):s(sz)&#123;&#125;; <span class="comment">//构造函数           </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span>;             <span class="comment">//执行表达式计算           </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">()</span></span>; </span><br><span class="line"><span class="keyword">private</span>:             </span><br><span class="line">  Stack&lt;<span class="keyword">double</span>&gt; s;      <span class="comment">//栈对象定义          </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span>  <span class="title">AddOperand</span><span class="params">(<span class="keyword">double</span> value)</span> </span>;  <span class="comment">//进操作数栈           </span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Get2Operands</span><span class="params">(<span class="keyword">double</span>&amp; left,<span class="keyword">double</span>&amp; right)</span></span>;                             </span><br><span class="line">  <span class="comment">//从栈中退出两个操作数           v</span></span><br><span class="line">  <span class="function">oid <span class="title">DoOperator</span><span class="params">(<span class="keyword">char</span> op)</span></span>; <span class="comment">//形成运算指令,进行计算 </span></span><br><span class="line">  &#125;; </span><br><span class="line"><span class="keyword">void</span> Calculator :: Run ( ) &#123;    </span><br><span class="line">   <span class="keyword">char</span> ch;   <span class="keyword">double</span> newoperand;    </span><br><span class="line">   <span class="keyword">while</span> ( <span class="built_in">cin</span> &gt;&gt; ch,  ch != ‘#’ ) &#123;        </span><br><span class="line">     <span class="keyword">switch</span> ( ch ) &#123;         </span><br><span class="line">       <span class="keyword">case</span> ‘+’ :           </span><br><span class="line">       <span class="keyword">case</span> ‘-’ :            </span><br><span class="line">       <span class="keyword">case</span> ‘*’ :           </span><br><span class="line">       <span class="keyword">case</span> ‘/’ :   </span><br><span class="line">       DoOperator ( ch );                             </span><br><span class="line">       <span class="keyword">break</span>;   <span class="comment">//计算         </span></span><br><span class="line">      <span class="keyword">default</span> :  <span class="built_in">cin</span>.putback ( ch );                              </span><br><span class="line">                                <span class="comment">//将字符放回输入流                   </span></span><br><span class="line">       <span class="built_in">cin</span> &gt;&gt; newoperand;  <span class="comment">//读操作数                        </span></span><br><span class="line">          AddOperand ( newoperand );       </span><br><span class="line">          &#125;    </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h4 id="栈的应用：递归"><a href="#栈的应用：递归" class="headerlink" title="栈的应用：递归"></a>栈的应用：递归</h4><h5 id="递归的定义"><a href="#递归的定义" class="headerlink" title="递归的定义"></a><strong>递归的定义</strong></h5><p>若一个对象部分地包含它自己，或用它自己 给自己定义,  则称这个对象是递归的；若 一个过程直接地或间接地调用自己, 则称这 个过程是递归的过程。 </p>
<p><strong>函数间的的执行</strong></p>
<p>1 .操作系统中，当一个函数调用另一个函数，需先完成： </p>
<p>1) 将所有的实在参数、返回地址等信息传递给被调用函数保存  </p>
<p>2) 为被调用函数的局部变量分配存储区；  </p>
<p>3) 将控制转移到被调用函数的入口。 </p>
<p>2 .从被调用函数返回调用函数之前，应该完成：   </p>
<p>1) 保存被调函数的计算结果；   </p>
<p>2) 释放被调函数的数据区；   </p>
<p>3) 依照被调函数保存的返回地址将控制转移到调用函数 </p>
<p><strong>递归函数的概念</strong>  </p>
<p>直接或间接地调用自身的函数称为递归函数。 从递归函数的执行过程看，递归函数设计时必须 有一个出口，直接处理, 从而结束对自身的调用。</p>
<p><strong>构成递归的条件</strong></p>
<p>不能无限制地调用本身， 必须有一个出口，直接处理。 </p>
<p>递归定义包括两项，一是边界条件：描述递归终止时问题的求解  ；二是递归函数：将问题分解为与原问题性质相同，但 规模较小的问题。只有具备了这两个要素，递归函数才能在有限次计算后得出结果。 </p>
<p><strong>递归设计：自顶向下、逐步分解的策略</strong> </p>
<p>解决递归问题的策略是把一个规模比较大的 问题分解为一个或若干规模比较小的问题， 子问题应与原问题做同样的事情，且更为简 单；分别对这些比较小的问题求解，再综合 它们的结果，从而得到原问题的解。 </p>
<p> <strong>以下三种情况常常用到递归方法</strong> </p>
<p> 定义是递归的 </p>
<p> 数据结构是递归的 </p>
<p> 问题的解法是递归的 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//含一个递归调用的递归过程的一般形式 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">p</span><span class="params">(参数<span class="number">1</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;    <span class="keyword">if</span>(数据为递归出口)                    </span><br><span class="line">操作;        </span><br><span class="line"><span class="keyword">else</span>&#123;                  </span><br><span class="line">操作;                 </span><br><span class="line">p(参数<span class="number">2</span>);                 </span><br><span class="line">操作;         </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="递归过程改为非递归过程"><a href="#递归过程改为非递归过程" class="headerlink" title="递归过程改为非递归过程"></a><strong>递归过程改为非递归过程</strong></h6><p>递归过程简洁、易编、易懂。但递归过程效率低，重复计算多，改为非递 归过程的目的是提高效率 。</p>
<p> 单向递归或尾递归可直接用迭代实现其非递归 过程（尾递归是单项递归的特例） </p>
<p> 其他情形必须借助栈实现非递归过程 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用迭代法实现单向递归 </span></span><br><span class="line"><span class="comment">//斐波那契数列就是单向递归 </span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">FibIter</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;      </span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;      </span><br><span class="line"><span class="keyword">long</span> twoback = <span class="number">0</span>,  oneback = <span class="number">1</span>,  current;      </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;          </span><br><span class="line">current = twoback + oneback;          </span><br><span class="line">twoback = oneback;             </span><br><span class="line">oneback = current;   </span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">return</span> current; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用迭代法实现尾递归 </span></span><br><span class="line"><span class="comment">//递归调用语句只有一句且在函数尾部</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recfunc</span><span class="params">(<span class="keyword">int</span> A[ ],  <span class="keyword">int</span> n)</span> </span>&#123;      </span><br><span class="line"><span class="keyword">if</span> (n &gt;= <span class="number">0</span>) &#123;           </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; A[n] &lt;&lt; “  ”;           </span><br><span class="line">n--;           </span><br><span class="line">recfunc(A, n);     </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sterfunc</span><span class="params">(<span class="keyword">int</span> A[ ], <span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line"><span class="comment">//消除了尾递归的非递归函数     </span></span><br><span class="line"><span class="keyword">while</span> (n &gt;= <span class="number">0</span>) &#123;          </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"value "</span> &lt;&lt; A[n] &lt;&lt; <span class="built_in">endl</span>;          </span><br><span class="line">n--;     </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="递归与回溯"><a href="#递归与回溯" class="headerlink" title="递归与回溯"></a><strong>递归与回溯</strong></h5><p>回溯法也常称为试探法。这种方法将问题的 候选解按某种顺序逐一检验，当发现当前解 不可能是解时，可以沿搜索路径回退到前一 结点，沿另一分支继续搜索,直到搜索到问题 的解，或搜完全部分支没有解存在为止。 </p>
<p>回溯法常使用递归进行试探，或使用栈帮助向前试探。 </p>
<h6 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a><strong>迷宫问题</strong></h6><p>迷宫是一个矩形区域，有一个入口和一个出口，其内 部设置了许多不能穿越的墙壁，对从入口到出口的前 进道路上形成了许多障碍.若能正确的绕过障碍，则从入口到出口存在一条穿越 迷宫的路线。 </p>
<p>前进方向：北、东北、东、东南   南、西南、西、西北 .<br>走步规则：首先从东开始，按照 顺时针方向搜索下一步可 能前进的位置 .</p>
<p>数据结构设计<br>1 用二维数组Maze[m+2][p+2]表示迷宫 </p>
<p>  若元素Maze[i][j]==1,表示该位置上是障碍。 </p>
<p>  若元素Maze[i][j]==0,表示该位置上是通路。 </p>
<p>2 用二维数组mark[m+2][p+2]标志已走过 的路途，防止走老路。 </p>
<p> 初始化时，所有元素都是没走过的，设为0。 </p>
<p> 当行进到迷宫的某个位置[i][j]时，就将对应的 mark[i][j]置为1； </p>
<p> 当前点的下一个试探位置   从当前位置Maze[i][j]出发，可能的前进方向有8个，用一 维数组move[8]表示。其数组元素为结构类型数据: </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">offsets</span> &#123;</span>     </span><br><span class="line"><span class="keyword">int</span> a, b;        <span class="comment">//a,b是横,纵方向的偏移量    </span></span><br><span class="line"><span class="keyword">char</span> *dir &#125; </span><br><span class="line"></span><br><span class="line">offsets <span class="built_in">move</span>[<span class="number">8</span>]=&#123;</span><br><span class="line">&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="string">"N"</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="string">"NE"</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="string">"E"</span>&#125;, &#123; <span class="number">1</span>,<span class="number">1</span>,<span class="string">"SE"</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="string">"S"</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="string">"SW"</span> </span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="string">"W"</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="string">"NW"</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解决迷宫问题的递归算法 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeekPath</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;      </span><br><span class="line"><span class="keyword">int</span> i,g,h; <span class="keyword">char</span> *d;   <span class="comment">//d,h记录位置信息，d记录方向      </span></span><br><span class="line"><span class="keyword">if</span>(x==m &amp;&amp; y==n)  <span class="keyword">return</span> <span class="number">1</span>;           </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line"> &#123;           </span><br><span class="line">   g=x+<span class="built_in">move</span>[i].a;   h=y+<span class="built_in">move</span>[i].b;     d=<span class="built_in">move</span>[i].dir; </span><br><span class="line">   <span class="keyword">if</span>(Maze[g][h]==<span class="number">0</span>&amp;&amp;mark[g][h]==<span class="number">0</span>)  </span><br><span class="line">   &#123;                </span><br><span class="line">        mark[g][h]=<span class="number">1</span>;            </span><br><span class="line">        <span class="keyword">if</span>(SeekPath(g,  h))</span><br><span class="line">        &#123;              </span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;“(“&lt;&lt;g&lt;&lt;“,”&lt;&lt;h&lt;&lt;“),”&lt;&lt;“direction”&lt;&lt;<span class="built_in">move</span>[i].dir&lt;&lt; “,”;       </span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">   &#125;         </span><br><span class="line"> &#125;<span class="comment">//回溯，换方向再试      </span></span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">1</span>&amp;&amp;y==<span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;“no path in Maze”&lt;&lt;<span class="built_in">endl</span>;      </span><br><span class="line">Return <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="n皇后问题"><a href="#n皇后问题" class="headerlink" title="n皇后问题"></a><strong>n皇后问题</strong></h6><p>在 n 行 n 列的国际象棋棋盘上，若两个皇后位于 同一行、同一列、同一对角线上，则称为它们为 互相攻击。n 皇后问题是指找到这 n 个皇后的互 不攻击的布局。 </p>
<p>8皇后问题：在8X8格的国际象棋上摆放八个皇后，使 其不能互相攻击，即任意两个皇后都不能处于同一行、 同一列或同一斜线上，问有多少种摆法？ </p>
<p>解题思路 </p>
<p>安放第 i 行皇后时，需要在列的方向从 0 到 n-1 试探 ( j = 0, …, n-1 )  </p>
<p>在第 j 列安放一个皇后： 如果在列、对角线方向有其它皇后，则 出现攻击，撤消在第 j 列安放的皇后。如果没有出现攻击，在第 j 列安放的皇 后不动，递归安放第 i+1行皇后。 </p>
<p>设置数组 col [n] ：col[i] 标识第 i 列是否安放了皇后 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Queen</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;     </span><br><span class="line"><span class="keyword">if</span> (i&gt;n) 输出棋盘布局；     </span><br><span class="line"><span class="keyword">else</span>     </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;  j &lt;= n;  j++) &#123;          </span><br><span class="line"> <span class="keyword">if</span> (第 i 行第 j 列没有攻击) &#123;              </span><br><span class="line"> 在第 i 行第 j 列安放皇后；               </span><br><span class="line"> Queen(i+<span class="number">1</span>);             </span><br><span class="line">   &#125;         </span><br><span class="line">  &#125;      </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//算法求精 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queen</span><span class="params">(<span class="keyword">int</span> k)</span>    </span>&#123;  </span><br><span class="line"><span class="keyword">if</span>(k&gt;n) &#123;sum++ ;               </span><br><span class="line"><span class="comment">//在这里打印出来 ；              </span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"the solution of "</span>&lt;&lt;sum &lt;&lt;<span class="built_in">endl</span>;              </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)             </span><br><span class="line">&#123;<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)            </span><br><span class="line"><span class="keyword">if</span> (x[i]==j) <span class="built_in">cout</span>&lt;&lt;<span class="string">"* "</span> ;               </span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"0 "</span>;                 </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span> ;    &#125;             </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">&#125; <span class="keyword">else</span>  </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)  </span><br><span class="line">&#123;   x[k]=j;      </span><br><span class="line"><span class="keyword">if</span>(place(k))    </span><br><span class="line">queen(k+<span class="number">1</span>);   &#125;&#125; </span><br><span class="line">place(<span class="keyword">int</span> t)  </span><br><span class="line"><span class="comment">//检查 第 t个皇后在第T行的当前位置上是否满足约束条件 </span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;t;i++)    </span><br><span class="line"><span class="keyword">if</span>((x[i]==x[t])|| (<span class="built_in">abs</span>(i-t)==<span class="built_in">abs</span>(x[i]-x[t])) ) <span class="keyword">return</span> <span class="literal">false</span> ;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125; </span><br><span class="line">Int sum=<span class="number">0</span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">int</span> n; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入皇后的数目"</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n; </span><br><span class="line"><span class="keyword">int</span> *x=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>] ; <span class="comment">//记录每行的皇后放在哪一列  </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=total;i++) x[i]=<span class="number">0</span>; </span><br><span class="line">queen(<span class="number">1</span>) ; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"the result of nqueen is :"</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line"><span class="keyword">delete</span> [] x ; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是只允许在一端删除，在另一端插入 的线性表 </p>
<p>允许删除的一端叫做队头(front)，允许插 入的一端叫做队尾(rear)。 </p>
<p>特性：先进先出(FIFO, First In First Out) </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队列的抽象数据类型 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Queue</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:      </span><br><span class="line">Queue() &#123; &#125;;       <span class="comment">//构造函数      </span></span><br><span class="line">～Queue() &#123; &#125;;       <span class="comment">//析构函数      </span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(<span class="keyword">const</span> E&amp; x)</span> </span>= <span class="number">0</span>;  <span class="comment">//进队列      </span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(E&amp; x)</span> </span>= <span class="number">0</span>;       <span class="comment">//出队列      </span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">getFront</span><span class="params">(E&amp; x)</span> </span>= <span class="number">0</span>;       <span class="comment">//取队头        </span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;       <span class="comment">//判队列空      </span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsFull</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;       <span class="comment">//判队列满 &#125;; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//队列的数组存储表示 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt; <span class="title">class</span> <span class="title">SeqQueue</span> :</span> <span class="keyword">public</span> Queue&lt;E&gt; &#123;    <span class="comment">//队列类定义 protected:      </span></span><br><span class="line"><span class="keyword">int</span> rear, front;         <span class="comment">//队尾与队头指针      </span></span><br><span class="line">E *elements;         <span class="comment">//队列存放数组      </span></span><br><span class="line"><span class="keyword">int</span> maxSize;         <span class="comment">//队列最大容量 </span></span><br><span class="line">……. </span><br><span class="line"><span class="comment">// 函数 </span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p><strong>队列的进队和出队原则</strong> </p>
<p> 进队时先将新元素按 rear 指示位置加入， 再将队尾指针加一  rear = rear + 1。 </p>
<p> 队尾指针指示实际队尾的后一位置。 </p>
<p> 出队时按队头指针指示位置取出元素，再将 队头指针进一 front = front + 1， </p>
<p> 队头指针指示实际队头位置。 </p>
<p> 队满时再进队将溢出出错（假溢出） ； </p>
<p> 解决假溢出的办法之一：将队列元素存放数 组首尾相接，形成循环（环形）队列。 </p>
<h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><p> 队列存放数组被当作首尾相接的表处理。 </p>
<p> 为了防止队头、队尾指针加1产生假溢出，可用语言 的取模(余数)运算实现。 </p>
<p> 队列初始化：front = rear = 0;  队头指针进1:  front = (front+1) % maxSize; </p>
<p> 队尾指针进1:  rear = (rear+1) % maxSize; </p>
<p> 队空条件：front == rear; </p>
<p> 队满条件：(rear+1) % maxSize == front （看示例） </p>
<p>   通过牺牲一个存储空间来实现（课本上的方案） </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队列的数组存储表示----循环队列 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt; <span class="title">class</span> <span class="title">SeqQueue</span> :</span> <span class="keyword">public</span> Queue&lt;E&gt; &#123;    <span class="comment">//队列类定义 protected:      </span></span><br><span class="line"><span class="keyword">int</span> rear, front;         <span class="comment">//队尾与队头指针      </span></span><br><span class="line">E *elements;         <span class="comment">//队列存放数组      </span></span><br><span class="line"><span class="keyword">int</span> maxSize;         <span class="comment">//队列最大容量 </span></span><br><span class="line"><span class="keyword">public</span>:      </span><br><span class="line">SeqQueue(<span class="keyword">int</span> sz = <span class="number">10</span>);    <span class="comment">//构造函数 </span></span><br><span class="line">～SeqQueue() &#123; <span class="keyword">delete</span>[ ] elements; &#125;  <span class="comment">//析构函数      </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(<span class="keyword">const</span> E &amp;x)</span></span>;         <span class="comment">//新元素进队列      </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(E&amp; x)</span></span>;      <span class="comment">//退出队头元素      </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">getFront</span><span class="params">(E&amp; x)</span></span>;       <span class="comment">//取队头元素值      </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeEmpty</span><span class="params">()</span> </span>&#123; front = rear = <span class="number">0</span>; &#125;        </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> front == rear; &#125;       </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsFull</span><span class="params">()</span> <span class="keyword">const</span>           </span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> ((rear+<span class="number">1</span>)% maxSize == front); &#125;       </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> <span class="keyword">const</span>           </span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> (rear-front+maxSize) % maxSize; &#125;  </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//循环队列操作的定义 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">SeqQueue</span>&lt;E&gt;:</span>:SeqQueue(<span class="keyword">int</span> sz): front(<span class="number">0</span>), rear(<span class="number">0</span>), maxSize(sz) &#123; <span class="comment">//构造函数   </span></span><br><span class="line">elements = <span class="keyword">new</span> E[maxSize];         </span><br><span class="line">assert ( elements != <span class="literal">NULL</span> ); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">SeqQueue</span>&lt;E&gt;:</span>:EnQueue(<span class="keyword">const</span> E&amp; x) &#123;</span><br><span class="line"><span class="comment">//若队列不满, 则将x插入到该队列队尾, 否则返回      </span></span><br><span class="line"><span class="keyword">if</span> (IsFull() == <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">false</span>;         </span><br><span class="line">elements[rear] = x;                    <span class="comment">//先存入      </span></span><br><span class="line">rear = (rear+<span class="number">1</span>) % maxSize;       <span class="comment">//尾指针加一      </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">SeqQueue</span>&lt;E&gt;:</span>:DeQueue(E&amp; x) &#123;  </span><br><span class="line"><span class="comment">//若队列不空则函数退队头元素并返回其值      </span></span><br><span class="line"><span class="keyword">if</span> (IsEmpty() == <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">x = elements[front];                  <span class="comment">//先取队头      </span></span><br><span class="line">front = (front+<span class="number">1</span>) % maxSize;   <span class="comment">//再队头指针加一      </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">SeqQueue</span>&lt;E&gt;:</span>:getFront(E&amp; x) <span class="keyword">const</span> &#123; <span class="comment">//若队列不空则函数返回该队列队头元素的</span></span><br><span class="line"><span class="keyword">if</span> (IsEmpty() == <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//队列空   </span></span><br><span class="line">x = elements[front];      <span class="comment">//返回队头元素   </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h4><p> 队头在链头，队尾在链尾。 </p>
<p> 链式队列在进队时无队满问题，但有队空问 题。 </p>
<p> 队空条件为 front == NULL </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队列的链接存储表示 — 链式队列 </span></span><br><span class="line"><span class="comment">//链式队列类的定义 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt; <span class="title">struct</span> <span class="title">LinkNode</span> &#123;</span>                   <span class="comment">//队列结点类定义  private:      </span></span><br><span class="line">E data;             <span class="comment">//队列结点数据     </span></span><br><span class="line">LinkNode&lt;E&gt; *link;          <span class="comment">//结点链指针 </span></span><br><span class="line"><span class="keyword">public</span>:     </span><br><span class="line">LinkNode(<span class="keyword">const</span> E&amp; d , LinkNode&lt;E&gt;*  next =null) : data(d), link(next) &#123; &#125; </span><br><span class="line">&#125;;   </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">LinkedQueue</span> &#123;</span>  </span><br><span class="line"><span class="keyword">private</span>:       </span><br><span class="line">LinkNode&lt;E&gt; *front, *rear;   <span class="comment">//队头、队尾指针 </span></span><br><span class="line"><span class="keyword">public</span>:      </span><br><span class="line">LinkedQueue() : rear(<span class="literal">NULL</span>), front(<span class="literal">NULL</span>) &#123; &#125;     </span><br><span class="line">~LinkedQueue(MakeEmpty());        </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(<span class="keyword">const</span> E&amp; x)</span></span>;     </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(E&amp; x)</span></span>;        </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetFront</span><span class="params">(E&amp; x)</span></span>;        </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">()</span></span>;                 </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> front == <span class="literal">NULL</span>; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkedQueue</span>&lt;E&gt;:</span>:makeEmpty() &#123;      <span class="comment">//析构函数     </span></span><br><span class="line">LinkNode&lt;E&gt; *p;     </span><br><span class="line"><span class="keyword">while</span> (front != <span class="literal">NULL</span>) &#123;              <span class="comment">//逐个结点释放         </span></span><br><span class="line">p = front;  </span><br><span class="line">front = front-&gt;link;  </span><br><span class="line"><span class="keyword">delete</span> p;     &#125; </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">LinkedQueue</span>&lt;E&gt;:</span>:EnQueue(<span class="keyword">const</span> E&amp; x) &#123; <span class="comment">//将新元素x插入到队列的队尾 </span></span><br><span class="line"><span class="comment">// 分空表和非空表两种情况。 </span></span><br><span class="line"><span class="keyword">if</span> (front == <span class="literal">NULL</span>)  &#123;              <span class="comment">//创建第一个结点        </span></span><br><span class="line">front = rear = <span class="keyword">new</span> LinkNode&lt;E&gt; (x);           </span><br><span class="line"><span class="keyword">if</span> (front == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>; &#125; <span class="comment">//分配失败       </span></span><br><span class="line"><span class="keyword">else</span> &#123;                                      <span class="comment">//队列不空, 插入           </span></span><br><span class="line">rear-&gt;link = <span class="keyword">new</span> LinkNode&lt;E&gt; (x);           </span><br><span class="line"><span class="keyword">if</span> (rear-&gt;link == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;           </span><br><span class="line">rear = rear-&gt;link;      &#125;      </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt; //如果队列不空，将队头结点从链式队列中删去 </span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">LinkedQueue</span>&lt;E&gt;:</span>:DeQueue(E&amp; x) &#123;      </span><br><span class="line"><span class="keyword">if</span> (IsEmpty() == <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">false</span>;        <span class="comment">//判队空      </span></span><br><span class="line">LinkNode&lt;E&gt; *p = front;        </span><br><span class="line">x = front-&gt;data;  </span><br><span class="line">front = front-&gt;link;         </span><br><span class="line"><span class="keyword">delete</span> p;   </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;     </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">LinkedQueue</span>&lt;E&gt;:</span>:GetFront(E&amp; x) &#123; <span class="comment">//若队列不空，则函数返回队头元素的值      </span></span><br><span class="line"><span class="keyword">if</span> (IsEmpty() == <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">false</span>;       </span><br><span class="line">x = front-&gt;data;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="队列的应用：打印杨辉三角形"><a href="#队列的应用：打印杨辉三角形" class="headerlink" title="队列的应用：打印杨辉三角形"></a>队列的应用：打印杨辉三角形</h4><p>算法逐行打印二项展开式 (a + b)i 的系数</p>
<p>每行的第i个元素，等于上一行的第i个元素和 它的前驱项相加的结果 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用队列打印二项展开式系数的算法 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"queue.h"</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">YANGHVI</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;      </span><br><span class="line"> <span class="function">Queue <span class="title">q</span><span class="params">(n+<span class="number">2</span>)</span></span>;                     <span class="comment">//队列初始化      </span></span><br><span class="line"> q.MakeEmpty();      </span><br><span class="line"> q.EnQueue(<span class="number">1</span>);  q.EnQueue(<span class="number">1</span>); </span><br><span class="line"> <span class="keyword">int</span> s = <span class="number">0</span>, t;  </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;            <span class="comment">//逐行计算           </span></span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;                </span><br><span class="line"> q.EnQueue(<span class="number">0</span>); <span class="comment">//各行间插入一个0               </span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i+<span class="number">2</span>; j++)        </span><br><span class="line"> &#123;<span class="comment">//处理第i行的i+2(包括0)个系数。               </span></span><br><span class="line">  q.DeQueue(t);              </span><br><span class="line">  q.EnQueue(s + t);                 </span><br><span class="line">  s = t;               </span><br><span class="line">  <span class="keyword">if</span> (j != i+<span class="number">2</span>) <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">' '</span>;            </span><br><span class="line">     &#125;      </span><br><span class="line"> &#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h4><p>每次从队列中取出的是具 有最高优先权的元素 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优先级队列的类定义 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">PQueue</span> &#123;</span> <span class="keyword">private</span>:     </span><br><span class="line">E *pqelements;        <span class="comment">//存放数组     </span></span><br><span class="line"><span class="keyword">int</span> count;                  <span class="comment">//队列元素计数     </span></span><br><span class="line"><span class="keyword">int</span> maxPQSize;                <span class="comment">//最大元素个数     </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span></span>;                  <span class="comment">//调整 </span></span><br><span class="line"><span class="keyword">public</span>:      </span><br><span class="line">PQueue(<span class="keyword">int</span> sz = <span class="number">50</span>);     </span><br><span class="line">~PQueue() &#123; <span class="keyword">delete</span> [ ] pqelements; &#125;     </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(E x)</span></span>;     </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RemoveMin</span><span class="params">(E&amp; x)</span></span>;      </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetFront</span><span class="params">(E&amp; x)</span></span>;      </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">()</span> </span>&#123; count = <span class="number">0</span>; &#125;     </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> count == <span class="number">0</span>; &#125;     </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsFull</span><span class="params">()</span> <span class="keyword">const</span>             </span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> count == maxPQSize; &#125;      </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> count; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//优先级队列部分成员函数的实现 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;  <span class="title">PQueue</span>&lt;E&gt;:</span>:PQueue(<span class="keyword">int</span> sz) &#123;       </span><br><span class="line">maxPQSize = sz;  count = <span class="number">0</span>;       </span><br><span class="line">pqelements = <span class="keyword">new</span> E[maxPQSize];       </span><br><span class="line">assert (pqelements != <span class="literal">NULL</span>);  &#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">PQueue</span>&lt;E&gt;:</span>:Insert(E x) &#123;      </span><br><span class="line"><span class="keyword">if</span> (IsFull() == <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//判队满断言      </span></span><br><span class="line">pqelements[count++] = x;              <span class="comment">//插入 </span></span><br><span class="line">adjust();   </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">PQueue</span>&lt;E&gt;:</span>:adjust() &#123;      </span><br><span class="line">E temp = pqelements[count<span class="number">-1</span>];      <span class="comment">//将最后元素暂存再从后向前找插入位置      </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = count<span class="number">-2</span>;  j &gt;= <span class="number">0</span>;  j--)          </span><br><span class="line"><span class="keyword">if</span> (pqelements[j] &lt;= temp) <span class="keyword">break</span>;           </span><br><span class="line"><span class="keyword">else</span> pqelements[j+<span class="number">1</span>] = pqelements[j];      </span><br><span class="line">pqelements[j+<span class="number">1</span>] = temp; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">PQueue</span>&lt;E&gt;:</span>:RemoveMin(E&amp; x) &#123;      </span><br><span class="line"><span class="keyword">if</span> (IsEmpty()) <span class="keyword">return</span> <span class="literal">false</span>;     </span><br><span class="line">x = pqelements[<span class="number">0</span>];       <span class="comment">//取出0号元素      </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++)          </span><br><span class="line">pqelements[i<span class="number">-1</span>] = pqelements[i];           <span class="comment">//从后向前逐个移动元素填补空位      </span></span><br><span class="line">    count--;      </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; &#125;  </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt; <span class="title">bool</span> <span class="title">PQueue</span>&lt;E&gt;:</span>:GetFront (E&amp; x) &#123;      </span><br><span class="line"><span class="keyword">if</span> (IsEmpty() == <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">false</span>;      </span><br><span class="line">x = pqelements[<span class="number">0</span>];        </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>课内学习</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构笔记（第七章）</title>
    <url>/2021/05/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="第七章-搜索结构"><a href="#第七章-搜索结构" class="headerlink" title="第七章 搜索结构"></a>第七章 搜索结构</h1><h2 id="搜索的基本概念"><a href="#搜索的基本概念" class="headerlink" title="搜索的基本概念"></a>搜索的基本概念</h2><p>所谓搜索，就是在数据集合中寻找满足某种 条件的数据对象。搜索的结果通常有两种可能：搜索成功、搜索不成功。    </p>
<p>关键码：可以标识一个记录的某个数据项。  </p>
<p>键值：关键码的值。 </p>
<p>主关键码：可以唯一地标识一个记录的关键码。</p>
<p>次关键码：不能唯一地标识一个记录的关键码</p>
<p><strong>查找的基本概念</strong> </p>
<p>静态搜索：不涉及插入和删除操作的搜索 。 </p>
<p>动态搜索：涉及插入和删除操作的搜索。   </p>
<p>静态搜索适用于：搜索集合一经生成，便只对其进行 搜索，而不进行插入和删除操作，或经过一段时间的 搜索之后，集中地进行插入和删除等修改操作； </p>
<p>动态搜索适用于：查找与插入和删除操作在同一个阶 段进行，例如当查找成功时，要删除查找到的记录， 当查找不成功时，要插入被查找的记录。 </p>
<p>搜索结构 ：面向搜索操作的数据结构 ，即搜索基于的 数据结构。 集合中元素之间不存在明显的组织规律，不便查找。 </p>
<p>线性表：适用于静态搜索，主要采用顺序搜索技术 和折半搜索技术。 </p>
<p>树表：适用于动态搜索，主要采用二叉排序树的搜 索技术。</p>
<p>散列表：静态查找和动态查找均适用，主要采用散 列技术。  </p>
<p><strong>搜索算法的性能</strong>  </p>
<p>搜索算法时间性能通过关键码的比较次数来度量。</p>
<p>关键码的比较次数与哪些因素有关呢？<br>平均搜索长度：将搜索算法进行的关键码的比较次数 的数学期望值定义为平均搜索长度，即： </p>
<p>ASL=求和(i从1到n)  Pi*Ci</p>
<p>其中：n：问题规模，查找集合中的记录个数；Pi：搜索第i个记录的概率； Ci：搜索第i个记录所需的关键码的比较次数。 </p>
<p>Ci取决于算法；pi与算法无关，取决于具体应用。如果pi 是已知的，则平均查找长度只是问题规模的函数。 </p>
<h2 id="线性表的搜索技术"><a href="#线性表的搜索技术" class="headerlink" title="线性表的搜索技术"></a>线性表的搜索技术</h2><p><strong>静态搜索表</strong></p>
<p>在静态搜索表中，数据元素存放于数组中，利 用数组元素的下标作为数据元素的存放地址。 搜索算法根据给定值 k，在数组中进行搜索。 直到找到 k 在数组中的存放位置或可确定在数 组中找不到 k 为止。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据表与搜索表的类定义 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt; </span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> defaultSize = <span class="number">100</span>; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>, <span class="title">class</span> <span class="title">K</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">dataList</span>;</span>  <span class="comment">//数据表类的前视定义 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>, <span class="title">class</span> <span class="title">K</span> &gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">dataNode</span></span></span><br><span class="line"><span class="class">&#123;</span>  <span class="comment">//数据表中结点类的定义 </span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">dataList</span>&lt;E, K&gt;;</span><span class="comment">//声明其友元类为dataList</span></span><br><span class="line"><span class="keyword">private</span>:      </span><br><span class="line">K key;   <span class="comment">//关键码域        </span></span><br><span class="line">E other;            <span class="comment">//其他域（视问题而定）                       </span></span><br><span class="line"> <span class="keyword">public</span>: </span><br><span class="line"></span><br><span class="line">     dataNode (<span class="keyword">const</span> K x) : key(x) &#123; &#125;     <span class="comment">//构造函数      </span></span><br><span class="line">     <span class="function">K <span class="title">getKey</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> key; &#125;     <span class="comment">//读取关键码      </span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">setKey</span> <span class="params">(K x)</span> </span>&#123; key = x; &#125;     <span class="comment">//修改关键码</span></span><br><span class="line">  &#125;;  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>, <span class="title">class</span> <span class="title">K</span> &gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">dataList</span> &#123;</span>  <span class="comment">//数据表类定义 </span></span><br><span class="line"><span class="keyword">protected</span>:      dataNode&lt;E, K&gt; *Element;    <span class="comment">//数据表存储数组      </span></span><br><span class="line"><span class="keyword">int</span> ArraySize, CurrentSize;  <span class="comment">//数组最大长度和当前长度</span></span><br></pre></td></tr></table></figure>

<p><strong>顺序搜索（Sequential Search）</strong></p>
<p>顺序搜索主要用于在线性表中搜索。 </p>
<p>顺序用各元素的关键码与给定值 x 进行比较 。技巧：把待查关键字key存入表头或表尾（俗称 “哨兵”），这样可以加快执行速度。</p>
<p><strong>顺序查找 （线性查找）</strong> </p>
<p>基本思想：从线性表的一端向另一端逐个将关键码与 给定值进行比较，若相等，则查找成功，给出该记录 在表中的位置；若整个表检测完仍未找到与给定值相 等的关键码，则查找失败，给出失败信息。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顺序查找 （线性查找） </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqSearch1</span><span class="params">(<span class="keyword">int</span> r[ ], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//数组r[1] ~ r[n]存放查找集合 </span></span></span><br><span class="line"><span class="function"></span>&#123;        </span><br><span class="line">i = n;     </span><br><span class="line"><span class="keyword">while</span> (i&gt;<span class="number">0</span> &amp;&amp;r[i] != k)        </span><br><span class="line">i--;     </span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>改进的顺序查找</strong> </p>
<p>基本思想：设置“哨兵”。哨兵就是待查值，将它放 在查找方向的尽头处，免去了在查找过程中每一次比 较后都要判断查找位置是否越界，从而提高查找速度 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//改进的顺序查找 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqSearch2</span><span class="params">(<span class="keyword">int</span> r[ ], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span>  </span></span><br><span class="line"><span class="function"><span class="comment">//数组r[1] ~ r[n]存放查找集合 </span></span></span><br><span class="line"><span class="function"></span>&#123;       </span><br><span class="line">r[<span class="number">0</span>] = k; </span><br><span class="line">i = n;      </span><br><span class="line"><span class="keyword">while</span> (r[i] != k)         </span><br><span class="line">i--;      </span><br><span class="line"><span class="keyword">return</span> i; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ASL=O(n) </p>
<p><strong>顺序查找的缺点：</strong> </p>
<p>平均查找长度较大，特别是当待查找集合中元素较多 时，查找效率较低。 </p>
<p><strong>顺序查找的优点</strong>：</p>
<p>算法简单而且使用面广。 </p>
<p>对表中记录的存储没有任何要求，顺序存储和链接 存储均可；</p>
<p>对表中记录的有序性也没有要求，无论记录是否按 关键码有序均可。 </p>
<p><strong>基于有序顺序表的折半搜索</strong> </p>
<p>哨兵法当N很大时，搜索的效率很低。</p>
<p>如果把顺序表的元素按其关键码从小到大 排列，则可以采取效率更高的搜索算法。 </p>
<p><strong>折半搜索</strong></p>
<p>使用条件： </p>
<p>线性表中的记录必须按关键码有序； </p>
<p>必须采用顺序存储。 </p>
<p>基本思想：</p>
<p>折半搜索时, 先求位于搜索区间正中的对 象的下标mid，用其关键码与给定值x比较: </p>
<p>Element[mid].key == x，搜索成功； </p>
<p>Element[mid].key &gt; x，把搜索区间缩小到表的前半部分，继续折半搜索； </p>
<p>Element[mid].key &lt; x，把搜索区间缩小     到表的后半部分，继续折半搜索。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//折半查找——非递归算法 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinSearch1</span><span class="params">(<span class="keyword">int</span> r[ ], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//数组r[1] ~ r[n]存放查找集合     </span></span><br><span class="line">low = <span class="number">1</span>; high = n;     </span><br><span class="line"><span class="keyword">while</span> (low &lt;= high)                        </span><br><span class="line">&#123;        </span><br><span class="line">mid = (low + high) / <span class="number">2</span>;                    </span><br><span class="line"><span class="keyword">if</span> (k &lt; r[mid])  high = mid - <span class="number">1</span>;        </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (k &gt; r[mid])  low = mid + <span class="number">1</span>;                </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> mid;     </span><br><span class="line">&#125;     </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//折半查找——递归算法 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinSearch2</span><span class="params">(<span class="keyword">int</span> r[ ], <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//数组r[1] ~ r[n]存放查找集合     </span></span><br><span class="line"><span class="keyword">if</span> (low &gt; high) <span class="keyword">return</span> <span class="number">0</span>;       </span><br><span class="line"><span class="keyword">else</span> &#123;        </span><br><span class="line">mid = (low + high) / <span class="number">2</span>;       </span><br><span class="line"><span class="keyword">if</span> (k &lt; r[mid])            </span><br><span class="line"><span class="keyword">return</span> BinSearch2(r, low, mid<span class="number">-1</span>, k);      </span><br><span class="line"><span class="keyword">else</span>  <span class="keyword">if</span> (k &gt; r[mid])                  </span><br><span class="line"><span class="keyword">return</span> BinSearch2(r, mid+<span class="number">1</span>, high, k);              </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> mid;    </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>折半搜索性能分析</strong> </p>
<p>若设 n = 2h-1，则描述折半搜索的判定树是 高度为 h的满二叉树。              </p>
<p>n=2h -1, h = log（2） ｜ (n+1) ︱。<br> 搜索成功：在表中查找任一记录的过程，即是折半查 找判定树中从根结点到该记录结点的路径，和给定值 的比较次数等于该记录结点在树中的层数。<br>搜索不成功：查找失败的过程就是走了一条从根结 点到外部结点的路径，和给定值进行的关键码的比 较次数等于该路径上内部结点的个数。 </p>
<p>ASLsucc=log（2）（n+1）-1</p>
<p><strong>动态查找表</strong> </p>
<p>特点：表结构在查找过程中动态生成。</p>
<p>要求：对于给定值key,若表中存在其关键字等于 key的记录，则查找成功返回； 否则插入或删除关键字等于key的记录。</p>
<p> 典型的动态表———二叉搜索树(二叉排序树) </p>
<h2 id="树表的搜索技术"><a href="#树表的搜索技术" class="headerlink" title="树表的搜索技术"></a>树表的搜索技术</h2><p><strong>二叉搜索树 ( Binary Search Tree )</strong> </p>
<p><strong>定义</strong>          </p>
<p>二叉搜索树或者是一棵空树，或者是具 有下列性质的二叉树： </p>
<p>所有结点的关键码互不相同。 </p>
<p>左子树（如果非空）上所有结点的关键 码都小于根结点的关键码。 </p>
<p>右子树（如果非空）上所有结点的关键 码都大于根结点的关键码。 </p>
<p>左子树和右子树也是二叉搜索树。 </p>
<p><strong>二叉搜索树例</strong></p>
<p>结点左子树上所 有关键码小于结 点关键码；</p>
<p>右子树上所有关 键码大于结点关 键码； </p>
<p>如果对一棵二叉搜索树进行中序遍历，可以按从小到大 的顺序，将各结点关键码排列起来，所以也称二叉搜索 树为二叉排序树。 </p>
<p>二叉搜索树的类定义用二叉链表作为它的存储表示，许多 操作的实现与二叉树类似。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>, <span class="title">class</span> <span class="title">K</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">BSTNode</span>  &#123;</span>       <span class="comment">//二叉树结点类     </span></span><br><span class="line">E data;        <span class="comment">//数据域     </span></span><br><span class="line">BSTNode&lt;E, K&gt; *left, *right;  <span class="comment">//左子女和右子女 </span></span><br><span class="line">BSTNode() &#123; left = <span class="literal">NULL</span>; right = <span class="literal">NULL</span>; &#125;     </span><br><span class="line">BSTNode (<span class="keyword">const</span> E d, BSTNode&lt;E, K&gt; *L = <span class="literal">NULL</span>, BSTNode&lt;E, K&gt; *R = <span class="literal">NULL</span>)   &#123; data = d; left = L; right = R;&#125; </span><br><span class="line">～BSTNode() &#123;&#125;    <span class="comment">//析构函数    </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setData</span> <span class="params">(E d)</span> </span>&#123; data = d; &#125; <span class="comment">//修改 </span></span><br><span class="line"><span class="function">E <span class="title">getData</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data; &#125;  <span class="comment">//提取     </span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> E&amp; x)  <span class="comment">//重载：判小于         </span></span><br><span class="line">&#123; <span class="keyword">return</span> data.key &lt; x.key; &#125;   </span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> E&amp; x)  <span class="comment">//重载：判大于         </span></span><br><span class="line">&#123; <span class="keyword">return</span> data.key &gt; x.key; &#125;     </span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> E&amp; x)  <span class="comment">//重载：判等于         </span></span><br><span class="line">&#123; <span class="keyword">return</span> data.key == x.key; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>, <span class="title">class</span> <span class="title">K</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">BST</span> &#123;</span>      <span class="comment">//二叉搜索树类定义 </span></span><br><span class="line"><span class="keyword">private</span>:     </span><br><span class="line">BSTNode&lt;E, K&gt; *root; <span class="comment">//根指针    </span></span><br><span class="line">K RefValue;    <span class="comment">//输入停止标志 </span></span><br><span class="line"><span class="keyword">public</span>:     </span><br><span class="line">BST() &#123; root = <span class="literal">NULL</span>; &#125;   <span class="comment">//构造函数     </span></span><br><span class="line">BST(K value);     <span class="comment">//构造函数     </span></span><br><span class="line">～BST() &#123;&#125;;     <span class="comment">//析构函数 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Search</span> <span class="params">(<span class="keyword">const</span> K x)</span> <span class="keyword">const</span> <span class="comment">//搜索          </span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> Search(x,root) != <span class="literal">NULL</span>; &#125;     </span><br><span class="line">BST&lt;E, K&gt;&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> BST&lt;E, K&gt;&amp; R);           <span class="comment">//重载：赋值     </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeEmpty</span><span class="params">()</span>    <span class="comment">//置空         </span></span></span><br><span class="line"><span class="function"></span>&#123; makeEmpty (root); root = <span class="literal">NULL</span>;&#125;     </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintTree</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; PrintTree (root); &#125;    <span class="comment">//输出    </span></span><br><span class="line"><span class="function">E <span class="title">Min</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Min(root)-&gt;data; &#125;  <span class="comment">//求最小 </span></span><br><span class="line"><span class="function">E <span class="title">Max</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Max(root)-&gt;data; &#125;  <span class="comment">//求最大 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">const</span> E&amp; e1)</span>                <span class="comment">//插入新元素         </span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> Insert(e1, root);&#125; </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Remove</span> <span class="params">(<span class="keyword">const</span> K x)</span> </span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> Remove(x, root);&#125;    <span class="comment">//删除含x的结点</span></span><br><span class="line"><span class="keyword">private</span>:     </span><br><span class="line">BSTNode&lt;E, K&gt; * Search (const K x, BSTNode&lt;E, K&gt; *ptr);  //递归：搜索  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeEmpty</span> <span class="params">(BSTNode&lt;E, K&gt; *&amp; ptr)</span></span>;      <span class="comment">//递归：置空     </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintTree</span> <span class="params">(BSTNode&lt;E, K&gt; *ptr)</span> <span class="keyword">const</span></span>;      <span class="comment">//递归：打印         </span></span><br><span class="line">BSTNode&lt;E, K&gt; * (<span class="keyword">const</span> BSTNode&lt;E, K&gt; *ptr); <span class="comment">//递归：复制    </span></span><br><span class="line">BSTNode&lt;E, K&gt;* Min (BSTNode&lt;E, K&gt;* ptr); //递归：求最小    </span><br><span class="line">BSTNode&lt;E, K&gt;* Max (BSTNode&lt;E, K&gt;* ptr);     //递归：求最大    </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span> <span class="params">(<span class="keyword">const</span> E&amp; e1, BSTNode&lt;E, K&gt;*&amp; ptr)</span></span>;     <span class="comment">//递归：插入     </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Remove</span> <span class="params">(<span class="keyword">const</span> K x, BSTNode&lt;E, K&gt;*&amp; ptr)</span></span>;     <span class="comment">//递归：删除 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>二叉搜索树的搜索算法</strong> </p>
<p>在二叉搜索树上进行搜索，是一个从根结点开始，递 归进行比较判等的过程。 </p>
<p>假设想要在二叉搜索树中搜索关键码为 x 的元素，搜 索过程从根结点开始。 </p>
<p>如果根指针为NULL，则搜索不成功；否则用给定值 x 与根结点的关键码进行比较： </p>
<p>若给定值等于根结点关键码，则搜索成功 </p>
<p>若小于根结点的关键码，则搜索左子树； </p>
<p>否则。递归搜索根结点的右子树。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>, <span class="title">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">BSTNode</span>&lt;E, K&gt;* <span class="title">BST</span>&lt;E, K&gt;:</span>: Search (<span class="keyword">const</span> K x, BSTNode&lt;E, K&gt; *ptr) </span><br><span class="line">&#123; <span class="comment">//私有递归函数：在以ptr为根的二叉搜索树中搜 //索含x的结点。若找到，则函数返回该结点的 </span></span><br><span class="line"><span class="comment">//地址，否则函数返回NULL值。     </span></span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;      </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x &lt; ptr-&gt;data) <span class="keyword">return</span> Search(x, ptr-&gt;left);     </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x &gt; ptr-&gt;data) <span class="keyword">return</span> Search(x, ptr-&gt;right);     </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> ptr;    <span class="comment">//搜索成功 </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>, <span class="title">class</span> <span class="title">K</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">BSTNode</span>&lt;E, K&gt;* <span class="title">BST</span>&lt;E, K&gt;:</span>: Search (<span class="keyword">const</span> K x, BSTNode&lt;E, K&gt; *ptr) &#123; </span><br><span class="line"><span class="comment">//非递归函数：作为对比，在当前以ptr为根的二 </span></span><br><span class="line"><span class="comment">//叉搜索树中搜索含x的结点。若找到，则函数返 </span></span><br><span class="line"><span class="comment">//回该结点的地址，否则函数返回NULL值。   </span></span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;     </span><br><span class="line">BSTNode&lt;E, K&gt;* temp = ptr;    </span><br><span class="line"><span class="keyword">while</span> (temp != <span class="literal">NULL</span>) </span><br><span class="line">&#123;       </span><br><span class="line"><span class="keyword">if</span> (x == temp-&gt;data) <span class="keyword">return</span> temp;        </span><br><span class="line"><span class="keyword">if</span> (x &lt; temp-&gt;data) temp = temp-&gt;left; </span><br><span class="line"><span class="keyword">else</span> temp = temp-&gt;right;     </span><br><span class="line">&#125;     </span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>搜索过程是从根结点开始，沿某条路径自 上而下逐层比较判等的过程。</p>
<p>搜索成功，搜索指针将停留在树上某个结 点；</p>
<p>搜索不成功，搜索指针将走到树上某 个结点的空子树。</p>
<p>设树的高度为h，最多比较次数不超过h。 </p>
<p><strong>二叉搜索树的插入算法</strong> </p>
<p>为了向二叉搜索树中插入一个新元素，必须 先检查这个元素是否在树中已经存在。 </p>
<p>在插入之前，先使用搜索算法在树中检查要 插入元素有还是没有。</p>
<p>如果搜索成功，说明树中已经有这个元素， 不再插入；</p>
<p>如果搜索不成功，说明树中原来没有关键 码等于给定值的结点，把新元素加到搜索 操作停止的地方。  </p>
<p><strong>二叉搜索树的插入</strong> </p>
<p>每次结点的插入，都要 从根结点出发搜索插入 位置，然后把新结点作为叶结点插入。 </p>
<p>利用二叉搜索树的插入算法，可以很方 便地建立二叉搜索树。   </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>, <span class="title">class</span> <span class="title">K</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">BST</span>&lt;E, K&gt;:</span>:Insert (<span class="keyword">const</span> E&amp; e1,   BSTNode&lt;E, K&gt; *&amp; ptr) </span><br><span class="line">&#123;   <span class="comment">//注意参数形式     </span></span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) </span><br><span class="line">&#123;    <span class="comment">//新结点作为叶结点插入         </span></span><br><span class="line">ptr = <span class="keyword">new</span> BstNode&lt;E, K&gt;(e1);   <span class="comment">//创建新结点         </span></span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">NULL</span>)&#123; <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Out of space"</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="built_in">exit</span>(<span class="number">1</span>); &#125;      </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;        </span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (e1 &lt; ptr-&gt;data) <span class="keyword">return</span> Insert (e1, ptr-&gt;left);      </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (e1 &gt; ptr-&gt;data) <span class="keyword">return</span> Insert (e1, ptr-&gt;right);    </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//x已在树中,不再插入 </span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>, <span class="title">class</span> <span class="title">K</span>&gt; <span class="title">BST</span>&lt;E, K&gt;:</span>:BST (K value) </span><br><span class="line">&#123; <span class="comment">//输入一个元素序列, 建立一棵二叉搜索树     </span></span><br><span class="line">    E x;       </span><br><span class="line">    root = <span class="literal">NULL</span>;  RefValue = value;      <span class="comment">//置空树    </span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;          <span class="comment">//输入数据     </span></span><br><span class="line">    <span class="keyword">while</span> ( x.key != RefValue) &#123;    <span class="comment">//RefValue是一个输入结束标志         </span></span><br><span class="line">        Insert (x, root);  <span class="built_in">cin</span> &gt;&gt; x;   <span class="comment">//插入，再输入数据     </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉搜索树插入的非递归方法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Binode</span></span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">int</span> data; </span><br><span class="line">Binode *l, *r; </span><br><span class="line">&#125;Binode,*Bitree; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Bitree &amp; t, <span class="keyword">int</span> i)</span></span>&#123;      </span><br><span class="line">Bitree  p =t, parent;       </span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;   </span><br><span class="line"><span class="keyword">if</span> (i &gt; p-&gt;data)&#123; parent=p;p = p-&gt;r;&#125;  </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i &lt; p-&gt;data) &#123;parent=p;p = p-&gt;l;&#125;   </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i == p-&gt;data)  <span class="keyword">return</span>;  &#125;         </span><br><span class="line">p=<span class="keyword">new</span> Binode;  </span><br><span class="line">p-&gt;data = i; </span><br><span class="line">p-&gt;l = <span class="literal">NULL</span>;   </span><br><span class="line">p-&gt;r = <span class="literal">NULL</span>; </span><br><span class="line"><span class="keyword">if</span>(t==<span class="literal">NULL</span>) t=p;   </span><br><span class="line"><span class="keyword">else</span>            </span><br><span class="line"><span class="keyword">if</span>(parent-&gt;data&lt;i) parent-&gt;r= p;          </span><br><span class="line"><span class="keyword">else</span> parent-&gt;l=p; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line"> </span><br><span class="line"> Bitree t = <span class="literal">NULL</span>; </span><br><span class="line"> <span class="keyword">int</span> n, k, i;  </span><br><span class="line"> <span class="built_in">cin</span> &gt;&gt; n&gt;&gt; k; </span><br><span class="line"><span class="keyword">while</span> (n--)</span><br><span class="line">&#123;   <span class="built_in">cin</span> &gt;&gt; i; </span><br><span class="line">    insert(t, i);   </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" is inserted"</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二叉搜索树的删除</strong> </p>
<p>在二叉排序树上删除某个结点之后，仍然保持二叉排 序树的特性。 </p>
<p>分三种情况讨论： </p>
<p>被删除的结点是叶子； 操作：将双亲结点中相应指针域的值改为空。 </p>
<p>被删除的结点只有左子树或者只有右子树； 操作：将双亲结点的相应指针域的值指向被删除 结点的左子树（或右子树）。 </p>
<p>被删除的结点既有左子树，也有右子树。 操作：被删结点左、右子树都不为空，以其左子树中的最大值结点（或右子树中的最小 值结点）替代之，再来处理这个结点的删除问题。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>, <span class="title">class</span> <span class="title">K</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">BST</span>&lt;E, K&gt;:</span>:Remove (<span class="keyword">const</span> K x, BstNode&lt;E, K&gt; *&amp; ptr) </span><br><span class="line">&#123; <span class="comment">//在以 ptr 为根的二叉搜索树中删除含 x 的结点    </span></span><br><span class="line">BstNode&lt;E, K&gt; *temp;     </span><br><span class="line"><span class="keyword">if</span> (ptr != <span class="literal">NULL</span>) &#123;          </span><br><span class="line"><span class="keyword">if</span> (x &lt; ptr-&gt;data) </span><br><span class="line"><span class="keyword">return</span> Remove (x, ptr-&gt;left);      <span class="comment">//在左子树中执行删除       </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x &gt; ptr-&gt;data) </span><br><span class="line"><span class="keyword">return</span>  Remove (x, ptr-&gt;right);        <span class="comment">//在右子树中执行删除 </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ptr-&gt;left != <span class="literal">NULL</span> &amp;&amp; ptr-&gt;right != <span class="literal">NULL</span>) </span><br><span class="line"> &#123; <span class="comment">//ptr指示关键码为x的结点，它有两个子女              </span></span><br><span class="line"> temp = ptr-&gt;right;  <span class="comment">//到右子树搜寻中序下第一个结点             </span></span><br><span class="line"> <span class="keyword">while</span> (temp-&gt;left != <span class="literal">NULL</span>)                   </span><br><span class="line"> temp = temp-&gt;left;              </span><br><span class="line"> ptr-&gt;data = temp-&gt;data;           <span class="comment">//用该结点数据代替根结点数据      </span></span><br><span class="line"> <span class="keyword">return</span> Remove (ptr-&gt;data, ptr-&gt;right);        </span><br><span class="line"> &#125;      </span><br><span class="line"> <span class="keyword">else</span> &#123; <span class="comment">//ptr指示关键码为x的结点有一个子女 </span></span><br><span class="line"> temp = ptr;     </span><br><span class="line"> <span class="keyword">if</span> (ptr-&gt;left == <span class="literal">NULL</span>) ptr = ptr-&gt;right;             </span><br><span class="line"> <span class="keyword">else</span> ptr = ptr-&gt;left;             </span><br><span class="line"> <span class="keyword">delete</span> temp;             </span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>;        </span><br><span class="line"> &#125; </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>注意在删除算法参数表引用型指针参数的使用</p>
<p><strong>二叉搜索树性能分析</strong></p>
<p>对于有 n 个关键码的集合，其关键码有 n! 种 不同排列，可构成不同二叉搜索树有 ( 1/(n+1) )*C 2n,n</p>
<p>同样 3 个数据{ 1, 2, 3 }，输入顺序不同，建立 起来的二叉搜索树的形态也不同。这直接影响 到二叉搜索树的搜索性能。 </p>
<p>如果输入序列选得不好，会建立起一棵单支树， 使得二叉搜索树的高度达到最大。</p>
<p>在二叉搜索树中加入外结点，形成判定树。外 结点表示失败结点，内结点表示搜索树中已有 的数据。 </p>
<p>这样的判定树即为扩充的二叉搜索树。 </p>
<p>一般把平均搜索长度达到最小的扩充的二叉搜 索树称作最优二叉搜索树。 </p>
<p>在相等搜索概率的情形下，所有内部、外部结 点的搜索概率都相等，视它们的权值都为 1。 同时，第 k 层有 2^(k-1)个结点，k = 1, 2, … 。则 有 n 个内部结点的扩充二叉搜索树的内部路径 长度 I 至少等于序列  </p>
<p>0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, … 的前 n 项的和。 </p>
<p> 因此，最优二叉搜索树的搜索成功的平均搜索 长度和搜索不成功的平均搜索长度分别为: </p>
<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200617102405760-882342916.png" alt=""></p>
<p>(2) 不相等搜索概率的情形 </p>
<p>不相等搜索概率情形下的最优二叉搜索树可能不同于完全二叉树的形态。考虑在不相等搜索概率情形下如何构造最优二叉搜索树。要构造最优二叉搜索树，必须先构造它的左子树和右子树，它们也是最优二叉搜索树。</p>
<p>构造最优二叉搜索树的方法就是自底向上逐步构造的方法。</p>
<p><strong>构造的步骤</strong></p>
<p>第一步，构造只有一个内部结点的最优搜索树：T[0] [1]，T[1] [2]，…，T[n-1] [n]。<br>在T[i-1] [i] (1  i  n) 中只包含关键码 key[i]。其代价分别是 C[i-1] [i] = W[i-1] [i]。另外设立一 个数组 R[0..n] [0..n] 存放各最优二叉搜索树的根。R[0] [1] = 1, R[1] [2] = 2, … , R[n-1] [n] = n。<br>第二步, 构造有两个内部结点的最优二叉搜索树：T[0] [2], T[1] [3], …, T[n-2] [n]。在T[i-2] [i] 中包含两个关键码 { key[i-1], key[i] }。其代价取分别以 key[i-1], key[i] 做根时计算出的 C[i-2] [i] 中的小者。</p>
<p>第三步，第四步，…，构造有 3 个内部结点，有 4 个内部结点，… 的最优二叉搜索树。<br>最后构造出包含有 n 个内部结点的最优二叉搜索树。对于这样的最优二叉搜索树，若设根为 k，则根 k 的值存于 R[0] [n] 中，其代价存于 C[0] [n] 中，左子树的根存于 R[0] [k-1] 中，右子树的根存于 R[k] [n] 中。</p>
<h2 id="散列表的搜索技术"><a href="#散列表的搜索技术" class="headerlink" title="散列表的搜索技术"></a>散列表的搜索技术</h2><p><strong>具体内容见第六章笔记</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线性探查法的搜索算法，函数返回找到位置。</span></span><br><span class="line"><span class="comment">//若返回负数可能是空位，若为-TableSize则失败。</span></span><br><span class="line">Find ( <span class="keyword">const</span> Type &amp; x ) &#123;</span><br><span class="line"><span class="keyword">int</span> i =  FindPos ( x ),  j = i;</span><br><span class="line">   <span class="keyword">while</span> ( ht[j].info != Empty &amp;&amp; ht[j].Element != x )&#123;</span><br><span class="line">       j = ( j + <span class="number">1</span> ) % TableSize;</span><br><span class="line">       <span class="keyword">if</span> ( j == i ) <span class="keyword">return</span> -TableSize;</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">if</span> ( ht[j].info == Active ) <span class="keyword">return</span> j;</span><br><span class="line">   <span class="keyword">else</span> -j;					</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线性探查方法容易产生“堆积”，不同探查序列的关键码占据可用的空桶，为寻找某一关键码需要经历不同的探查序列，导致搜索时间增加。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循链搜索的算法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">Type</span> *<span class="title">HashTable</span>&lt;Type&gt;:</span>: Find ( <span class="keyword">const</span> Type &amp; x,)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> j = HashFunc ( x, buckets );</span><br><span class="line">    ListPtr&lt;Type&gt; *p = ht[j];</span><br><span class="line">    <span class="keyword">while</span> ( p != <span class="literal">NULL</span> )</span><br><span class="line">         <span class="keyword">if</span> ( p→key == x ) <span class="keyword">return</span> &amp; p→key;</span><br><span class="line">         <span class="keyword">else</span> p = p→link;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>课内学习</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>对python输入流的简单探索</title>
    <url>/2021/05/24/%E5%AF%B9python%E8%BE%93%E5%85%A5%E6%B5%81%E7%9A%84%E7%AE%80%E5%8D%95%E6%8E%A2%E7%B4%A2/</url>
    <content><![CDATA[<blockquote>
<p>本文首发于<a href="https://blog.csdn.net/weixin_43608722/article/details/104306943" target="_blank" rel="noopener">vito的CSDN博客</a>，经作者同意后转载。</p>
</blockquote>
<hr>
<p>今年的蓝桥杯新增加了python比赛，CCF-CSP认证现在也可以使用python语言，我和身边的一些小伙伴选择了使用pyhton来做算法题。我刚从C/C++转到python有诸多不适，遇到的第一个问题便是python的<strong>输入</strong>问题</p>
<p>我先举一个简单的例子，输入两个整型，用空格隔开,<br>在C++中非常简单实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br></pre></td></tr></table></figure>
<p>C++的输入流<code>&gt;&gt;</code>不仅支持按回车分隔输入，也支持按空格分隔输入<br>刚开始学python的我有了这样先入为主的概念，就写出这样的python的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=input()</span><br><span class="line">b=input()</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<p>这样写是没有语法问题的，运行一下输入 1 2，可是当我输入2后按下了回车键，光标提示我还要继续输入，我下意识再按了下回车，输出，本应该出现在两行的1和2竟然出现在了一行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<img src=https://img-blog.csdnimg.cn/2020021409485921.jpg width='50%'>

<p>修改一下程序,去掉print(b)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>在运行程序，输入1 2，点击运行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>结果不变，显然1、空格、2都赋值给了a<br>为什么会出现这样的结果呢，我这里用help查询一下吧</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(input)</span><br><span class="line">Help on built-<span class="keyword">in</span> function input <span class="keyword">in</span> module builtins:</span><br><span class="line"></span><br><span class="line">input(prompt=<span class="literal">None</span>, /)</span><br><span class="line">    Read a string <span class="keyword">from</span> standard input.  The trailing newline <span class="keyword">is</span> stripped.</span><br><span class="line">    </span><br><span class="line">    The prompt string, <span class="keyword">if</span> given, <span class="keyword">is</span> printed to standard output without a</span><br><span class="line">    trailing newline before reading input.</span><br><span class="line">    </span><br><span class="line">    If the user hits EOF (*nix: Ctrl-D, Windows: Ctrl-Z+Return), <span class="keyword">raise</span> EOFError.</span><br><span class="line">    On *nix systems, readline <span class="keyword">is</span> used <span class="keyword">if</span> available.</span><br></pre></td></tr></table></figure>
<p>Read a <code>string</code> from standard input.  这句话解释得非常清楚啦，input()是读取了一个字符串。也就是说，刚刚我按下空格时，并没有<strong>结束</strong>当前a=input()这一动作，而是继续读取接下来我从键盘上输入的2，所以b就有接收到2了。<br>我在Python Shell上再继续验证一下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=input()</span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line">&gt;&gt;&gt;print(<span class="string">"a="</span>,a,<span class="string">"\na's type is"</span>,type(a))</span><br><span class="line">a= <span class="number">1</span> <span class="number">2</span></span><br><span class="line">a<span class="string">'s type is &lt;class '</span>st<span class="string">r'&gt;</span></span><br></pre></td></tr></table></figure>
<p>python的input()有点像C++的<code>cin.getline()</code>，可以接受带空格的字符串，按回车才会结束当前输入。<br>即使你输入的是整型、浮点型，也会自动转化为字符串</p>
<p>我在<a href="https://pintia.cn/problem-sets/994805260223102976/problems/type/7" target="_blank" rel="noopener">PAT (Basic Level) Practice</a>里找了一个OJ题，来练习一下在OJ遇见此类问题(带空格的输入)应该怎么做</p>
<h4 id="1010-一元多项式求导"><a href="#1010-一元多项式求导" class="headerlink" title="1010 一元多项式求导"></a><center><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805313708867584" target="_blank" rel="noopener">1010 一元多项式求导</a></center></h4><blockquote>
<p>设计函数求一元多项式的导数。（注：x^n  （n为整数）的一阶导数为nx^n−1 。）<br>输入格式:<br>以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以<code>空格</code>分隔。<br>输出格式:<br>以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾<strong>不能有多余空格</strong>。注意“零多项式”的指数和系数都是 0，但是表示为 0 0。<br>输入样例:<br>3 4 -5 2 6 1 -2 0<br>输出样例:<br>12 3 -10 1 6 0</p>
</blockquote>
<p>ok，读完题感觉很简单一道OJ题，可是对于当时刚学了一个周python满脑子是C++的我来说并不容易，光是输入就让我头疼半天。我仔细回想了一下，问题出在于我对于input()赋给变量一个<code>字符串</code>没有清楚的概念</p>
<p>好了，现在我们坚信input()输入的是字符串，接下来就是对字符串的操作了，然而直接对字符进行操作是很生硬的，我首先用<code>split()</code>将其转化为<code>列表</code>，其中再将其字符转化为整型，剩下对列表操作就行云流水了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">st=input()</span><br><span class="line">s=[int(x) <span class="keyword">for</span> x <span class="keyword">in</span> st.split()]</span><br><span class="line">result=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(s),<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">if</span> s[i+<span class="number">1</span>]!=<span class="number">0</span>:</span><br><span class="line">        result.append(str(int(s[i]*s[i+<span class="number">1</span>])))</span><br><span class="line">        result.append(str(s[i+<span class="number">1</span>]<span class="number">-1</span>))</span><br><span class="line"><span class="keyword">if</span> len(result)==<span class="number">0</span>:</span><br><span class="line">    print(<span class="string">'0 0'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">' '</span>.join(result))</span><br></pre></td></tr></table></figure>
<p>其实，当你熟练python,前面两句可以简化为以下代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=[int(x) <span class="keyword">for</span> x <span class="keyword">in</span> input().split()]</span><br></pre></td></tr></table></figure>
<p>input()就是一个字符串，大胆地使用.split()就好了</p>
<p>为了强化input()是字符串这一概念呢，我又准备了一道题</p>
<h4 id="1009-说反话"><a href="#1009-说反话" class="headerlink" title="1009 说反话  "></a><center><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805314941992960" target="_blank" rel="noopener">1009 说反话</a>  </center></h4><blockquote>
<p>给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。<br>输入格式：<br>测试输入包含一个测试用例，在一行内给出总长度不超过 80 的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用 1 个空格分开，输入保证句子末尾没有多余的空格。<br>输出格式：<br>每个测试用例的输出占一行，输出倒序后的句子。<br>输入样例：<br>Hello World Here I Come<br>输出样例：<br>Come I Here World Hello</p>
</blockquote>
<p>经过我的反复修改，最终答案只剩一行代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">' '</span>.join(input().split()[::<span class="number">-1</span>]))</span><br></pre></td></tr></table></figure>
<p>先用<code>split()</code>将input()转化为<code>字符串列表</code>,再使用<code>切片[::-1]</code>逆序,最后在用’ ‘.join()将字符列表转化为<code>字符串</code>输出,这一行代码融合了输入流、输出流、字符串和列表之间的转化，python使用起来确实很流畅<br><img src=https://img-blog.csdnimg.cn/20200214103649856.jpg width='50%'></p>
<hr>
<p>这是Vito的第二篇原创博客，以后我会陆续介绍学习python的一点心得。除了在CSDN上发布博客，我也会在<a href="https://github.com/cumtcssuld/RSP_of_CUMTCS" target="_blank" rel="noopener">矿大计算机学院资源共享计划（Resource Sharing Plan of CUMTCS）</a>这个GitHub资源库里分享我的学习资料和博客</p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>蓝桥杯</tag>
        <tag>基础操作</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据导论期末复习参考</title>
    <url>/2021/05/24/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E5%8F%82%E8%80%83/</url>
    <content><![CDATA[<blockquote>
<p>本文首发于<a href="https://blog.csdn.net/weixin_43608722/article/details/106316387" target="_blank" rel="noopener">vito的CSDN博客</a>，经作者同意后转载。</p>
</blockquote>
<hr>
<h3 id="第1章-大数据概述"><a href="#第1章-大数据概述" class="headerlink" title="第1章 大数据概述"></a>第1章 大数据概述</h3><h4 id="数据类型、数据组织形式、数据的使用"><a href="#数据类型、数据组织形式、数据的使用" class="headerlink" title="数据类型、数据组织形式、数据的使用"></a>数据类型、数据组织形式、数据的使用</h4><h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center"><strong>含义</strong></th>
<th align="center"><strong>本质</strong></th>
<th align="center"><strong>举例</strong></th>
<th align="center"><strong>技术</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>结构化数据</strong></td>
<td align="center">直接可以用传统关系数据库存储和管理的数据</td>
<td align="center">先有结构，后有管理</td>
<td align="center">数字、符号、表格</td>
<td align="center">SQL</td>
</tr>
<tr>
<td align="center"><strong>非结构化数据</strong></td>
<td align="center">无法用传统关系数据库存储和管理的数据</td>
<td align="center">难以发现同一的结构</td>
<td align="center">语音、图像、文本</td>
<td align="center">NoSQL,NewSQL,云技术</td>
</tr>
<tr>
<td align="center"><strong>半结构化数据</strong></td>
<td align="center">经过转换用传统关系数据库存储和管理的数据</td>
<td align="center">先有数据，后有结构</td>
<td align="center">HTML、XML</td>
<td align="center">RDF、OWL</td>
</tr>
</tbody></table>
<h5 id="数据组织形式"><a href="#数据组织形式" class="headerlink" title="数据组织形式"></a>数据组织形式</h5><p>计算机系统中的数据组织形式主要有两种，即文件和数据库。</p>
<ol>
<li><p>文件：计算机系统中的很多数据都是以文件形式存在的，比如一个WORD文件、一个文本文件、一个网页文件、一个图片文件等等。</p>
</li>
<li><p>数据库：计算机系统中另一种非常重要的数据组织形式就是数据库，数据库已经成为计算机软件开发的基础和核心。</p>
</li>
</ol>
<h5 id="数据的使用"><a href="#数据的使用" class="headerlink" title="数据的使用"></a>数据的使用</h5><ul>
<li><p>数据清洗</p>
</li>
<li><p>数据管理</p>
</li>
<li><p>数据分析</p>
</li>
<li><p>信息化浪潮、信息科技为大数据时代提供技术支撑</p>
<ol>
<li>存储设备容量不断增加<ol start="2">
<li>CPU处理能力大幅提升 <ol start="3">
<li>网络带宽不断增加</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h4 id="大数据的概念-4V"><a href="#大数据的概念-4V" class="headerlink" title="大数据的概念(4V)"></a>大数据的概念(4V)</h4><img src=https://img-blog.csdnimg.cn/20200524161358526.png#pic_center width='75%'>

<h4 id="科学研究四种范式"><a href="#科学研究四种范式" class="headerlink" title="科学研究四种范式"></a>科学研究四种范式</h4><ul>
<li><p>实验</p>
</li>
<li><p>理论</p>
</li>
<li><p>计算机</p>
</li>
<li><p>数据</p>
</li>
</ul>
<h3 id="第2章-大数据与云计算、物联网、人工智能"><a href="#第2章-大数据与云计算、物联网、人工智能" class="headerlink" title="第2章 大数据与云计算、物联网、人工智能"></a>第2章 大数据与云计算、物联网、人工智能</h3><h4 id="云计算概念、云计算服务模式和类型"><a href="#云计算概念、云计算服务模式和类型" class="headerlink" title="云计算概念、云计算服务模式和类型"></a>云计算概念、云计算服务模式和类型</h4><h5 id="五个特征"><a href="#五个特征" class="headerlink" title="五个特征"></a>五个特征</h5><ul>
<li><p>宽带接入</p>
</li>
<li><p>弹性架构</p>
</li>
<li><p>可测量服务</p>
</li>
<li><p>按需自服务</p>
</li>
<li><p>虚拟化的资源池</p>
</li>
</ul>
<h5 id="四个部署模型"><a href="#四个部署模型" class="headerlink" title="四个部署模型"></a>四个部署模型</h5><ul>
<li><p>公有云</p>
</li>
<li><p>私有云</p>
</li>
<li><p>混合云</p>
</li>
<li><p>社区云</p>
</li>
</ul>
<h5 id="服务模式"><a href="#服务模式" class="headerlink" title="服务模式"></a>服务模式</h5><p><code>IaaS</code>（Infrastructure as a Service）：基础设施级服务。消费者通过因特网可以从完善的计算机基础设施获得服务。</p>
<p>IaaS通过网络向用户提供计算机（物理机和虚拟机）、存储空间、网络连接、负载均衡和防火墙等基本计算资源；用户在此基础上部署和运行各种软件，包括操作系统和应用程序。例如，通过亚马逊的AWS，用户可以按需定制所要的虚拟主机和块存储等，在线配置和管理这些资源。</p>
<p><code>PaaS</code>（Platform as a Service）：平台级服务。PaaS实际上是指将软件研发的平台作为一种服务，以SaaS的模式提交给用户。因此，PaaS也是SaaS模式的一种应用。但是，PaaS的出现可以加快SaaS的发展，尤其是加快SaaS应用的开发速度。</p>
<p> 平台通常包括操作系统、编程语言的运行环境、数据库和 Web服务器，用户在此平台上部署和运行自己的应用。用户不能管理和控制底层的基础设施，只能控制自己部署的应用。目前常见的PaaS提供商有CloudFoundry、谷歌的GAE等。</p>
<p><code>SaaS</code>（Software as a Service）：软件级服务。它是一种通过因特网提供软件的模式，用户无需购买软件，而是向提供商租用基于Web的软件，来管理企业经营活动，例如邮件服务、数据处理服务、财务管理服务等</p>
<h4 id="大数据系统与云安全、云安全及其关键技术"><a href="#大数据系统与云安全、云安全及其关键技术" class="headerlink" title="大数据系统与云安全、云安全及其关键技术"></a>大数据系统与云安全、云安全及其关键技术</h4><ul>
<li><p>认证授权问题</p>
</li>
<li><p>访问控制问题</p>
</li>
<li><p>操作审计问题</p>
</li>
<li><p>敏感数据保护问题</p>
</li>
<li><p>认证授权问题</p>
</li>
</ul>
<img src=https://img-blog.csdnimg.cn/20200524161430903.png#pic_center width='80%'>



<h4 id="物联网概念、物联网三要素、物联网层次架构"><a href="#物联网概念、物联网三要素、物联网层次架构" class="headerlink" title="物联网概念、物联网三要素、物联网层次架构"></a>物联网概念、物联网三要素、物联网层次架构</h4><img src=https://img-blog.csdnimg.cn/2020052416155132.png#pic_center width='35%'>

<img src=https://img-blog.csdnimg.cn/2020052416161370.png#pic_center width='65%'>



<h4 id="大数据与云计算、物联网的关系"><a href="#大数据与云计算、物联网的关系" class="headerlink" title="大数据与云计算、物联网的关系"></a>大数据与云计算、物联网的关系</h4><img src=https://img-blog.csdnimg.cn/20200524161626127.png#pic_center width='70%'>


<h4 id="人工智能概念、人工智能关键技术"><a href="#人工智能概念、人工智能关键技术" class="headerlink" title="人工智能概念、人工智能关键技术"></a>人工智能概念、人工智能关键技术</h4><p>人工智能（Artificial Intelligence），英文缩写为AI，是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。</p>
<p>关键技术：机器学习、专家系统、知识图谱、计算机视觉、自然语言处理、生物特征识别、人机交互、VR/AR、模式识别</p>
<h4 id="大数据与人工智能的关系"><a href="#大数据与人工智能的关系" class="headerlink" title="大数据与人工智能的关系"></a>大数据与人工智能的关系</h4><ol>
<li>人工智能需要数据来建立其智能，特别是机器学习</li>
<li>大数据技术为人工智能提供了强大的存储能力和计算能力</li>
</ol>
<h3 id="第3章-大数据技术"><a href="#第3章-大数据技术" class="headerlink" title="第3章 大数据技术"></a>第3章 大数据技术</h3><h4 id="大数据技术的不同层面及其功能"><a href="#大数据技术的不同层面及其功能" class="headerlink" title="大数据技术的不同层面及其功能"></a>大数据技术的不同层面及其功能</h4><p><img src="https://img-blog.csdnimg.cn/20200524161638263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYwODcyMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="传统的数据采集与大数据采集的区别"><a href="#传统的数据采集与大数据采集的区别" class="headerlink" title="传统的数据采集与大数据采集的区别"></a>传统的数据采集与大数据采集的区别</h4><p><img src="https://img-blog.csdnimg.cn/20200524161647858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYwODcyMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="互联网爬虫基本架构、爬取策略"><a href="#互联网爬虫基本架构、爬取策略" class="headerlink" title="互联网爬虫基本架构、爬取策略"></a>互联网爬虫基本架构、爬取策略</h4><ol>
<li>将这些URL放入待抓取URL队列；</li>
<li>读取URL，Download对应页面；</li>
<li>解析页面，嗅探新的URL去重加入队列；</li>
<li>Goto step 3</li>
</ol>
<h4 id="ETL概念"><a href="#ETL概念" class="headerlink" title="ETL概念"></a>ETL概念</h4><p><code>ETL</code>(Extract、Transform、load)</p>
<p>ETL是数据获取的重要手段，需要知道具体格式<br><img src=https://img-blog.csdnimg.cn/20200524161759589.png#pic_center width='85%'></p>
<h4 id="数据清洗的主要内容"><a href="#数据清洗的主要内容" class="headerlink" title="数据清洗的主要内容"></a>数据清洗的主要内容</h4><img src=https://img-blog.csdnimg.cn/20200524161717912.png#pic_center width='65%'>


<h4 id="大数据时代的数据存储和管理技术"><a href="#大数据时代的数据存储和管理技术" class="headerlink" title="大数据时代的数据存储和管理技术"></a>大数据时代的数据存储和管理技术</h4><ol>
<li>分布式文件系统</li>
<li>NewSQL和NoSQL数据库</li>
</ol>
<h4 id="数据挖掘和机器学习算法、深度学习概念和应用领域"><a href="#数据挖掘和机器学习算法、深度学习概念和应用领域" class="headerlink" title="数据挖掘和机器学习算法、深度学习概念和应用领域"></a>数据挖掘和机器学习算法、深度学习概念和应用领域</h4><img src=https://img-blog.csdnimg.cn/20200524161724534.png#pic_center width='75%'>

<h4 id="大数据处理分析技术类型及解决的主要问题"><a href="#大数据处理分析技术类型及解决的主要问题" class="headerlink" title="大数据处理分析技术类型及解决的主要问题"></a>大数据处理分析技术类型及解决的主要问题</h4><table>
<thead>
<tr>
<th align="center"><strong>大数据计算模式</strong></th>
<th align="center"><strong>解决问题</strong></th>
<th align="center"><strong>代表产品</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>批处理计算</strong></td>
<td align="center">针对大规模数据的批量处理</td>
<td align="center">MapReduce、Spark等</td>
</tr>
<tr>
<td align="center"><strong>流计算</strong></td>
<td align="center">针对流数据的实时计算</td>
<td align="center">Storm、S4、Flume、Streams、Puma、DStream、Super Mario、银河流数据处理平台等</td>
</tr>
<tr>
<td align="center"><strong>图计算</strong></td>
<td align="center">针对大规模图结构数据的处理</td>
<td align="center">Pregel、GraphX、Giraph、PowerGraph、Hama、GoldenOrb等</td>
</tr>
<tr>
<td align="center"><strong>查询分析计算</strong></td>
<td align="center">大规模数据的存储管理和查询分析</td>
<td align="center">Dremel、Hive、Cassandra、Impala等</td>
</tr>
</tbody></table>
<h4 id="数据可视化概念"><a href="#数据可视化概念" class="headerlink" title="数据可视化概念"></a>数据可视化概念</h4><p>数据可视化是指将大型数据集中的数据以图形图像形式表示，并利用数据分析和开发工具发现其中未知信息的处理过程</p>
<h4 id="数据安全技术"><a href="#数据安全技术" class="headerlink" title="数据安全技术"></a>数据安全技术</h4><ol>
<li>身份认证技术</li>
<li>防火墙技术</li>
<li>访问控制技术</li>
<li>入侵检测技术</li>
<li>加密技术</li>
</ol>
<h3 id="第4、5、6章-大数据应用、大数据安全、大数据思维"><a href="#第4、5、6章-大数据应用、大数据安全、大数据思维" class="headerlink" title="第4、5、6章 大数据应用、大数据安全、大数据思维"></a>第4、5、6章 大数据应用、大数据安全、大数据思维</h3><h4 id="推荐系统、推荐方法、推荐系统"><a href="#推荐系统、推荐方法、推荐系统" class="headerlink" title="推荐系统、推荐方法、推荐系统"></a>推荐系统、推荐方法、推荐系统</h4><p>推荐系统是自动联系用户和物品的一种工具，和搜索引擎相比，推荐系统通过研究用户的兴趣偏好，进行个性化计算。推荐系统可发现用户的兴趣点，帮助用户从海量信息中去发掘自己潜在的需求。<br><img src="https://img-blog.csdnimg.cn/20200524161938953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYwODcyMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src=https://img-blog.csdnimg.cn/20200524161947729.png#pic_center width='75%'></p>
<h4 id="大数据应用领域"><a href="#大数据应用领域" class="headerlink" title="大数据应用领域"></a>大数据应用领域</h4><ol>
<li>互联网领域</li>
<li>生物医学领域</li>
<li>物流领域</li>
<li>城市管理领域</li>
<li>金融领域</li>
<li>汽车领域</li>
<li>零售领域</li>
<li>餐饮领域</li>
<li>电信领域</li>
<li>能源领域</li>
<li>体育和娱乐领域</li>
<li>安全领域</li>
<li>政府领域</li>
</ol>
<h4 id="大数据安全与传统数据安全的不同"><a href="#大数据安全与传统数据安全的不同" class="headerlink" title="大数据安全与传统数据安全的不同"></a>大数据安全与传统数据安全的不同</h4><ol>
<li>大数据成为网络攻击的显著目标</li>
<li>大数据加大隐私泄露风险</li>
<li>大数据技术被应用到攻击手段中</li>
<li>大数据成为高级可持续攻击（APT）的载体</li>
</ol>
<h4 id="大数据思维方式"><a href="#大数据思维方式" class="headerlink" title="大数据思维方式"></a>大数据思维方式</h4><ol>
<li>全样而非抽样</li>
<li>效率而非精确</li>
<li>相关而非因果</li>
<li>以数据为中心</li>
<li>我为人人，人人为我</li>
</ol>
<h3 id="第9章-Hadoop、HDFS、MapReduce、Hive、Spark简介"><a href="#第9章-Hadoop、HDFS、MapReduce、Hive、Spark简介" class="headerlink" title="第9章 Hadoop、HDFS、MapReduce、Hive、Spark简介"></a>第9章 Hadoop、HDFS、MapReduce、Hive、Spark简介</h3><h4 id="Hadoop的特性、项目结构"><a href="#Hadoop的特性、项目结构" class="headerlink" title="Hadoop的特性、项目结构"></a>Hadoop的特性、项目结构</h4><p>特性：</p>
<ul>
<li>高可靠性<ul>
<li>高效性</li>
<li>高可扩展性</li>
<li>高容错性</li>
<li>成本低</li>
<li>运行在Linux平台上</li>
<li>支持多种编程语言</li>
</ul>
</li>
</ul>
<p>项目结构：</p>
<p><img src="https://img-blog.csdnimg.cn/20200524162001284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYwODcyMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<table>
<thead>
<tr>
<th><strong>组件</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>HDFS</strong></td>
<td><strong>分布式文件系统</strong></td>
</tr>
<tr>
<td><strong>MapReduce</strong></td>
<td><strong>分布式并行编程模型</strong></td>
</tr>
<tr>
<td><strong>YARN</strong></td>
<td><strong>资源管理和调度器</strong></td>
</tr>
<tr>
<td><strong>Tez</strong></td>
<td><strong>运行在YARN之上的下一代Hadoop查询处理框架，它会将很多的mr任务分析优化后构建一个有向无环图，保证最高的工作效率</strong></td>
</tr>
<tr>
<td><strong>Hive</strong></td>
<td><strong>Hadoop上的数据仓库</strong></td>
</tr>
<tr>
<td><strong>HBase</strong></td>
<td><strong>Hadoop上的非关系型的分布式数据库</strong></td>
</tr>
<tr>
<td><strong>Pig</strong></td>
<td><strong>一个基于Hadoop的大规模数据分析平台，提供类似SQL的查询语言Pig Latin</strong></td>
</tr>
<tr>
<td><strong>Sqoop</strong></td>
<td><strong>用于在Hadoop与传统数据库之间进行数据传递</strong></td>
</tr>
<tr>
<td><strong>Oozie</strong></td>
<td><strong>Hadoop上的工作流管理系统</strong></td>
</tr>
<tr>
<td><strong>Zookeeper</strong></td>
<td><strong>提供分布式协调一致性服务</strong></td>
</tr>
<tr>
<td><strong>Storm</strong></td>
<td><strong>流计算框架</strong></td>
</tr>
<tr>
<td><strong>Flume</strong></td>
<td><strong>一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的系统</strong></td>
</tr>
<tr>
<td><strong>Ambari</strong></td>
<td><strong>Hadoop快速部署工具，支持Apache Hadoop集群的供应、管理和监控</strong></td>
</tr>
<tr>
<td><strong>Kafka</strong></td>
<td><strong>一种高吞吐量的分布式发布订阅消息系统，可以处理消费者规模的网站中的所有动作流数据</strong></td>
</tr>
<tr>
<td><strong>Spark</strong></td>
<td><strong>类似于**</strong>Hadoop MapReduce<strong>**的通用并行框架</strong></td>
</tr>
</tbody></table>
<h4 id="HDFS相关概念、体系结构、数据存取策略、数据错误与恢复"><a href="#HDFS相关概念、体系结构、数据存取策略、数据错误与恢复" class="headerlink" title="HDFS相关概念、体系结构、数据存取策略、数据错误与恢复"></a>HDFS相关概念、体系结构、数据存取策略、数据错误与恢复</h4><h5 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h5><ul>
<li><p>块</p>
<p>HDFS默认一个块128MB，一个文件被分成多个块，以块作为存储单位。</p>
<pre><code>+ 支持大规模文件存储
+ 简化系统设计
+ 适合数据备份</code></pre></li>
<li><p>NameNode和DataNode</p>
<table>
<thead>
<tr>
<th><strong>NameNode</strong></th>
<th><strong>DataNode</strong></th>
</tr>
</thead>
<tbody><tr>
<td>存储元数据</td>
<td>存储文件内容</td>
</tr>
<tr>
<td>元数据保存在内存中</td>
<td>文件内容保存在磁盘</td>
</tr>
<tr>
<td>保存文件,block,datanode之间的映射关系</td>
<td>维护了block  id和datanode本地文件的映射关系</td>
</tr>
</tbody></table>
<ul>
<li><p>NameNode</p>
<ul>
<li><p>在HDFS中，名称节点（NameNode）负责管理分布式文件系统的命名空间，保存了两个核心的数据结构，即FsImage和EditLog</p>
</li>
<li><p>名称节点记录了每个文件中各个块所在的数据节点的位置信息<br><img src="https://img-blog.csdnimg.cn/20200524162009939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYwODcyMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
</li>
<li><p>FsImage文件</p>
<ul>
<li>FsImage文件包含文件系统中所有目录和文件inode的序列化形式。</li>
<li>FsImage文件没有记录块存储在哪个数据节点。而是由名称节点把这些 映射保留在内存中</li>
</ul>
</li>
<li><p>SecondaryNameNode</p>
<p>第二名称节点是HDFS架构中的一个组成部分，它是用来保存名称节点中对HDFS 元数据信息的备份，并减少名称节点重启的时间。SecondaryNameNode一般是单独运行在一台机器上</p>
</li>
<li><p>数据节点（DataNode）</p>
<ul>
<li><p>数据节点是分布式文件系统HDFS的工作节点，负责数据的存储和读取，会根据</p>
<p>客户端或者是名称节点的调度来进行数据的存储和检索，并且向名称节点定期发</p>
<p>送自己所存储的块的列表</p>
</li>
<li><p>每个数据节点中的数据会被保存在各自节点的本地Linux文件系统中</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="HDFS体系结构"><a href="#HDFS体系结构" class="headerlink" title="HDFS体系结构"></a>HDFS体系结构</h5><p>HDFS采用了主从（Master/Slave）结构模型，一个HDFS集群包括一个名称节点（NameNode）和若干个数据节点（DataNode）。名称节点作为中心服务器，负责管理文件系统的命名空间及客户端对文件的访问。集群中的数据节点一般是一个节点运行一个数据节点进程，负责处理文件系统客户端的读/写请求，在名称节点的统一调度下进行数据块的创建、删除和复制等操作。每个数据节点的数据实际上是保存在本地Linux文件系统中的</p>
<p><img src="https://img-blog.csdnimg.cn/20200524162016813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYwODcyMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="数据存取策略"><a href="#数据存取策略" class="headerlink" title="数据存取策略"></a>数据存取策略</h5><ol>
<li>数据存放<ul>
<li>第一个副本：放置在上传文件的数据节点；如果是集群外提交，则随机挑选一台磁盘不太满、CPU不太忙的节点</li>
<li>第二个副本：放置在与第一个副本不同的机架的节点上</li>
<li>第三个副本：与第一个副本相同机架的其他节点上</li>
<li>更多副本：随机节点</li>
</ul>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200524162039550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYwODcyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ol start="2">
<li>数据读取<ul>
<li>HDFS提供了一个API可以确定一个数据节点所属的机架ID，客户端也可以调用API获取自己所属的机架ID</li>
<li>当客户端读取数据时，从名称节点获得数据块不同副本的存放位置列表，列表中包含了副本所在的数据节点，可以调用API来确定客户端和这些数据节点所属的机架ID，当发现某个数据块副本对应的机架ID和客户端对应的机架ID相同时，就优先选择该 副本读取数据，如果没有发现，就随机选择一个副本读取数据</li>
</ul>
</li>
</ol>
<h5 id="数据错误与恢复"><a href="#数据错误与恢复" class="headerlink" title="数据错误与恢复"></a>数据错误与恢复</h5><ol>
<li><p>名称节点出错</p>
<p>HDFS设置了备份机制，把这些核心文件同步复制到备份服务器SecondaryNameNode上。当名称节点出错时，就可以根据备份服务器SecondaryNameNode中的FsImage和Editlog数据进行恢复。</p>
</li>
<li><p>数据节点出错</p>
<ul>
<li><p>每个数据节点会定期向名称节点发送“心跳”信息，向名称节点报告自己的状态</p>
</li>
<li><p>当数据节点发生故障，或者网络发生断网时，名称节点就无法收到来自一些数据节点的心跳信息，这时，这些数据节点就会被标记为“宕机”，节点上面的所有数据都会被标记为“不可读”，名称节点不会再给它们发送任何I/O请求</p>
</li>
<li><p>这时，有可能出现一种情形，即由于一些数据节点的不可用，会导致一些数据块的副本数量小于冗余因子</p>
</li>
<li><p>名称节点会定期检查这种情况，一旦发现某个数据块的副本数量小于冗余因子，就会启动数据冗余复制，为它生成新的副本</p>
</li>
<li><p>HDFS和其它分布式文件系统的最大区别就是可以调整冗余数据的位置</p>
</li>
</ul>
</li>
<li><p>数据出错</p>
<ol>
<li>网络传输和磁盘错误等因素，都会造成数据错误</li>
</ol>
</li>
</ol>
<ol start="2">
<li>客户端在读取到数据后，会采用md5和sha1对数据块进行校验，以确定读取到正确的数据</li>
</ol>
<ol start="3">
<li>在文件被创建时，客户端就会对每一个文件块进行信息摘录，并把这些信息写入到同一个径的隐藏文件里面</li>
</ol>
<ol start="4">
<li><p>当客户端读取文件的时候，会先读取该信息文件，然后，利用该信息文件对每个读取的数</p>
<ol start="5">
<li>据块进行校验，如果校验出错，客户端就会请求到另外一个数据节点读取该文件块，并且向名称节点报告这个文件块有错误，名称节点会定期检查并且重新复制这个块</li>
</ol>
</li>
</ol>
<h4 id="HDFS如何减轻名称节点的负担"><a href="#HDFS如何减轻名称节点的负担" class="headerlink" title="HDFS如何减轻名称节点的负担"></a>HDFS如何减轻名称节点的负担</h4><p>在客户端需要访问一个文件时,名称节点并不参与数据的传输,而是只将数据节点位置发给客户端,因此实现了一个文件的数据能够在不同的数据节点上实现并发访问,大大提高了数据访问速度并减轻了中心服务器的负担,方便了数据管理。</p>
<h4 id="MapReduce相较于传统并行计算框架的优势"><a href="#MapReduce相较于传统并行计算框架的优势" class="headerlink" title="MapReduce相较于传统并行计算框架的优势"></a>MapReduce相较于传统并行计算框架的优势</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center"><strong>传统并行计算框架</strong></th>
<th align="center"><strong>MapReduce</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">集群架构/容错性</td>
<td align="center">共享式(共享内存/共享存储)，容错性差</td>
<td align="center">非共享式，容错性好</td>
</tr>
<tr>
<td align="center">硬件/价格/扩展性</td>
<td align="center">刀片服务器、高速网、SAN，价格贵，扩展性差</td>
<td align="center">普通PC机，便宜，扩展性好</td>
</tr>
<tr>
<td align="center">编程/学习难度</td>
<td align="center">what-how，难</td>
<td align="center">what，简单</td>
</tr>
<tr>
<td align="center">适用场景</td>
<td align="center">实时、细粒度计算、计算密集型</td>
<td align="center">批处理、非实时、数据密集型</td>
</tr>
</tbody></table>
<h4 id="MapReduce体系结构、应用程序执行过程"><a href="#MapReduce体系结构、应用程序执行过程" class="headerlink" title="MapReduce体系结构、应用程序执行过程"></a>MapReduce体系结构、应用程序执行过程</h4><h5 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h5><p>MapReduce体系结构主要由四个部分组成，分别是：Client、JobTracker、TaskTracker以及Task</p>
<p><img src="https://img-blog.csdnimg.cn/20200524162117333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYwODcyMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p><strong>Client</strong></p>
<ul>
<li>用户编写的MapReduce程序通过Client提交到JobTracker端</li>
<li>用户可通过Client提供的一些接口查看作业运行状态</li>
</ul>
</li>
<li><p><strong>JobTracker</strong></p>
<ul>
<li><p>JobTracker负责资源监控和作业调度</p>
</li>
<li><p>JobTracker 监控所有TaskTracker与Job的健康状况，一旦发现失败，就将相</p>
<p>应的任务转移到其他节点</p>
</li>
<li><p>JobTracker 会跟踪任务的执行进度、资源使用量等信息，并将这些信息告诉任务调度器（TaskScheduler,可插拔，可自定义），而调度器会在资源出现空闲时，选择合适的任务去使用这些资源</p>
</li>
</ul>
</li>
<li><p><strong>TaskTracker</strong></p>
<ul>
<li><p>TaskTracker 会周期性地通过“心跳”将本节点上资源的使用情况和任务的</p>
<p> 运行进度汇报给JobTracker，同时接收JobTracker 发送过来的命令并执行相</p>
<p> 应的操作（如启动新任务、杀死任务等）</p>
</li>
<li><p>TaskTracker 使用”slot（槽）”等量划分本节点上的资源量（CPU、内存等）。</p>
</li>
<li><p>一个Task 获取到一个slot 后才有机会运行，而Hadoop调度器的作用就是将各个TaskTracker上的空闲slot分配给Task使用。slot 分为Map slot 和 Reduce slot 两种，分别供MapTask 和Reduce Task 使用</p>
</li>
</ul>
</li>
<li><p>Task</p>
<p>Task 分为Map Task 和Reduce Task 两种，均由TaskTracker 启动</p>
</li>
</ul>
<h5 id="MapReduce应用程序执行过程"><a href="#MapReduce应用程序执行过程" class="headerlink" title="MapReduce应用程序执行过程"></a>MapReduce应用程序执行过程</h5><p><img src="https://img-blog.csdnimg.cn/20200524162131141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYwODcyMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="数据仓库概念、-Hive特点"><a href="#数据仓库概念、-Hive特点" class="headerlink" title="数据仓库概念、 Hive特点"></a>数据仓库概念、 Hive特点</h4><p><code>数据仓库</code>（Data Warehouse）是一个面向主题的（Subject Oriented）、集成的（Integrated）、相对稳定的（Non-Volatile）、反映历史变化（Time Variant）的数据集合，用于支持管理决策。</p>
<p><img src="https://img-blog.csdnimg.cn/20200524162145725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYwODcyMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>Hive是一个构建于Hadoop顶层的数据仓库工具</p>
</li>
<li><p>支持大规模数据存储、分析，具有良好的可扩展性</p>
</li>
<li><p>某种程度上可以看作是用户编程接口，本身不存储和处理数据</p>
</li>
<li><p>依赖分布式文件系统HDFS存储数据</p>
</li>
<li><p>依赖分布式并行计算模型MapReduce处理数据</p>
</li>
<li><p>定义了简单的类似SQL 的查询语言——HiveQL</p>
</li>
<li><p>用户可以通过编写的HiveQL语句运行MapReduce任务</p>
</li>
<li><p>可以很容易把原来构建在关系数据库上的数据仓库应用程序移植到Hadoop平台上</p>
</li>
<li><p>是一个可以提供有效、合理、直观组织和使用数据的分析工具</p>
</li>
</ul>
<p>Hive具有的特点非常适用于数据仓库</p>
<ul>
<li>采用批处理方式处理海量数据<ul>
<li>Hive需要把HiveQL语句转换成MapReduce任务进行运行</li>
<li>数据仓库存储的是静态数据，对静态数据的分析适合采用批处理方式，不需要快速响应给出结果，而且数据本身也不会频繁变化</li>
</ul>
</li>
<li>提供适合数据仓库操作的工具<ul>
<li>Hive本身提供了一系列对数据进行提取、转换、加载（ETL）的工具，可以存储、查询和分析存储在Hadoop中的大规模数据</li>
<li>这些工具能够很好地满足数据仓库各种应用场景</li>
</ul>
</li>
</ul>
<h4 id="Hive与Hadoop生态系统中其他组件的关系"><a href="#Hive与Hadoop生态系统中其他组件的关系" class="headerlink" title="Hive与Hadoop生态系统中其他组件的关系"></a>Hive与Hadoop生态系统中其他组件的关系</h4><ul>
<li><p>Hive依赖于HDFS存储数据</p>
</li>
<li><p>Hive依赖于MapReduce 处理数据</p>
</li>
<li><p>在某些场景下Pig可以作为Hive的替代工具</p>
</li>
<li><p>HBase 提供数据的实时访问</p>
<img src=https://img-blog.csdnimg.cn/20200524162152774.png#pic_center width='50%'>


</li>
</ul>
<h4 id="Spark特点、Spark基本概念"><a href="#Spark特点、Spark基本概念" class="headerlink" title="Spark特点、Spark基本概念"></a>Spark特点、Spark基本概念</h4><ul>
<li><p><strong>运行速度快</strong>：使用DAG执行引擎以支持循环数据流与内存计算</p>
</li>
<li><p><strong>容易使用</strong>：支持使用Scala、Java、Python和R语言进行编程，可以通过Spark Shell进行交互式编程</p>
</li>
<li><p><strong>通用性</strong>：Spark提供了完整而强大的技术栈，包括SQL查询、流式计算、机器学习和图算法组件</p>
</li>
<li><p><strong>运行模式多样</strong>：可运行于独立的集群模式中，可运行于Hadoop中，并且可以访问HDFS、HBase、Hive等多种数据源</p>
</li>
</ul>
<h4 id="Spark与Hadoop的对比、Spark-RDD"><a href="#Spark与Hadoop的对比、Spark-RDD" class="headerlink" title="Spark与Hadoop的对比、Spark RDD"></a>Spark与Hadoop的对比、Spark RDD</h4><p>Hadoop存在如下一些缺点：</p>
<ul>
<li><p>表达能力有限</p>
</li>
<li><p>磁盘IO开销大</p>
</li>
<li><p>延迟高</p>
</li>
<li><p>任务之间的衔接涉及IO开销</p>
</li>
<li><p>在前一个任务执行完成之前，其他任务就无法开始，难以胜任复杂、多阶段的计算任务</p>
</li>
</ul>
<p>相比于Hadoop MapReduce，Spark主要具有如下优点：</p>
<ul>
<li><p>Spark的计算模式也属于MapReduce，但不局限于Map和Reduce操作，还提供了多 种数据集操作类型，编程模型比Hadoop MapReduce更灵活</p>
</li>
<li><p>Spark提供了内存计算，可将中间结果放到内存中，对于迭代运算效率更高</p>
</li>
<li><p>Spark基于DAG的任务调度执行机制，要优于Hadoop MapReduce的迭代执行机制</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>MapReduce</strong></th>
<th align="center"><strong>Spark</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">数据存储结构：磁盘HDFS文件系统的split</td>
<td align="center">使用内存构建弹性分布式数据集RDD  对数据进行运算和cache</td>
</tr>
<tr>
<td align="center">编程范式：Map  + Reduce</td>
<td align="center">DAG:  Transformation + Action</td>
</tr>
<tr>
<td align="center">计算中间结果落到磁盘，IO代价大</td>
<td align="center">计算中间结果在内存中维护  存取速度比磁盘高几个数量级</td>
</tr>
<tr>
<td align="center">Task以进程的方式维护，需要数秒时间才能启动任务</td>
<td align="center">Task以线程的方式维护  对于小数据集读取能够达到亚秒级的延迟</td>
</tr>
</tbody></table>
<h5 id="Spark-RDD"><a href="#Spark-RDD" class="headerlink" title="Spark RDD"></a>Spark RDD</h5><p>RDD提供了一个抽象的数据架构，我们不必 担心底层数据的分布式特性，只需将具体的应用逻辑表达为一系列转换处理，不同RDD之间的转换操作形成依赖关系，可以实现管道化，避免中间数据存储</p>
<p>RDD典型的执行过程如下：</p>
<ul>
<li><p>RDD读入外部数据源进行创建</p>
</li>
<li><p>RDD经过一系列的转换（Transformation）操作，每一次都会产生不同的RDD，供给下一个转换操作使用</p>
</li>
<li><p>最后一个RDD经过“动作”操作进行转换，并输出到外部数据源</p>
</li>
</ul>
<p>RDD特性</p>
<ul>
<li><p>高效的容错性</p>
<p>现有容错机制：数据复制或者记录日志</p>
<p>RDD：血缘关系、重新计算丢失分区、无需回滚系统、重算过程在不同</p>
<p> 节点之间并行、只记录粗粒度的操作</p>
</li>
<li><p>中间结果持久化到内存，数据在内存中的多个RDD操作之间进行传递，避免  了不必要的读写磁盘开销</p>
</li>
</ul>
<p>担心底层数据的分布式特性，只需将具体的应用逻辑表达为一系列转换处理，不同RDD之间的转换操作形成依赖关系，可以实现管道化，避免中间数据存储</p>
<p>RDD典型的执行过程如下：</p>
<ul>
<li><p>RDD读入外部数据源进行创建</p>
</li>
<li><p>RDD经过一系列的转换（Transformation）操作，每一次都会产生不同的RDD，供给下一个转换操作使用</p>
</li>
<li><p>最后一个RDD经过“动作”操作进行转换，并输出到外部数据源<br><img src="https://img-blog.csdnimg.cn/20200524162204941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYwODcyMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
<p>RDD特性</p>
<ul>
<li><p>高效的容错性</p>
<p>现有容错机制：数据复制或者记录日志</p>
<p>RDD：血缘关系、重新计算丢失分区、无需回滚系统、重算过程在不同</p>
<p> 节点之间并行、只记录粗粒度的操作</p>
</li>
<li><p>中间结果持久化到内存，数据在内存中的多个RDD操作之间进行传递，避免  了不必要的读写磁盘开销</p>
</li>
</ul>
]]></content>
      <categories>
        <category>课内学习</category>
        <category>大数据导论</category>
      </categories>
      <tags>
        <tag>大数据导论</tag>
        <tag>期末复习</tag>
      </tags>
  </entry>
  <entry>
    <title>吐血推荐，B站最强学习资源汇总（数据科学，机器学习，python）(转)</title>
    <url>/2020/06/02/%E5%90%90%E8%A1%80%E6%8E%A8%E8%8D%90%EF%BC%8CB%E7%AB%99%E6%9C%80%E5%BC%BA%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB%EF%BC%88%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%EF%BC%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%8CPython%EF%BC%89/</url>
    <content><![CDATA[<h1 id="吐血推荐，B站最强学习资源汇总（数据科学，机器学习，Python）"><a href="#吐血推荐，B站最强学习资源汇总（数据科学，机器学习，Python）" class="headerlink" title="吐血推荐，B站最强学习资源汇总（数据科学，机器学习，Python）"></a>吐血推荐，B站最强学习资源汇总（数据科学，机器学习，Python）</h1><blockquote>
<p>导读：本文整理一波B站上关于数据科学、人工智能领域的学习资料和值得关注的up主，欢迎大家收藏转发哦～</p>
</blockquote>
<p>来源：数据派THU（ID：DatapiTHU），编辑：于腾凯，校对：洪舒越</p>
<p>经过这几个月的居家隔离，想必大多数同学都开始习惯通过线上的方式开展学习了，在线教育领域也因此迎来了一波爆发，竞争异常激烈，既有知名平台如MOOC、学堂在线、网易云课堂等，也有不少初创新星。</p>
<p>但要说最受年轻人欢迎的学习资源网站，应该非B站莫属。该平台资源之丰富不用多说，并且全程无广告，很多网友都表示自己通过B站学会了很多技能，比如Python、数据库、Photoshop、英语考级、日语考级等。总之，一个B站就足够解决绝大多数问题。</p>
<h2 id="01-AI入门了解"><a href="#01-AI入门了解" class="headerlink" title="01 AI入门了解"></a>01 AI入门了解</h2><h3 id="1-Crash-Course-AI"><a href="#1-Crash-Course-AI" class="headerlink" title="1. Crash Course AI"></a>1. Crash Course AI</h3><p><a href="https://space.bilibili.com/276373762/channel/detail?cid=101907" target="_blank" rel="noopener">https://space.bilibili.com/276373762/channel/detail?cid=101907</a></p>
<p>课程介绍：该课程出自Crash Course，首发YouTube，单个视频时长均在10分钟左右。视频节奏非常好，语速偏快，适合下饭时间入门了解。主讲很擅长深入浅出的讲清复杂的概念，一集信息量很大甚至评论区还会有课代表帮你总结才能稍稍消化。</p>
<h2 id="02-数学基础"><a href="#02-数学基础" class="headerlink" title="02 数学基础"></a>02 数学基础</h2><h3 id="1-Up主：3Blue1Brown的数学基础"><a href="#1-Up主：3Blue1Brown的数学基础" class="headerlink" title="1. Up主：3Blue1Brown的数学基础"></a>1. Up主：3Blue1Brown的数学基础</h3><p><a href="https://space.bilibili.com/88461692" target="_blank" rel="noopener">https://space.bilibili.com/88461692</a></p>
<p>课程介绍：用动画讲述数学专业知识，其视频涵盖了线性代数、微积分、拓扑学等领域，每门课都配有直观生动的动画演示，帮助观众加深对数学概念定理的理解。</p>
<h3 id="2-数学分析"><a href="#2-数学分析" class="headerlink" title="2. 数学分析"></a>2. 数学分析</h3><p><a href="https://www.bilibili.com/video/av8042121" target="_blank" rel="noopener">https://www.bilibili.com/video/av8042121</a></p>
<p>课程介绍：复旦陈纪修老师的数学分析视频课程，共214讲。陈纪修老师主持编写了21世纪课程教材——《数学分析》。</p>
<h3 id="3-数学建模"><a href="#3-数学建模" class="headerlink" title="3. 数学建模"></a>3. 数学建模</h3><p><a href="http://www.bilibili.com/video/av8824879" target="_blank" rel="noopener">www.bilibili.com/video/av8824879</a></p>
<p>课程介绍：清华大学数学建模公开课，共84讲。教材用的是《数学模型》姜启源 。</p>
<h3 id="4-统计学"><a href="#4-统计学" class="headerlink" title="4. 统计学"></a>4. 统计学</h3><p><a href="https://www.bilibili.com/video/av7199273" target="_blank" rel="noopener">https://www.bilibili.com/video/av7199273</a></p>
<p>课程介绍：可汗学院公开课，将统计学所有内容都涵盖了。共85讲。</p>
<h2 id="03-可视化"><a href="#03-可视化" class="headerlink" title="03 可视化"></a>03 可视化</h2><h3 id="1-Python数据可视化分析"><a href="#1-Python数据可视化分析" class="headerlink" title="1. Python数据可视化分析"></a>1. Python数据可视化分析</h3><p><a href="https://www.bilibili.com/video/av6989413" target="_blank" rel="noopener">https://www.bilibili.com/video/av6989413</a></p>
<p>课程介绍：麦子学院的公开课，共31讲。 </p>
<h3 id="2-Matplotlib-Python-画图教程"><a href="#2-Matplotlib-Python-画图教程" class="headerlink" title="2. Matplotlib Python 画图教程"></a>2. Matplotlib Python 画图教程</h3><p><a href="https://www.bilibili.com/video/av16378354" target="_blank" rel="noopener">https://www.bilibili.com/video/av16378354</a></p>
<p>课程介绍：莫烦Python的课程内容，共19讲。</p>
<h2 id="04-数据分析"><a href="#04-数据分析" class="headerlink" title="04 数据分析"></a>04 数据分析</h2><h3 id="1-Python-数据分析与展示-北京理工大学"><a href="#1-Python-数据分析与展示-北京理工大学" class="headerlink" title="1. Python 数据分析与展示(北京理工大学)"></a>1. Python 数据分析与展示(北京理工大学)</h3><p><a href="https://www.bilibili.com/video/av10101509" target="_blank" rel="noopener">https://www.bilibili.com/video/av10101509</a></p>
<p>课程介绍：北京理工大学MOOC课程，共65讲。 </p>
<h3 id="2-Numpy-amp-Pandas"><a href="#2-Numpy-amp-Pandas" class="headerlink" title="2. Numpy &amp; Pandas"></a>2. Numpy &amp; Pandas</h3><p><a href="https://www.bilibili.com/video/av16378934" target="_blank" rel="noopener">https://www.bilibili.com/video/av16378934</a> </p>
<p>课程介绍：莫烦 Python 数据处理教程，主要讲解Numpy、Pandas两个包的使用。共18讲。</p>
<h3 id="3-【数据分析】SQL数据库入门到精通，最干净易懂的小白必备教程10小时完整版"><a href="#3-【数据分析】SQL数据库入门到精通，最干净易懂的小白必备教程10小时完整版" class="headerlink" title="3. 【数据分析】SQL数据库入门到精通，最干净易懂的小白必备教程10小时完整版"></a>3. 【数据分析】SQL数据库入门到精通，最干净易懂的小白必备教程10小时完整版</h3><p><a href="https://www.bilibili.com/video/av77541375" target="_blank" rel="noopener">https://www.bilibili.com/video/av77541375</a></p>
<p>课程介绍：英文课程，中文字幕，很多同学表示这是看过最好的课程，通俗易懂。</p>
<h2 id="05-数据挖掘"><a href="#05-数据挖掘" class="headerlink" title="05 数据挖掘"></a>05 数据挖掘</h2><h3 id="1-清华大学-数据挖掘：理论与算法"><a href="#1-清华大学-数据挖掘：理论与算法" class="headerlink" title="1. 清华大学-数据挖掘：理论与算法"></a>1. 清华大学-数据挖掘：理论与算法</h3><p><a href="https://www.bilibili.com/video/BV154411Q7mGfrom=search&amp;seid=4187357852637700624" target="_blank" rel="noopener">https://www.bilibili.com/video/BV154411Q7mGfrom=search&amp;seid=4187357852637700624</a></p>
<p>课程介绍：本课程完整覆盖数据挖掘领域的各项核心技术，包括数据预处理、分类、聚类、回归、关联、推荐、集成学习、进化计算等。</p>
<p>强调在知识的广度、深度和趣味性之间寻找最佳平衡点，在生动幽默中讲述数据挖掘的核心思想、关键技术以及一些在其它相关课程和教科书中少有涉及的重要知识点，适合对大数据和数据科学感兴趣的各专业学生以及工程技术人员学习。</p>
<h2 id="06-机器学习"><a href="#06-机器学习" class="headerlink" title="06 机器学习"></a>06 机器学习</h2><h3 id="1-中英字幕-吴恩达机器学习系列课程"><a href="#1-中英字幕-吴恩达机器学习系列课程" class="headerlink" title="1. [中英字幕]吴恩达机器学习系列课程"></a>1. [中英字幕]吴恩达机器学习系列课程</h3><p><a href="https://www.bilibili.com/video/BV164411b7dxfrom=search&amp;seid=13732295711057612613" target="_blank" rel="noopener">https://www.bilibili.com/video/BV164411b7dxfrom=search&amp;seid=13732295711057612613</a></p>
<p>课程介绍：这是个视频是转自吴恩达老师在Coursera上的公开课视频，内容偏向理论而并非实战，适合初学机器学习、深度学习的同学。</p>
<p>需要视频配套资料的可以看看这里：</p>
<p><a href="https://zhuanlan.zhihu.com/p/84214338" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/84214338</a></p>
<p>这是国内黄博士为吴老师课程配的全套资料，包括视频字幕，对应python代码，原版PPT，中文版笔记等等。</p>
<h3 id="2-林轩田机器学习基石-国语"><a href="#2-林轩田机器学习基石-国语" class="headerlink" title="2. 林轩田机器学习基石(国语)"></a>2. 林轩田机器学习基石(国语)</h3><p><a href="https://www.bilibili.com/video/av12463015/" target="_blank" rel="noopener">https://www.bilibili.com/video/av12463015/</a></p>
<p>课程介绍：台湾大学林轩田老师的《机器学习基石》课程由浅入深、内容全面，基本涵盖了机器学习领域的很多方面。其作为机器学习的入门和进阶资料非常适合。而且林老师的教学风格也很幽默风趣，总让读者在轻松愉快的氛围中掌握知识。</p>
<h3 id="3-机器学习技法（林轩田）"><a href="#3-机器学习技法（林轩田）" class="headerlink" title="3. 机器学习技法（林轩田）"></a>3. 机器学习技法（林轩田）</h3><p><a href="https://www.bilibili.com/video/av85508326?p=1" target="_blank" rel="noopener">https://www.bilibili.com/video/av85508326?p=1</a></p>
<p>课程介绍：同样是台大林轩田老师课程，通常学完基石的同学会继续学习这一门课程。</p>
<h3 id="4-李宏毅机器学习-2017"><a href="#4-李宏毅机器学习-2017" class="headerlink" title="4. 李宏毅机器学习(2017)"></a>4. 李宏毅机器学习(2017)</h3><p><a href="https://www.bilibili.com/video/av10590361" target="_blank" rel="noopener">https://www.bilibili.com/video/av10590361</a></p>
<p>课程介绍：台大教授李宏毅制作的，经常被认为机器学习中文课程的首选，而且课程风格诙谐幽默，这就让枯燥的课程变的有趣许多。而且最重要的是，课程中布置了很多作业，而万能的网友更是找出了作业答案，并将其公布在了留言区，可以说太良心了，简直是没钱报班学习者的福音。</p>
<h3 id="5-up主：shuhuai008-【机器学习】【白板推导系列】"><a href="#5-up主：shuhuai008-【机器学习】【白板推导系列】" class="headerlink" title="5. up主：shuhuai008 【机器学习】【白板推导系列】"></a>5. up主：shuhuai008 【机器学习】【白板推导系列】</h3><p><a href="https://www.bilibili.com/video/av70839977" target="_blank" rel="noopener">https://www.bilibili.com/video/av70839977</a></p>
<p>课程介绍：这个up主来自清华，他做的这一套机器学习白板推导的视频讲解系列目前出到第33集流模型。这个视频系列最大的特点是给出了整体的框架，再用单章去分解里面的重点，力求做到简洁易懂，很有中国特色。对比国外普遍一个视频2小时的课程，更适合国人。</p>
<h3 id="6-机器学习教程【强烈推荐】"><a href="#6-机器学习教程【强烈推荐】" class="headerlink" title="6. 机器学习教程【强烈推荐】"></a>6. 机器学习教程【强烈推荐】</h3><p><a href="https://www.bilibili.com/video/av46180067/" target="_blank" rel="noopener">https://www.bilibili.com/video/av46180067/</a></p>
<p>课程介绍：这门课程来自邹博老师的《机器学习与数学分析》，风格同样是深入浅出、通俗易懂，对于有基础和没基础的同学，都能让你轻易入门。</p>
<h3 id="7-机器学习算法-2017邹博最新（Python版）"><a href="#7-机器学习算法-2017邹博最新（Python版）" class="headerlink" title="7. 机器学习算法-2017邹博最新（Python版）"></a>7. 机器学习算法-2017邹博最新（Python版）</h3><p><a href="https://www.bilibili.com/video/av23585080" target="_blank" rel="noopener">https://www.bilibili.com/video/av23585080</a></p>
<p>课程介绍：这门课程同样来自邹博老师，适合配合上一部一起观看。 </p>
<h3 id="8-上海交通大学张志华-机器学习导论"><a href="#8-上海交通大学张志华-机器学习导论" class="headerlink" title="8. (上海交通大学张志华)机器学习导论"></a>8. (上海交通大学张志华)机器学习导论</h3><p><a href="https://www.bilibili.com/video/av76230791/" target="_blank" rel="noopener">https://www.bilibili.com/video/av76230791/</a></p>
<p>课程介绍：张志华老师的这门课讲的很深入，适合学习机器学习和深度学习的研究者深入学习，内容比较偏向理论，需要一定的数学基础。 </p>
<h3 id="9-Scikit-learn-sklearn-优雅地学会机器学习-莫烦-Python-教程"><a href="#9-Scikit-learn-sklearn-优雅地学会机器学习-莫烦-Python-教程" class="headerlink" title="9. Scikit-learn (sklearn) 优雅地学会机器学习 (莫烦 Python 教程)"></a>9. Scikit-learn (sklearn) 优雅地学会机器学习 (莫烦 Python 教程)</h3><p><a href="https://www.bilibili.com/video/av17003173" target="_blank" rel="noopener">https://www.bilibili.com/video/av17003173</a></p>
<p>课程介绍：莫烦的机器学习教程汇集了很多近些年来比较流行的 python 模块教程。课程内容有趣，没有机器学习背景的朋友们也能产生兴趣，对机器学习的每种方法都能迅速理解。</p>
<p>另外，对于已经入门了的同学们, 这门课程也是一个提升自己应用机器学习的好地方, 因为里面同时也介绍了很多种机器学习的技巧方法, 能大大帮助提升学习效果。</p>
<h3 id="10-Stanford-Statistical-Learning-斯坦福大学：统计学习"><a href="#10-Stanford-Statistical-Learning-斯坦福大学：统计学习" class="headerlink" title="10. Stanford : Statistical Learning 斯坦福大学：统计学习"></a>10. Stanford : Statistical Learning 斯坦福大学：统计学习</h3><p><a href="https://www.bilibili.com/video/av19775701" target="_blank" rel="noopener">https://www.bilibili.com/video/av19775701</a></p>
<p>课程介绍：这门课程来自统计学两位超级大佬，全英文字幕，是公认的统计学系入门课程，使用的教材是Introduction to statistical learning，极力避免深奥的公式推导和复杂的概念，对于数学基础不好的人非常友好。</p>
<h2 id="07-深度学习"><a href="#07-深度学习" class="headerlink" title="07 深度学习"></a>07 深度学习</h2><h3 id="1-【中英字幕】吴恩达深度学习课程"><a href="#1-【中英字幕】吴恩达深度学习课程" class="headerlink" title="1. 【中英字幕】吴恩达深度学习课程"></a>1. 【中英字幕】吴恩达深度学习课程</h3><p>第一课：神经网络与深度学习</p>
<p><a href="https://www.bilibili.com/video/av66314465" target="_blank" rel="noopener">https://www.bilibili.com/video/av66314465</a></p>
<p>课程介绍：这门课程的目标是为同学们介绍深度学习的基础知识。学完这门课，你将能够：理解驱动深度学习的主要技术趋势；能够搭建、训练并且运用全连接的深层神经网络；了解如何实现高效的（向量化）的神经网络；理解神经网络架构中的关键参数。 </p>
<p>第二课：改善深层神经网络：超参数调试、正则化以及优化</p>
<p><a href="https://www.bilibili.com/video/av66524657/" target="_blank" rel="noopener">https://www.bilibili.com/video/av66524657/</a></p>
<p>课程介绍：</p>
<p>这门课程将学会理解业界构建深度神经网络应用最有效的做法；<br>能够高效地使用神经网络通用的技巧，包括初始化、L2和dropout正则化、Batch归一化、梯度检验；<br>能够实现并应用各种优化算法，例如mini-batch、Momentum、RMSprop和Adam，并检查它们的收敛程度；<br>理解深度学习时代关于如何构建训练/开发/测试集以及偏差/方差分析最新最有效的方法；<br>能够用TensorFlow实现一个神经网络。</p>
<p>第三课：结构化机器学习项目</p>
<p><a href="https://www.bilibili.com/video/av66524657/" target="_blank" rel="noopener">https://www.bilibili.com/video/av87949453?p=24</a></p>
<p>课程介绍：这门课程将学会理解如何诊断机器学习系统中的错误；能够优先减小误差最有效的方向；理解复杂ML设定，例如训练/测试集不匹配，比较并/或超过人的表现；知道如何应用端到端学习、迁移学习以及多任务学习。</p>
<p>第四课：卷积神经网络</p>
<p><a href="https://www.bilibili.com/video/av66646276" target="_blank" rel="noopener">https://www.bilibili.com/video/av66646276</a></p>
<p>课程介绍：这门课程将学会理解如何搭建一个神经网络，包括最新的变体，例如残余网络；知道如何将卷积网络应用到视觉检测和识别任务；知道如何使用神经风格迁移生成艺术；能够在图像、视频以及其他2D或3D数据上应用这些算法。</p>
<p>第五课：序列模型</p>
<p><a href="https://www.bilibili.com/video/av66647398/" target="_blank" rel="noopener">https://www.bilibili.com/video/av66647398/</a></p>
<p>课程介绍：这门课程将学会理解如何构建并训练循环神经网络（RNN），以及一些广泛应用的变体，例如GRU和LSTM；能够将序列模型应用到自然语言问题中，包括文字合成；能够将序列模型应用到音频应用，包括语音识别和音乐合成。</p>
<h3 id="2-up主：周博磊-强化学习纲要"><a href="#2-up主：周博磊-强化学习纲要" class="headerlink" title="2. up主：周博磊 强化学习纲要"></a>2. up主：周博磊 强化学习纲要</h3><p><a href="https://space.bilibili.com/511221970" target="_blank" rel="noopener">https://space.bilibili.com/511221970</a></p>
<p>课程介绍：最近，香港中文大学信息工程系助理教授周博磊也开始当up主，上传自己的《强化学习》课程。</p>
<p>整个课程共分为基础课程和高阶课程两大部分，主要面向大三、大四或研一的学生，参加课程的学生需要具备相关背景知识，包括线性代数、概率论、机器学习（数据挖掘、模式识别、深度学习）等。此外，由于该课程有不少实践内容，所以参加课程的同学最好有一些编程经验，会用 Python、PyTorch。</p>
<p>除了直播和课程视频之外，周博磊还会同步更新课程的代码，使用的编程语言为 Python，深度学习框架则是 TensorFlow 和 PyTorch 皆可（PyTorch 为主）。和常规的课程一样，《强化学习纲要》也会在每节课后留下一些作业。</p>
<h3 id="3-深度学习框架Tensorflow学习与应用"><a href="#3-深度学习框架Tensorflow学习与应用" class="headerlink" title="3. 深度学习框架Tensorflow学习与应用"></a>3. 深度学习框架Tensorflow学习与应用</h3><p><a href="https://www.bilibili.com/video/av20542427" target="_blank" rel="noopener">https://www.bilibili.com/video/av20542427</a></p>
<p>课程介绍：这门课程来自炼数成金。课程内容基本上是以代码编程为主，也会有少量的深度学习理论内容。课程会从Tensorflow最基础的图(graphs),会话(session),张量(tensor),变量(Variable)等一些最基础的知识开始讲起，逐步讲到Tensorflow的基础使用，以及在Tensorflow中CNN和LSTM的使用。</p>
<p>在课程的后面会带着大家做几个实际的项目，比如训练自己的模型去进行图像识别，使用Tensorflow进行验证码的识别，以及Tensorflow在NLP中的使用。</p>
<h3 id="4-PyTorch-动态神经网络-莫烦-Python-教学"><a href="#4-PyTorch-动态神经网络-莫烦-Python-教学" class="headerlink" title="4. PyTorch 动态神经网络 (莫烦 Python 教学)"></a>4. PyTorch 动态神经网络 (莫烦 Python 教学)</h3><p><a href="https://www.bilibili.com/video/av15997678" target="_blank" rel="noopener">https://www.bilibili.com/video/av15997678</a></p>
<p>课程介绍：这套视频比较适合有一些机器学习课程基础的同学。</p>
<h3 id="5-Numpy-amp-Pandas-莫烦-Python-数据处理教程"><a href="#5-Numpy-amp-Pandas-莫烦-Python-数据处理教程" class="headerlink" title="5. Numpy &amp; Pandas (莫烦 Python 数据处理教程)"></a>5. Numpy &amp; Pandas (莫烦 Python 数据处理教程)</h3><p><a href="https://www.bilibili.com/video/av16378934" target="_blank" rel="noopener">https://www.bilibili.com/video/av16378934</a></p>
<p>课程介绍：这门课程汇集了在 Python 中最重要的数据处理，科学计算模块: Numpy 和 Pandas。</p>
<h3 id="6-Matplotlib-Python-画图教程-莫烦Python"><a href="#6-Matplotlib-Python-画图教程-莫烦Python" class="headerlink" title="6. Matplotlib Python 画图教程 (莫烦Python)"></a>6. Matplotlib Python 画图教程 (莫烦Python)</h3><p><a href="https://www.bilibili.com/video/av16378354/课程介绍：Matplotlib" target="_blank" rel="noopener">https://www.bilibili.com/video/av16378354/课程介绍：Matplotlib</a> 是一个非常强大的 Python 画图工具;这门课程可以对比莫烦numpy &amp; pandas &amp; matplotlib同时来学。</p>
<h3 id="7-tensorflow2-0入门与实战-2019年最通俗易懂的课程"><a href="#7-tensorflow2-0入门与实战-2019年最通俗易懂的课程" class="headerlink" title="7. tensorflow2.0入门与实战 2019年最通俗易懂的课程"></a>7. tensorflow2.0入门与实战 2019年最通俗易懂的课程</h3><p><a href="https://www.bilibili.com/video/av62215565?p=17" target="_blank" rel="noopener">https://www.bilibili.com/video/av62215565?p=17</a></p>
<p>课程介绍：本课程是关于Tensorflow与深度学习实战的一门课程。该课用通俗易懂的实例，系统讲解了Tensorflow2.0的使用，可以说是目前最新最系统的 Tensorflow 2.0 教程。</p>
<p>其中讲解了Tensorflow中各种概念、操作和使用方法，针对Tensorflow的基础知识，在传统数据分析中应用进行详细讲解，并且给出了丰富的深度学习模型实战。</p>
<h3 id="8-斯坦福2017季CS231n深度视觉识别课程视频"><a href="#8-斯坦福2017季CS231n深度视觉识别课程视频" class="headerlink" title="8. 斯坦福2017季CS231n深度视觉识别课程视频"></a>8. 斯坦福2017季CS231n深度视觉识别课程视频</h3><p><a href="https://www.bilibili.com/video/av13260183/?p=1" target="_blank" rel="noopener">https://www.bilibili.com/video/av13260183/?p=1</a></p>
<p>课程介绍：本课程是斯坦福大学关于计算机视觉的课程，全英文字幕，老师是Fei-Fei Li, Justin Johnson, Serena Yeung。</p>
<h3 id="9-【北京大学】人工智能实践：Tensorflow笔记"><a href="#9-【北京大学】人工智能实践：Tensorflow笔记" class="headerlink" title="9. 【北京大学】人工智能实践：Tensorflow笔记"></a>9. 【北京大学】人工智能实践：Tensorflow笔记</h3><p><a href="https://www.bilibili.com/video/av22530538" target="_blank" rel="noopener">https://www.bilibili.com/video/av22530538</a></p>
<p>课程介绍：这是人工智能入门课，将用八次课帮你梳理人工智能概念、机器学习方法、深度学习框架。</p>
<h3 id="10-Keras-快速搭建神经网络-莫烦-Python-教程"><a href="#10-Keras-快速搭建神经网络-莫烦-Python-教程" class="headerlink" title="10. Keras 快速搭建神经网络 (莫烦 Python 教程)"></a>10. Keras 快速搭建神经网络 (莫烦 Python 教程)</h3><p><a href="https://www.bilibili.com/video/av16910214" target="_blank" rel="noopener">https://www.bilibili.com/video/av16910214</a></p>
<p>课程介绍：这门课程包括对Keras的介绍以及如何搭建各种神经网络。</p>
<h3 id="11-李宏毅对抗生成网络-GAN-国语教程-2018"><a href="#11-李宏毅对抗生成网络-GAN-国语教程-2018" class="headerlink" title="11. 李宏毅对抗生成网络(GAN)国语教程(2018)"></a>11. 李宏毅对抗生成网络(GAN)国语教程(2018)</h3><p><a href="https://www.bilibili.com/video/av24011528" target="_blank" rel="noopener">https://www.bilibili.com/video/av24011528</a></p>
<p>课程介绍：这门课程内容详略得当，不想推公式的同学可以跳过推导，并不影响后续课程。</p>
<p>课程的项目和论文都很新，同时也很生动，可以迅速的接触一些最新的东西。另外，为了讲清楚一个概念或技术，PPT的可视化做的非常用心，简洁易懂。</p>
<h3 id="12-李宏毅深度强化学习-国语-课程-2018"><a href="#12-李宏毅深度强化学习-国语-课程-2018" class="headerlink" title="12. 李宏毅深度强化学习(国语)课程(2018)"></a>12. 李宏毅深度强化学习(国语)课程(2018)</h3><p><a href="https://www.bilibili.com/video/av24724071/" target="_blank" rel="noopener">https://www.bilibili.com/video/av24724071/</a></p>
<p>课程介绍：这门课程每个视频大约40分钟左右，PPT内容为英文，讲授语言为中文。课程内容主打强化学习，涉及理论和论文解读，需要同学们具备一定的强化学习基础。</p>
<h3 id="13-David-Silver-强化学习课程高清版"><a href="#13-David-Silver-强化学习课程高清版" class="headerlink" title="13. David Silver 强化学习课程高清版"></a>13. David Silver 强化学习课程高清版</h3><p><a href="https://www.bilibili.com/video/av35209257/" target="_blank" rel="noopener">https://www.bilibili.com/video/av35209257/</a></p>
<p>课程介绍：这是David Silver在 UCL 讲授的强化学习入门课程。Silver就是那位来自 DeepMind，在 Nature 上发表了 DQN 论文，紧接着提出 AlphaGo 和 AlphaGo Zero，从此掀起深度强化学习研究浪潮的大神。</p>
<p>他的课程深入浅出，在介绍强化学习概念的过程中穿插了很多例子，对初学者非常友好，建议作为第一个观看的入门视频课程。</p>
<h3 id="14-【中英文字幕】OpenAI-Spinning-Up-in-Deep-RL-Workshop-（Deep-Reinforcement-Learning）"><a href="#14-【中英文字幕】OpenAI-Spinning-Up-in-Deep-RL-Workshop-（Deep-Reinforcement-Learning）" class="headerlink" title="14. 【中英文字幕】OpenAI - Spinning Up in Deep RL Workshop （Deep Reinforcement Learning）"></a>14. 【中英文字幕】OpenAI - Spinning Up in Deep RL Workshop （Deep Reinforcement Learning）</h3><p><a href="https://www.bilibili.com/video/av45364513/" target="_blank" rel="noopener">https://www.bilibili.com/video/av45364513/</a></p>
<p>课程介绍：对于想上手实践深度强化学习的同学们，这门课程是不错的资源，从 VPG(Vanilla Policy Gradient) 到 TRPO(Trust Region Policy Optimization)、SAC(Soft Actor-Critic) 均有实现，关键是 OpenAI 出品，代码质量高。</p>
<h3 id="15-斯坦福CS224n深度学习自然语言处理课程-by-Chris-Manning"><a href="#15-斯坦福CS224n深度学习自然语言处理课程-by-Chris-Manning" class="headerlink" title="15. 斯坦福CS224n深度学习自然语言处理课程 by Chris Manning"></a>15. 斯坦福CS224n深度学习自然语言处理课程 by Chris Manning</h3><p><a href="https://www.bilibili.com/video/av46216519/" target="_blank" rel="noopener">https://www.bilibili.com/video/av46216519/</a></p>
<p>课程介绍：这门自然语言处理课程是值得每个NLPer学习的NLP课程，由 Christopher Manning大神坐镇主讲，在斯坦福大学已经讲授很多年。此次2019年新课，有很多更新，除了增加一些新内容外，最大的一点大概是代码由Tensorflow迁移到PyTorch。</p>
<p>这门课程的主要目标是希望学生能学到现代深度学习相关知识，特别是和NLP相关的一些知识点；能从宏观上了解人类语言以及理解和产生人类语言的难度；能理解和用代码（PyTorch)实习NLP中的一些主要问题和人物，例如词义理解、依存句法分析、机器翻译、问答系统等。</p>
<h2 id="08-自然语言处理"><a href="#08-自然语言处理" class="headerlink" title="08 自然语言处理"></a>08 自然语言处理</h2><h3 id="1-清华「云上学堂」-刘知远老师闲话AI——自然语言理解难在哪儿"><a href="#1-清华「云上学堂」-刘知远老师闲话AI——自然语言理解难在哪儿" class="headerlink" title="1. 清华「云上学堂」:刘知远老师闲话AI——自然语言理解难在哪儿"></a>1. 清华「云上学堂」:刘知远老师闲话AI——自然语言理解难在哪儿</h3><p><a href="https://www.bilibili.com/video/av90563504" target="_blank" rel="noopener">https://www.bilibili.com/video/av90563504</a></p>
<p>课程介绍：这门课程来自清华大学计算机系刘知远老师。该课程不涉及任何算法及公式，主要是对为什么开展自然语言理解的研究进行介绍，对于想要入门相关领域同学不妨一看。 </p>
<h2 id="09-Python"><a href="#09-Python" class="headerlink" title="09 Python"></a>09 Python</h2><h3 id="1-小甲鱼-零基础入门学Python"><a href="#1-小甲鱼-零基础入门学Python" class="headerlink" title="1. [小甲鱼]零基础入门学Python"></a>1. [小甲鱼]零基础入门学Python</h3><p><a href="https://www.bilibili.com/video/av4050443" target="_blank" rel="noopener">https://www.bilibili.com/video/av4050443</a></p>
<p>课程介绍：小甲鱼教学视频全套共96套，课程生动有趣幽默，强烈推荐给零基础学习python的同学，一步一步深入熟知Python。</p>
<h3 id="2-Python编程-从入门到实践"><a href="#2-Python编程-从入门到实践" class="headerlink" title="2. Python编程 从入门到实践"></a>2. Python编程 从入门到实践</h3><p><a href="https://www.bilibili.com/video/av35698354" target="_blank" rel="noopener">https://www.bilibili.com/video/av35698354</a></p>
<p>课程介绍：这门课程还有配套纸质书籍，非常适合初学者入门的python神书，文笔精炼，内容浅显易懂，还有源代码可做练习题。</p>
<h3 id="3-麻省理工公开课（计算机科学导论及Python编程）"><a href="#3-麻省理工公开课（计算机科学导论及Python编程）" class="headerlink" title="3. 麻省理工公开课（计算机科学导论及Python编程）"></a>3. 麻省理工公开课（计算机科学导论及Python编程）</h3><p><a href="https://www.bilibili.com/video/av10497433" target="_blank" rel="noopener">https://www.bilibili.com/video/av10497433</a></p>
<p>课程介绍：这门课是为零基础或编程经验较少的学生设计。适合新手学习编程，掌握基础计算机科学理论知识。</p>
<h3 id="4-【Python】这可能是你见过的最简洁最没有废话的Python教程"><a href="#4-【Python】这可能是你见过的最简洁最没有废话的Python教程" class="headerlink" title="4. 【Python】这可能是你见过的最简洁最没有废话的Python教程"></a>4. 【Python】这可能是你见过的最简洁最没有废话的Python教程</h3><p><a href="https://www.bilibili.com/video/av5236569" target="_blank" rel="noopener">https://www.bilibili.com/video/av5236569</a></p>
<p>课程介绍：老师雨敲窗表示，由于自己在python的学习道路上摸索了一些方法，也知道小白入门的痛点在哪里，所以这有可能是大家见到的最简洁的python入门教程，每节课视频长度5到10分钟，再花个一两个小时敲一敲代码就足够了。</p>
<h3 id="5-python全栈开发（入门到放弃）"><a href="#5-python全栈开发（入门到放弃）" class="headerlink" title="5. python全栈开发（入门到放弃）"></a>5. python全栈开发（入门到放弃）</h3><p><a href="https://www.bilibili.com/video/av13690129" target="_blank" rel="noopener">https://www.bilibili.com/video/av13690129</a></p>
<p>课程介绍：这门课程共616讲，内容非常系统翔实，包含Python 领域方方面面，对基础的讲解非常透彻。</p>
<h3 id="6-python数据结构与算法系列课程"><a href="#6-python数据结构与算法系列课程" class="headerlink" title="6. python数据结构与算法系列课程"></a>6. python数据结构与算法系列课程</h3><p><a href="https://www.bilibili.com/video/av21540971" target="_blank" rel="noopener">https://www.bilibili.com/video/av21540971</a></p>
<p>课程介绍：课程一共44讲，知识点清晰，适合刚入门学习不久的学生，视频中所讲的算法较好理解，没学过python的也能看得懂，里面用得较多的是 if、while循环，涉及python其它的语法的少。另外，该视频还有配套书籍，名称是 《数据结构与算法 Python语言描述 裘宗燕著》。</p>
<h3 id="7-Python教程-600集Python从入门到精通教程（懂中文就能学会）"><a href="#7-Python教程-600集Python从入门到精通教程（懂中文就能学会）" class="headerlink" title="7. Python教程_600集Python从入门到精通教程（懂中文就能学会）"></a>7. Python教程_600集Python从入门到精通教程（懂中文就能学会）</h3><p><a href="https://www.bilibili.com/video/BV1ex411x7Em?p=1" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1ex411x7Em?p=1</a></p>
<p>课程介绍：这套教程共分为三部分：Linux基础命令；Python基础教程；飞机大战项目演练。从Linux开始讲起是为了照顾真正零基础的同学。</p>
<h3 id="8-2019-Python教程400集-不定时更新！"><a href="#8-2019-Python教程400集-不定时更新！" class="headerlink" title="8. 2019 Python教程400集 不定时更新！"></a>8. 2019 Python教程400集 不定时更新！</h3><p><a href="https://www.bilibili.com/video/av50240377/" target="_blank" rel="noopener">https://www.bilibili.com/video/av50240377/</a></p>
<p>课程介绍：这套Python课程400集，从零基础开始，全面讲解Python基础，直达可以手写神经网络的境界。</p>
<h3 id="9-Python-基础教程-莫烦-Python-教程"><a href="#9-Python-基础教程-莫烦-Python-教程" class="headerlink" title="9. Python 基础教程 (莫烦 Python 教程)"></a>9. Python 基础教程 (莫烦 Python 教程)</h3><p><a href="https://www.bilibili.com/video/av16926522" target="_blank" rel="noopener">https://www.bilibili.com/video/av16926522</a></p>
<p>课程介绍：Python基础非常适合刚入门, 或者是以前使用过其语言的同学, 每一段视频都不会很长, 节节相连, 对于迅速掌握基础的使用方法很有帮助。</p>
<h3 id="10-【千锋教育】Python-900集（学完可就业-2019版）"><a href="#10-【千锋教育】Python-900集（学完可就业-2019版）" class="headerlink" title="10. 【千锋教育】Python 900集（学完可就业/2019版）"></a>10. 【千锋教育】Python 900集（学完可就业/2019版）</h3><p><a href="https://www.bilibili.com/video/av69060979" target="_blank" rel="noopener">https://www.bilibili.com/video/av69060979</a></p>
<p>课程介绍：这门课程非常全面，很适合自学人群的查漏补缺。</p>
<h2 id="10-其他相关领域有趣的up主"><a href="#10-其他相关领域有趣的up主" class="headerlink" title="10 其他相关领域有趣的up主"></a>10 其他相关领域有趣的up主</h2><h3 id="1-up主：python人工智能大数据"><a href="#1-up主：python人工智能大数据" class="headerlink" title="1. up主：python人工智能大数据"></a>1. up主：python人工智能大数据</h3><p><a href="https://space.bilibili.com/477684807?spm_id_from=333.788.b_636f6d6d656e74.4" target="_blank" rel="noopener">https://space.bilibili.com/477684807?spm_id_from=333.788.b_636f6d6d656e74.4</a></p>
<p>推荐理由：这名up主来自清华大学，除了会搬运一些经典AI课程，还会有一些戳中同学痛点的视频，比如AI研究生不知道如何写论文？？清华大学计算机教授为你指点迷津！！！</p>
<h3 id="2-up主：稚晖君"><a href="#2-up主：稚晖君" class="headerlink" title="2. up主：稚晖君"></a>2. up主：稚晖君</h3><p><a href="https://space.bilibili.com/20259914" target="_blank" rel="noopener">https://space.bilibili.com/20259914</a></p>
<p>推荐理由：这名up主超级硬核，作为一个AI开发者，凭借一个硬核纯手工作品——“套娃”小电视登上B站首页，播放量达263.7万。这是一台从零开始制造的AI助手“贾维斯”，不仅能当语音助手，还能处理实时图像，甚至能当web服务器。</p>
<p>整个小电视除了芯片外，从手工画pcb、手工焊接，到写c++代码，几乎全是up主自己手工完成。</p>
<p>根据一个技术大佬统计所需要用到的知识有：</p>
<ul>
<li>电子基础</li>
<li>电子元器件选型</li>
<li>电路原理图设计</li>
<li>高速电路PCB设计</li>
<li>电子元器件焊接技术</li>
<li>电路板调试</li>
<li>启动程序UBOOT裁剪移植</li>
<li>linux内核裁剪移植</li>
<li>文件系统</li>
<li>底层驱动程序(C语言,ARM架构汇编，linux内核架构)</li>
<li>上层应用程序(C++、Qt、JAVA、Python等，深度学习，机器学习，OpenCV，神经网络，自然语言处理)</li>
<li>静态博客服务器搭建</li>
<li>高等数学</li>
<li>线性代数</li>
<li>概率论</li>
<li>离散数学</li>
<li>3D建模</li>
<li>3D打印</li>
<li>雕刻机</li>
<li>视频拍摄后期制作</li>
<li>防脱发技术</li>
</ul>
<h3 id="3-up主：泡泡机器人"><a href="#3-up主：泡泡机器人" class="headerlink" title="3. up主：泡泡机器人"></a>3. up主：泡泡机器人</h3><p><a href="https://space.bilibili.com/38737757/" target="_blank" rel="noopener">https://space.bilibili.com/38737757/</a></p>
<p>推荐理由：机器人要实现智能化，同步定位与地图建构（SLAM或Simultaneous localization and mapping）技术必不可少。尤其这两年无人机、无人车、VR/AR的发展，让SLAM日益火热和重要。</p>
<p>在SLAM理论中，第一个问题称为定位 (Localization)，第二个称为建图 (Mapping)，第三个则是随后的路径规划。就跟一个人来到新环境一样，需要知道自己身处位置，接下来往哪里走。SLAM的作用便是如此，能够精准地建立时间和空间的对应关系。</p>
<p>但非常可惜的是，国内关于SLAM的学习资料还非常少。B站上有热心的阿婆主上传了一系列SLAM课程。UP主“泡泡机器人”是中国SLAM研究爱好者自发组成的团体，在自愿条件下分享SLAM相关知识，旨为推动国内SLAM研究做出一点小小的贡献。</p>
<h3 id="4-老师好我叫何同学"><a href="#4-老师好我叫何同学" class="headerlink" title="4. 老师好我叫何同学"></a>4. 老师好我叫何同学</h3><p><a href="https://space.bilibili.com/163637592?from=search&amp;seid=9630507640569471349" target="_blank" rel="noopener">https://space.bilibili.com/163637592?from=search&amp;seid=9630507640569471349</a></p>
<p>推荐理由：这是一位比较年轻的UP主，目前还在上大学，发布的主要是数码电子产品相关的视频，如三星的折叠屏手机、iPad、HomePod和Apple Watch等，视频中多处精心设计的动画和仔细斟酌的脚本，都是非常吸引人的亮点。</p>
<p>何同学去年发布的视频《有多快？5G在日常使用中的真实体验》，让他彻底出圈了，全网上千万的视频曝光量，给他带来了百万粉丝。</p>
<h3 id="5-up主-CodeSheep"><a href="#5-up主-CodeSheep" class="headerlink" title="5. up主: CodeSheep"></a>5. up主: CodeSheep</h3><p><a href="https://space.bilibili.com/384068749?from=search&amp;seid=9290310507418460283" target="_blank" rel="noopener">https://space.bilibili.com/384068749?from=search&amp;seid=9290310507418460283</a></p>
<p>推荐理由：这是一位程序员出身的UP主，日常分享内容主要有：自学书籍推荐、程序员面试经验分享、职场危机、读研心路历程等。</p>
<p>他认为程序员群体太需要一个能为自己发声的平台，一方面程序员天天和代码打交道，自己其实都快变成一个哑巴了，失去了基本的社交能力，另一方面，程序员其实算是弱势群体，在职场上如果遇到了不公平的待遇，需要有平台去表达自己的心声。</p>
<p>总之，如果你也是一名技术人，或者有志进入 IT 行业，不妨看看这位程序员UP主的视频，不管是吐槽还是分享感悟，你能够找到共鸣。</p>
]]></content>
      <categories>
        <category>学习资源</category>
        <category>B站资源</category>
      </categories>
      <tags>
        <tag>学习资源</tag>
        <tag>B站</tag>
      </tags>
  </entry>
  <entry>
    <title>企业级PaaS解决方案</title>
    <url>/2020/04/12/Enterprise-grade-PaaS-Solution/</url>
    <content><![CDATA[<blockquote>
<p>本文首发于作者周浩同学的个人博客，本站获授权转载。</p>
<p><a href="https://giant-whale.gitee.io/blueking_blog/2020/04/11/Enterprise-grade-PaaS-Solution/" target="_blank" rel="noopener">点击访问原文</a></p>
</blockquote>
<hr>
<h1 id="企业级PaaS解决方案"><a href="#企业级PaaS解决方案" class="headerlink" title="企业级PaaS解决方案"></a>企业级PaaS解决方案</h1><h2 id="IaaS-PaaS-SaaS"><a href="#IaaS-PaaS-SaaS" class="headerlink" title="IaaS PaaS SaaS"></a>IaaS PaaS SaaS</h2><p>一张图解释：</p>
<p><img src="2020-04-11-18-01-30.png" alt=""></p>
<h2 id="开始前的建议"><a href="#开始前的建议" class="headerlink" title="开始前的建议"></a>开始前的建议</h2><h3 id="Python的建议"><a href="#Python的建议" class="headerlink" title="Python的建议"></a>Python的建议</h3><p>我们建议你阅读Python的编码规范：<a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0008/</a></p>
<p>同时对于无编程基础的同学，可以去看看《简明Python教程》。</p>
<p>对于有编程基础的同学，可以去看看《Python核心编程 第二版》，熟悉1-8章，了解10-13章</p>
<h3 id="Django的建议"><a href="#Django的建议" class="headerlink" title="Django的建议"></a>Django的建议</h3><p>你也还需要阅读Django的文档：<a href="https://docs.djangoproject.com/en/2.2/" target="_blank" rel="noopener">https://docs.djangoproject.com/en/2.2/</a></p>
<p>同属熟悉框架：Tutorial (Part 1 | Part 2 | Part 3 | Part 4)</p>
<p>了解Models、querysets、views、template基本使用</p>
<h2 id="框架目录介绍"><a href="#框架目录介绍" class="headerlink" title="框架目录介绍"></a>框架目录介绍</h2><p><img src="2020-04-11-18-09-19.png" alt=""></p>
<p><img src="2020-04-11-18-09-46.png" alt=""></p>
<p>其中，我们研发重点关注的目录为：</p>
<ul>
<li>config - 项目配置文件</li>
<li>static - 静态文件(图片、css、js)</li>
<li>templates\make_templates - HTML模板基础文件</li>
<li>home_application - 默认创建的应用目录(Django模板)</li>
</ul>
<p>我们仔细看一下：</p>
<p><img src="2020-04-11-18-12-30.png" alt=""></p>
<h2 id="本地搭建蓝鲸"><a href="#本地搭建蓝鲸" class="headerlink" title="本地搭建蓝鲸"></a>本地搭建蓝鲸</h2><h3 id="下载蓝鲸框架到本地"><a href="#下载蓝鲸框架到本地" class="headerlink" title="下载蓝鲸框架到本地"></a>下载蓝鲸框架到本地</h3><p>前往地址：<a href="https://bk.tencent.com/docs/document/5.1/2/20" target="_blank" rel="noopener">https://bk.tencent.com/docs/document/5.1/2/20</a></p>
<p>下载该框架：</p>
<p><img src="2020-04-11-18-13-43.png" alt=""></p>
<p>然后解压至一个你选中的目录。</p>
<p>它的目录结构应该是这样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├─blueapps</span><br><span class="line">│  ├─account</span><br><span class="line">│  │  ├─components</span><br><span class="line">│  │  │  ├─bk_jwt</span><br><span class="line">│  │  │  ├─bk_token</span><br><span class="line">│  │  │  ├─null</span><br><span class="line">│  │  │  └─weixin</span><br><span class="line">│  │  ├─handlers</span><br><span class="line">│  │  ├─migrations</span><br><span class="line">│  │  ├─sites</span><br><span class="line">│  │  │  └─open</span><br><span class="line">│  │  ├─static</span><br><span class="line">│  │  │  └─account</span><br><span class="line">│  │  ├─templates</span><br><span class="line">│  │  │  └─account</span><br><span class="line">│  │  └─utils</span><br><span class="line">│  ├─conf</span><br><span class="line">│  │  └─sites</span><br><span class="line">│  │      └─open</span><br><span class="line">│  ├─contrib</span><br><span class="line">│  │  └─bk_commands</span><br><span class="line">│  │      └─management</span><br><span class="line">│  │          └─commands</span><br><span class="line">│  ├─core</span><br><span class="line">│  │  ├─celery</span><br><span class="line">│  │  ├─exceptions</span><br><span class="line">│  │  ├─handler</span><br><span class="line">│  │  └─sites</span><br><span class="line">│  ├─middleware</span><br><span class="line">│  │  ├─bkui</span><br><span class="line">│  │  └─xss</span><br><span class="line">│  ├─patch</span><br><span class="line">│  ├─template</span><br><span class="line">│  │  └─backends</span><br><span class="line">│  ├─utils</span><br><span class="line">│  │  └─sites</span><br><span class="line">│  │      ├─clouds</span><br><span class="line">│  │      ├─ieod</span><br><span class="line">│  │      ├─open</span><br><span class="line">│  │      ├─qcloud</span><br><span class="line">│  │      └─tencent</span><br><span class="line">│  └─__pycache__</span><br><span class="line">├─blueking</span><br><span class="line">│  ├─component</span><br><span class="line">│  │  └─apis</span><br><span class="line">│  └─tests</span><br><span class="line">│      └─utils</span><br><span class="line">├─config</span><br><span class="line">├─home_application</span><br><span class="line">│  └─templates</span><br><span class="line">│      └─home_application</span><br><span class="line">├─locale</span><br><span class="line">│  ├─en</span><br><span class="line">│  │  └─LC_MESSAGES</span><br><span class="line">│  └─zh-hans</span><br><span class="line">│      └─LC_MESSAGES</span><br><span class="line">├─mako_application</span><br><span class="line">│  └─mako_templates</span><br><span class="line">│      └─mako_application</span><br><span class="line">├─mako_templates</span><br><span class="line">├─static</span><br><span class="line">│  ├─account</span><br><span class="line">│  ├─admin</span><br><span class="line">│  │  ├─css</span><br><span class="line">│  │  ├─fonts</span><br><span class="line">│  │  ├─img</span><br><span class="line">│  │  │  └─gis</span><br><span class="line">│  │  └─js</span><br><span class="line">│  │      ├─admin</span><br><span class="line">│  │      └─vendor</span><br><span class="line">│  │          ├─jquery</span><br><span class="line">│  │          └─xregexp</span><br><span class="line">│  ├─djcelery</span><br><span class="line">│  ├─js</span><br><span class="line">│  ├─open</span><br><span class="line">│  │  ├─css</span><br><span class="line">│  │  └─img</span><br><span class="line">│  └─remote</span><br><span class="line">│      ├─artdialog</span><br><span class="line">│      │  └─skins</span><br><span class="line">│      │      └─icons</span><br><span class="line">│      ├─artDialog-6.0.4</span><br><span class="line">│      │  ├─css</span><br><span class="line">│      │  └─new</span><br><span class="line">│      │      ├─css</span><br><span class="line">│      │      └─js</span><br><span class="line">│      ├─bk</span><br><span class="line">│      │  └─style_custom</span><br><span class="line">│      │      └─images</span><br><span class="line">│      ├─jquery</span><br><span class="line">│      └─v3</span><br><span class="line">│          ├─assets</span><br><span class="line">│          │  ├─bootstrap-3.3.4</span><br><span class="line">│          │  │  ├─css</span><br><span class="line">│          │  │  ├─fonts</span><br><span class="line">│          │  │  └─js</span><br><span class="line">│          │  ├─jquery-ui-1.11.0.custom</span><br><span class="line">│          │  │  ├─external</span><br><span class="line">│          │  │  │  └─jquery</span><br><span class="line">│          │  │  └─images</span><br><span class="line">│          │  └─js</span><br><span class="line">│          └─bk</span><br><span class="line">│              ├─css</span><br><span class="line">│              └─js</span><br><span class="line">└─templates</span><br><span class="line">    └─admin</span><br></pre></td></tr></table></figure>

<h3 id="创建虚拟环境并安装依赖"><a href="#创建虚拟环境并安装依赖" class="headerlink" title="创建虚拟环境并安装依赖"></a>创建虚拟环境并安装依赖</h3><p>使用Pycharm打开该项目，并在内置终端中配置git，首次推送到远程仓库。</p>
<p>此处推荐使用码云题高效率。</p>
<p>然后我们创建虚拟环境，在<strong>Settings-Project:{Your Project Name}-Project Interpreter</strong>中点击<strong>齿轮-Add</strong>创建一个新的<strong>venv</strong>，如图：</p>
<p><img src="2020-04-11-18-26-02.png" alt=""></p>
<p>创建完虚拟环境后，建议添加gitignore文件移除对venv文件夹的控制。</p>
<p>然后安装依赖，使用虚拟环境终端:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install -r requirement.txt -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p>但是在安装MysqlClient的时候遇到了问题：</p>
<p><img src="2020-04-11-18-31-08.png" alt=""></p>
<p>对于这种情况，MysqlClient的文档中解释，在Windows下构建MysqlClient是十分困难的，但是我们可以使用二进制包进行安装。</p>
<p>于是，我们首先检查自己的pip可以安装哪些平台的包。</p>
<p>进入python交互环境，依次输入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pip._internal</span><br><span class="line">print(pip._internal.pep425tags.get_supported())</span><br></pre></td></tr></table></figure>

<p>我的python版本是3.8，得到了以下结果：</p>
<p><img src="2020-04-11-18-34-31.png" alt=""></p>
<p>于是我们去下载它的二进制包。</p>
<p>地址：<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#mysqlclient" target="_blank" rel="noopener">https://www.lfd.uci.edu/~gohlke/pythonlibs/#mysqlclient</a></p>
<p>你应该看到这样的界面：</p>
<p><img src="2020-04-11-18-39-09.png" alt=""></p>
<p>注意看，py36即为python3.6版本，cp36即为CPython3.6版本。具体差异请百度。</p>
<p>此处由于我们找不到可以完美适配我们的python版本的二进制包，于是我下载了，cp38-cp38的包，即:</p>
<p><strong>mysqlclient‑1.4.6‑cp38‑cp38‑win32.whl</strong></p>
<p>下载完成后将其拷贝入你的项目根目录。</p>
<p>然后修改其名称：</p>
<p><strong>mysqlclient-1.4.6-cp38-cp38-win32.whl</strong> ===&gt; <strong>mysqlclient-1.4.6-cp38-cp38m-win32.whl</strong></p>
<p>这样使得可以让pip检测平台时不会弹no supported提示。</p>
<p>然后执行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install mysqlclient-1.4.6-cp38-cp38m-win32.whl</span><br></pre></td></tr></table></figure>

<p>安装成功：</p>
<p><img src="2020-04-11-18-43-29.png" alt=""></p>
<p>然后我们打开requirement.txt文件，在里面将mysqlclient==1.4.4该为你二进制包安装的版本。</p>
<p>然后我们再重新执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install -r requirement.txt -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p>安装所有依赖。</p>
<h3 id="在PaaS平台创建应用并填入对应信息"><a href="#在PaaS平台创建应用并填入对应信息" class="headerlink" title="在PaaS平台创建应用并填入对应信息"></a>在PaaS平台创建应用并填入对应信息</h3><p>前往PaaS平台，在开发者中心中，进入应用中心，创建一个应用：</p>
<p><img src="2020-04-11-18-47-47.png" alt=""></p>
<p>填好信息后提交，得到以下信息：</p>
<p><img src="2020-04-11-18-48-34.png" alt=""></p>
<p>在config/<strong>init</strong>.py文件下填入以下信息：</p>
<p><img src="2020-04-11-18-52-18.png" alt=""></p>
<p>其中APP_CODE就是应用ID，SECRET_KEY就是TOKEN，SaaS地址如果是使用公共环境可以参考我的。</p>
<p>然后在本地数据库MySQL中创建一个对应自己应用ID的数据库，执行以下SQL语句(将{APP_CODE}替换为你的应用ID)：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="string">`&#123;APP_CODE&#125;`</span> <span class="keyword">default</span> <span class="keyword">charset</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci;</span><br></pre></td></tr></table></figure>

<p>在config/dev.py中设置你的本地数据库密码。</p>
<p>然后我们执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>

<p>如果报错——“Did you install mysqlclient?”，请执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 uninstall mysqlclient</span><br></pre></td></tr></table></figure>

<p>而后按照安装二进制包的顺序重新安装一次mysqlclient。</p>
<p>但是我们还是报错，提示为：</p>
<p><img src="2020-04-11-19-01-12.png" alt=""></p>
<p>我们打开mako/compat.py，即为venv/Lib/mako/compat.py。</p>
<p>修改clock为perf_counter()，如图：</p>
<p><img src="2020-04-11-19-03-18.png" alt=""></p>
<p>然后重新migrate，此次应该成功。</p>
<h3 id="本地域名映射"><a href="#本地域名映射" class="headerlink" title="本地域名映射"></a>本地域名映射</h3><p>打开hosts文件，加入一个域名映射：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1 appdev.&#123;PAAS_URL&#125;</span><br></pre></td></tr></table></figure>

<p>将其中的{PASS_URL}替换为你的PaaS平台地址。</p>
<p>例如：127.0.0.1 appdev.paas-class.bktencent.com</p>
<p>然后执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py runserver appdev.paas-class.bktencent.com:8000</span><br></pre></td></tr></table></figure>

<p>然后访问：<a href="https://appdev.paas-class.bktencent.com" target="_blank" rel="noopener">https://appdev.paas-class.bktencent.com</a></p>
<p>看到如图即为配置成功：</p>
<p><img src="2020-04-11-19-10-55.png" alt=""></p>
<h2 id="远程部署蓝鲸"><a href="#远程部署蓝鲸" class="headerlink" title="远程部署蓝鲸"></a>远程部署蓝鲸</h2><p>在工作台中打开自助创建数据库，按步填写信息，获得远程蓝鲸数据库账户、密码、地址等信息。</p>
<p>然后填入config/stag.py和prod.py中。</p>
<p>如图：</p>
<p><img src="2020-04-11-19-15-26.png" alt=""></p>
<p>接下来推送至远程代码仓库。</p>
<p>然后进入部署界面</p>
<p>在发布部署中一键部署。</p>
<p><img src="2020-04-11-19-18-55.png" alt=""></p>
<p>一键化部署成功。</p>
<h2 id="写第一个HelloWorld应用部署至远程蓝鲸"><a href="#写第一个HelloWorld应用部署至远程蓝鲸" class="headerlink" title="写第一个HelloWorld应用部署至远程蓝鲸"></a>写第一个HelloWorld应用部署至远程蓝鲸</h2><p>在home_application的template/home_application下添加helloworld.html文件，内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Hello World&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>编辑home_application/urls.py，如图：</p>
<p><img src="2020-04-11-19-30-43.png" alt=""></p>
<p>编辑home_application/views.py，如图：</p>
<p><img src="2020-04-11-19-31-06.png" alt=""></p>
<p>完成后在本地查看是否存在问题。</p>
<p>没有问题推送至远程仓库，一键部署。</p>
<p>如图，测试部署成功：</p>
<p><img src="2020-04-11-19-32-41.png" alt=""></p>
]]></content>
      <categories>
        <category>web</category>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Paas</tag>
        <tag>web部署</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>在树莓派搭建博客平台</title>
    <url>/2020/04/12/%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<blockquote>
<p>本文首发于作者xzlxr的个人网站，本站获授权转载。</p>
<p><a href="http://xzaslxr.xyz/index.php/2020/03/19/zai-shu-mei-pai-da-jian-bo-ke/" target="_blank" rel="noopener">点击访问原文</a></p>
</blockquote>
<hr>
<h1 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h1><h2 id="镜像下载"><a href="#镜像下载" class="headerlink" title="镜像下载"></a>镜像下载</h2><ul>
<li><p><a href="https://www.offensive-security.com/kali-linux-arm-images/#1493408272250-e17e9049-9ce8" target="_blank" rel="noopener">kali   download_</a></p>
</li>
<li><p><a href="https://www.raspberrypi.org/downloads/" target="_blank" rel="noopener">raspbian</a></p>
<p>  <strong>推荐raspbian</strong></p>
</li>
</ul>
<h2 id="烧录"><a href="#烧录" class="headerlink" title="烧录"></a>烧录</h2><p>选择镜像<br>使用win32DiskImager烧录<br><img src="https://i0.wp.com/img.xzaslxr.xyz/img/20200412102617.png" alt="批注 2020-03-05 151401.png"></p>
<p>当win10弹出请求格式化窗口时，取消。<br>烧录成功的分区</p>
<p><img src="https://i2.wp.com/img.xzaslxr.xyz/img/20200412102619.png" alt="批注 2020-03-05 151758.png"></p>
<h2 id="使用ssh连接控制-启动并更改root密码"><a href="#使用ssh连接控制-启动并更改root密码" class="headerlink" title="使用ssh连接控制 启动并更改root密码"></a>使用ssh连接控制 启动并更改root密码</h2><blockquote>
<p>注意 打开daspbian  ssh需要  添加 SSH 文件(无后续)<br><img src="https://i1.wp.com/img.xzaslxr.xyz/img/20200412102621.png" alt="批注 2020-03-05 152449.png"></p>
</blockquote>
<ul>
<li>查看 ip</li>
</ul>
<blockquote>
<p>登录路由器管理员页面<br>或使用ip 扫描器 192.168.1.1-192.168.1.254<br>我这边是192.168.1.115(有线连接)</p>
</blockquote>
<ul>
<li>使用ssh.exe连接 </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh pi@192.168.1.115</span><br></pre></td></tr></table></figure>


<p>需注意raspbian一开始只能使用 <code>pi</code> 用户  且密码为<code>raspberry</code></p>
<ul>
<li>raspbian</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo passwd root <span class="comment">#设置密码</span></span><br><span class="line">sudo passwd --unlock root <span class="comment">#开启root账户</span></span><br></pre></td></tr></table></figure>

<ul>
<li>kali<br>  默认<code>root</code> 密码为 <code>toor</code></li>
</ul>
<h2 id="更新源"><a href="#更新源" class="headerlink" title="更新源"></a>更新源</h2><ul>
<li>kali</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/apt/sources.list</span><br><span class="line"><span class="comment">#中科大</span></span><br><span class="line">deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line"><span class="comment">#aliyun</span></span><br><span class="line">deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib </span><br><span class="line"><span class="comment">#清华</span></span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br></pre></td></tr></table></figure>

<ul>
<li>raspbian<br>  <a href="https://lug.ustc.edu.cn/wiki/mirrors/help/raspbian" target="_blank" rel="noopener">https://lug.ustc.edu.cn/wiki/mirrors/help/raspbian</a></li>
</ul>
<h3 id="修改apt软件源-和-系统源"><a href="#修改apt软件源-和-系统源" class="headerlink" title="修改apt软件源  和 系统源"></a>修改apt软件源  和 系统源</h3><p>添加进去 ，最好先备份</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/apt/sources.list </span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi</span><br><span class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi</span><br></pre></td></tr></table></figure>

<p>完成源的更新软件包索引</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<p>接着更新系统源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nano &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;raspi.list</span><br><span class="line"></span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;raspberrypi&#x2F; buster main ui</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;raspberrypi&#x2F; buster main ui</span><br></pre></td></tr></table></figure>

<p>最后<code>sudo apt-get upgrade</code></p>
<p>配置pip源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/.pip/pip.conf</span><br><span class="line"></span><br><span class="line">[global]</span><br><span class="line">index-url = http://pypi.douban.com/simple/</span><br></pre></td></tr></table></figure>

<h2 id="打开-设置wifi"><a href="#打开-设置wifi" class="headerlink" title="打开 设置wifi"></a>打开 设置wifi</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo raspi-config</span><br><span class="line">SSID:WIFI_NAME</span><br><span class="line">password:WIFI_Password</span><br></pre></td></tr></table></figure>

<p>在win10通过查看wifi的属性来获取SSID<br><img src="http://img.xzaslxr.xyz/img/31220.png" alt="SSID配置"></p>
<h2 id="扩展分区"><a href="#扩展分区" class="headerlink" title="扩展分区"></a>扩展分区</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo raspi-config <span class="comment">#选择7 -&gt; A1</span></span><br></pre></td></tr></table></figure>

<p><code>df -h</code>查看</p>
<h2 id="win远程🔗"><a href="#win远程🔗" class="headerlink" title="win远程🔗"></a>win远程🔗</h2><p>1.安装相关服务<br>卸载原tightvnc<br><code>sudo apt-get purge tightvnc xrdp</code><br>安装tighyvnc xrdp<br><code>sudo apt-get install tightvncserver  xrdp</code></p>
<p>2.开启连接<br>win+r  &gt; mstsc<br>输入用户名和密码就行</p>
<h2 id="查看树莓派-信息"><a href="#查看树莓派-信息" class="headerlink" title="查看树莓派 信息"></a>查看树莓派 信息</h2><ul>
<li>CPU温度、CPU占用情况、内存占用情况和硬盘占用</li>
</ul>
<p>来源<br><a href="https://shumeipai.nxez.com/2014/10/04/get-raspberry-the-current-status-and-data.html" target="_blank" rel="noopener">get-raspberry-the-current-status-and-data.html</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># Return CPU temperature as a character string</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCPUtemperature</span><span class="params">()</span>:</span></span><br><span class="line">    res = os.popen(<span class="string">'vcgencmd measure_temp'</span>).readline()</span><br><span class="line">    <span class="keyword">return</span>(res.replace(<span class="string">"temp="</span>,<span class="string">""</span>).replace(<span class="string">"'C\n"</span>,<span class="string">""</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Return RAM information (unit=kb) in a list</span></span><br><span class="line"><span class="comment"># Index 0: total RAM</span></span><br><span class="line"><span class="comment"># Index 1: used RAM</span></span><br><span class="line"><span class="comment"># Index 2: free RAM</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getRAMinfo</span><span class="params">()</span>:</span></span><br><span class="line">    p = os.popen(<span class="string">'free'</span>)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        line = p.readline()</span><br><span class="line">        <span class="keyword">if</span> i==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span>(line.split()[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Return % of CPU used by user as a character string</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCPUuse</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span>(str(os.popen(<span class="string">"top -n1 | awk '/Cpu\(s\):/ &#123;print $2&#125;'"</span>).readline().strip()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Return information about disk space as a list (unit included)                   # Index 0: total disk space                                                       # Index 1: used disk space                                                       # Index 2: remaining disk space                                                   # Index 3: percentage of disk used                                               def getDiskSpace():</span></span><br><span class="line">    p = os.popen(<span class="string">"df -h /"</span>)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        i = i +<span class="number">1</span></span><br><span class="line">        line = p.readline()</span><br><span class="line">        <span class="keyword">if</span> i==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span>(line.split()[<span class="number">1</span>:<span class="number">5</span>])</span><br><span class="line"><span class="comment"># CPU informatiom</span></span><br><span class="line">CPU_temp = getCPUtemperature()</span><br><span class="line">CPU_usage = getCPUuse()</span><br><span class="line"></span><br><span class="line"><span class="comment"># RAM information</span></span><br><span class="line"><span class="comment"># Output is in kb, here I convert it in Mb for readability</span></span><br><span class="line">RAM_stats = getRAMinfo()</span><br><span class="line">RAM_total = round(int(RAM_stats[<span class="number">0</span>]) / <span class="number">1000</span>,<span class="number">1</span>)</span><br><span class="line">RAM_used = round(int(RAM_stats[<span class="number">1</span>]) / <span class="number">1000</span>,<span class="number">1</span>)</span><br><span class="line">RAM_free = round(int(RAM_stats[<span class="number">2</span>]) / <span class="number">1000</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Disk information</span></span><br><span class="line">DISK_stats = getDiskSpace()</span><br><span class="line">DISK_total = DISK_stats[<span class="number">0</span>]</span><br><span class="line">DISK_used = DISK_stats[<span class="number">1</span>]</span><br><span class="line">DISK_perc = DISK_stats[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">''</span>)</span><br><span class="line">    print(<span class="string">'CPU Temperature = '</span>+CPU_temp)</span><br><span class="line">    print(<span class="string">'CPU Use = '</span>+CPU_usage)</span><br><span class="line">    print(<span class="string">''</span>)</span><br><span class="line">    print(<span class="string">'RAM Total = '</span>+str(RAM_total)+<span class="string">' MB'</span>)</span><br><span class="line">    print(<span class="string">'RAM Used = '</span>+str(RAM_used)+<span class="string">' MB'</span>)</span><br><span class="line">    print(<span class="string">'RAM Free = '</span>+str(RAM_free)+<span class="string">' MB'</span>)</span><br><span class="line">    print(<span class="string">''</span>)  </span><br><span class="line">    print(<span class="string">'DISK Total Space = '</span>+str(DISK_total)+<span class="string">'B'</span>)</span><br><span class="line">    print(<span class="string">'DISK Used Space = '</span>+str(DISK_used)+<span class="string">'B'</span>)</span><br><span class="line">    print(<span class="string">'DISK Used Percentage = '</span>+str(DISK_perc))</span><br></pre></td></tr></table></figure>

<p>添加执行权限并执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x get.py</span><br><span class="line">python3 get.py</span><br></pre></td></tr></table></figure>

<h1 id="网站搭建"><a href="#网站搭建" class="headerlink" title="网站搭建"></a>网站搭建</h1><h2 id="安装Nginx-php-7-3-MariaDB"><a href="#安装Nginx-php-7-3-MariaDB" class="headerlink" title="安装Nginx + php 7.3 + MariaDB"></a>安装Nginx + php 7.3 + MariaDB</h2><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y nginx</span><br></pre></td></tr></table></figure>

<h3 id="php"><a href="#php" class="headerlink" title="php"></a>php</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install -y -t buster php7.3-fpm php7.3-curl php7.3-gd php7.3-intl php7.3-mbstring php7.3-mysql php7.3-imap php7.3-opcache php7.3-sqlite3 php7.3-xml php7.3-xmlrpc php7.3-zip</span><br></pre></td></tr></table></figure>

<h3 id="MariaDB"><a href="#MariaDB" class="headerlink" title="MariaDB"></a>MariaDB</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mariadb-server</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>设置初始密码及修改密码</strong></li>
</ul>
<p><a href="https://www.cnblogs.com/messhair/p/11782850.html" target="_blank" rel="noopener">https://www.cnblogs.com/messhair/p/11782850.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MariaDB [(none)]&gt; use mysql;</span><br><span class="line">MariaDB [mysql]&gt; UPDATE mysql.user SET password &#x3D; PASSWORD(&#39;xzlxr@mysql&#39;) WHERE user &#x3D; &#39;root&#39;;</span><br><span class="line">MariaDB [mysql]&gt; UPDATE user SET plugin&#x3D;&#39;mysql_native_password&#39; WHERE user &#x3D; &#39;root&#39;;</span><br><span class="line">MariaDB [mysql]&gt; FLUSH PRIVILEGES;  #刷新权限相关表格</span><br></pre></td></tr></table></figure>

<p><strong>restart</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service mariadb restart</span><br></pre></td></tr></table></figure>

<p><strong>登录</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>

<p>输入新密码即可</p>
<h3 id="apache2"><a href="#apache2" class="headerlink" title="apache2"></a>apache2</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install apache2</span><br><span class="line">sudo apt-get install libapache2-mod-php</span><br></pre></td></tr></table></figure>


<h2 id="配置-暂时无安全加固"><a href="#配置-暂时无安全加固" class="headerlink" title="配置(暂时无安全加固)"></a>配置(暂时无安全加固)</h2><h3 id="Nginx-配置"><a href="#Nginx-配置" class="headerlink" title="Nginx 配置"></a>Nginx 配置</h3><p>打开配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo  nano /etc/nginx/sites-available/default</span><br></pre></td></tr></table></figure>

<p>连接php以及添加 index.php</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service nginx restart </span><br><span class="line">sudo service php7.3-fpm restart</span><br></pre></td></tr></table></figure>

<h2 id="安装typecho"><a href="#安装typecho" class="headerlink" title="安装typecho"></a>安装typecho</h2><p><a href="http://typecho.org/" target="_blank" rel="noopener">官网</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo wget http://typecho.org/downloads/1.1-17.10.30-release.tar.gz</span><br><span class="line">sudo tar zxvf 1.1-17.10.30-release.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="wordpass"><a href="#wordpass" class="headerlink" title="wordpass"></a>wordpass</h2><p><a href="https://wordpress.com/" target="_blank" rel="noopener">官网下载</a></p>
<h2 id="使用-Frp-实现内网穿透，公网访问web服务器，设置自动启动，后台运行"><a href="#使用-Frp-实现内网穿透，公网访问web服务器，设置自动启动，后台运行" class="headerlink" title="使用 Frp 实现内网穿透，公网访问web服务器，设置自动启动，后台运行"></a>使用 Frp 实现内网穿透，公网访问web服务器，设置自动启动，后台运行</h2><p>参考：</p>
<p><a href="https://blog.csdn.net/u012963827/article/details/89427544?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">使用 Frp 实现内网穿透，公网访问web服务器，设置自动启动，后台运行</a><br><a href="https://blog.csdn.net/datana/article/details/86559217" target="_blank" rel="noopener">通过frp穿透内网ssh访问树莓派</a></p>
<p><a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">https://github.com/fatedier/frp/releases</a></p>
<ul>
<li>客户端配置</li>
</ul>
<blockquote>
<p>在树莓派上</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.32.0/frp_0.32_linux_arm.tar.gz</span><br><span class="line">tar -zxvf frp_0.32_linux_arm.tar.gz</span><br><span class="line"><span class="built_in">cd</span> frp_0.32_linux_arm</span><br><span class="line">sudo nano frpc.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">token = XXXXXXXX <span class="comment">#your_token</span></span><br><span class="line">server_addr = xxx.xxx.xxx.xxx<span class="comment">#服务器ip</span></span><br><span class="line">server_port = XXXX<span class="comment">#服务器端口</span></span><br><span class="line"></span><br><span class="line">[web]</span><br><span class="line"><span class="built_in">type</span> = http</span><br><span class="line">local_ip = xxx.xxx.xxx.xxx <span class="comment">#本地ip</span></span><br><span class="line">local_port = 80</span><br><span class="line">remote_port = 80</span><br><span class="line">custom_domains = <span class="comment">#你的域名</span></span><br></pre></td></tr></table></figure>

<p>在树莓派上添加自启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano /lib/systemd/system/frpc.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=frpc service</span><br><span class="line">After=network.target syslog.target</span><br><span class="line">Wants=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/home/pi/frp/frpc -c /home/pi/frp/frpc.ini  </span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>



<p>重启Frpc，可以 <code>sudo systemctl restart frpc</code><br>停止Frpc，可以 <code>sudo systemctl stop frpc</code></p>
<h2 id="v2ray"><a href="#v2ray" class="headerlink" title="v2ray"></a>v2ray</h2><p><a href="https://github.com/jiangxufeng/v2rayL" target="_blank" rel="noopener">v2ray</a></p>
<h2 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h2><p><a href="https://suool.net/2018/01/09/树莓派折腾指南之使用-SSR-实现科学上网/" target="_blank" rel="noopener">https://suool.net/2018/01/09/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8A%98%E8%85%BE%E6%8C%87%E5%8D%97%E4%B9%8B%E4%BD%BF%E7%94%A8-SSR-%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</a></p>
<h3 id="添加xml"><a href="#添加xml" class="headerlink" title="添加xml"></a>添加xml</h3><p>一开始想直接用插件的(插件，他不香吗)</p>
<p>但问题是，我的vps是代理转发的，而实际的博客vps地址。。。只有内网地址<em>(192.168.1.xxx)</em>，试了google-sitemap(不行)，改了wp上的url设置还是不行。。。</p>
<p>最后的方案:</p>
<ul>
<li>编写sitemap.php</li>
</ul>
<blockquote>
<p><a href="https://blog.csdn.net/u011781521/java/article/details/82814723" target="_blank" rel="noopener">来源</a></p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">require</span>(<span class="string">'./wp-blog-header.php'</span>);</span><br><span class="line"> </span><br><span class="line">header(<span class="string">"Content-type: text/xml"</span>);</span><br><span class="line"> </span><br><span class="line">header(<span class="string">'HTTP/1.1 200 OK'</span>);</span><br><span class="line"> </span><br><span class="line">$posts_to_show = <span class="number">1000</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;?xml version="1.0" encoding="UTF-8"?&gt;'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9" xmlns:mobile="http://www.baidu.com/schemas/sitemap-mobile/1/"&gt;'</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"> </span><br><span class="line">&lt;!-- generated-on=<span class="meta">&lt;?php</span> <span class="keyword">echo</span> get_lastpostdate(<span class="string">'blog'</span>); <span class="meta">?&gt;</span> --&gt;</span><br><span class="line"> </span><br><span class="line">&lt;url&gt;</span><br><span class="line"> </span><br><span class="line">&lt;loc&gt;<span class="meta">&lt;?php</span> <span class="keyword">echo</span> get_home_url(); <span class="meta">?&gt;</span>&lt;/loc&gt;</span><br><span class="line"> </span><br><span class="line">&lt;lastmod&gt;<span class="meta">&lt;?php</span> $ltime = get_lastpostmodified(GMT);$ltime = gmdate(<span class="string">'Y-m-d\TH:i:s+00:00'</span>, strtotime($ltime)); <span class="keyword">echo</span> $ltime; <span class="meta">?&gt;</span>&lt;/lastmod&gt;</span><br><span class="line"> </span><br><span class="line">&lt;changefreq&gt;daily&lt;/changefreq&gt;</span><br><span class="line"> </span><br><span class="line">&lt;priority&gt;<span class="number">1.0</span>&lt;/priority&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/url&gt;</span><br><span class="line"> </span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 文章页面 */</span></span><br><span class="line"> </span><br><span class="line">$myposts = get_posts( <span class="string">"numberposts="</span> . $posts_to_show );</span><br><span class="line"> </span><br><span class="line"><span class="keyword">foreach</span>( $myposts <span class="keyword">as</span> $post ) &#123; <span class="meta">?&gt;</span></span><br><span class="line"> </span><br><span class="line">&lt;url&gt;</span><br><span class="line"> </span><br><span class="line">&lt;loc&gt;<span class="meta">&lt;?php</span> the_permalink(); <span class="meta">?&gt;</span>&lt;/loc&gt;</span><br><span class="line"> </span><br><span class="line">&lt;lastmod&gt;<span class="meta">&lt;?php</span> the_time(<span class="string">'c'</span>) <span class="meta">?&gt;</span>&lt;/lastmod&gt;</span><br><span class="line"> </span><br><span class="line">&lt;changefreq&gt;monthly&lt;/changefreq&gt;</span><br><span class="line"> </span><br><span class="line">&lt;priority&gt;<span class="number">0.6</span>&lt;/priority&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/url&gt;</span><br><span class="line"> </span><br><span class="line"><span class="meta">&lt;?php</span> &#125; <span class="comment">/* 文章循环结束 */</span> <span class="meta">?&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 单页面 */</span></span><br><span class="line"> </span><br><span class="line">$mypages = get_pages();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(count($mypages) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">foreach</span>($mypages <span class="keyword">as</span> $page) &#123; <span class="meta">?&gt;</span></span><br><span class="line"> </span><br><span class="line">&lt;url&gt;</span><br><span class="line"> </span><br><span class="line">&lt;loc&gt;<span class="meta">&lt;?php</span> <span class="keyword">echo</span> get_page_link($page-&gt;ID); <span class="meta">?&gt;</span>&lt;/loc&gt;</span><br><span class="line"> </span><br><span class="line">&lt;lastmod&gt;<span class="meta">&lt;?php</span> <span class="keyword">echo</span> str_replace(<span class="string">" "</span>,<span class="string">"T"</span>,get_page($page-&gt;ID)-&gt;post_modified); <span class="meta">?&gt;</span>+<span class="number">00</span>:<span class="number">00</span>&lt;/lastmod&gt;</span><br><span class="line"> </span><br><span class="line">&lt;changefreq&gt;weekly&lt;/changefreq&gt;</span><br><span class="line"> </span><br><span class="line">&lt;priority&gt;<span class="number">0.6</span>&lt;/priority&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/url&gt;</span><br><span class="line"> </span><br><span class="line"><span class="meta">&lt;?php</span> &#125;&#125; <span class="comment">/* 单页面循环结束 */</span> <span class="meta">?&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 博客分类 */</span></span><br><span class="line"> </span><br><span class="line">$terms = get_terms(<span class="string">'category'</span>, <span class="string">'orderby=name&amp;hide_empty=0'</span> );</span><br><span class="line"> </span><br><span class="line">$count = count($terms);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>($count &gt; <span class="number">0</span>)&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">foreach</span> ($terms <span class="keyword">as</span> $term) &#123; <span class="meta">?&gt;</span></span><br><span class="line"> </span><br><span class="line">&lt;url&gt;</span><br><span class="line"> </span><br><span class="line">&lt;loc&gt;<span class="meta">&lt;?php</span> <span class="keyword">echo</span> get_term_link($term, $term-&gt;slug); <span class="meta">?&gt;</span>&lt;/loc&gt;</span><br><span class="line"> </span><br><span class="line">&lt;changefreq&gt;weekly&lt;/changefreq&gt;</span><br><span class="line"> </span><br><span class="line">&lt;priority&gt;<span class="number">0.8</span>&lt;/priority&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/url&gt;</span><br><span class="line"> </span><br><span class="line"><span class="meta">&lt;?php</span> &#125;&#125; <span class="comment">/* 分类循环结束 */</span><span class="meta">?&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 标签(可选) */</span></span><br><span class="line"> </span><br><span class="line">$tags = get_terms(<span class="string">"post_tag"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">foreach</span> ( $tags <span class="keyword">as</span> $key =&gt; $tag ) &#123;</span><br><span class="line"> </span><br><span class="line">$link = get_term_link( intval($tag-&gt;term_id), <span class="string">"post_tag"</span> );</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( is_wp_error( $link ) )</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">$tags[ $key ]-&gt;link = $link;</span><br><span class="line"> </span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"> </span><br><span class="line">&lt;url&gt;</span><br><span class="line"> </span><br><span class="line">&lt;loc&gt;<span class="meta">&lt;?php</span> <span class="keyword">echo</span> $link <span class="meta">?&gt;</span>&lt;/loc&gt;</span><br><span class="line"> </span><br><span class="line">&lt;changefreq&gt;monthly&lt;/changefreq&gt;</span><br><span class="line"> </span><br><span class="line">&lt;priority&gt;<span class="number">0.4</span>&lt;/priority&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/url&gt;</span><br><span class="line"> </span><br><span class="line"><span class="meta">&lt;?php</span>  &#125; <span class="comment">/* 标签循环结束 */</span> <span class="meta">?&gt;</span></span><br><span class="line"> </span><br><span class="line">&lt;/urlset&gt;</span><br></pre></td></tr></table></figure>



<ul>
<li><pre><code>Yoast SEO  #目前来看最好用的SEO插件</code></pre></li>
</ul>
]]></content>
      <categories>
        <category>web</category>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>frp</tag>
        <tag>树莓派</tag>
        <tag>搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建web运行的基础环境以及加固</title>
    <url>/2020/04/12/%E6%90%AD%E5%BB%BAweb%E8%BF%90%E8%A1%8C%E7%9A%84%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E4%BB%A5%E5%8F%8A%E5%8A%A0%E5%9B%BA/</url>
    <content><![CDATA[<blockquote>
<p>本文首发于作者xzlxr的个人网站，本站获授权转载。</p>
<p><a href="http://xzaslxr.xyz/index.php/2020/03/19/da-jian-web-yun-xing-de-ji-chu-huan-jing-yi-ji-jia-gu/" target="_blank" rel="noopener">点击访问原文</a></p>
</blockquote>
<hr>
<ul>
<li>任务目标:准备学习环境,学习web服务器的搭建过程,并做相应的加固学习</li>
<li>操作系统:win10家庭版+ vm15</li>
<li>预装环境:ubuntu 18.04 + nginx + php-fpm + mysql  </li>
<li>报告要求:搭建过程详细记录,收集加固文档,学习加固技术</li>
</ul>
<h2 id="搭建-0x01"><a href="#搭建-0x01" class="headerlink" title="搭建 0x01"></a>搭建 0x01</h2><h3 id="安装-nginx-php-fpm-mysql"><a href="#安装-nginx-php-fpm-mysql" class="headerlink" title="安装 nginx + php-fpm + mysql"></a>安装 nginx + php-fpm + mysql</h3><p><a href="https://wiki.ubuntu.org.cn/Nginx" target="_blank" rel="noopener">Nginx的安装</a><br>这篇文章涵盖nginx + php-fpm + mysql的详细安装过程和指南</p>
<h4 id="更新系统软件源"><a href="#更新系统软件源" class="headerlink" title="更新系统软件源"></a>更新系统软件源</h4><ul>
<li>备份原有软件源文件<br>  <code>cp /etc/apt/sources.list /etc/apt/sources.list.bak</code></li>
<li>打开并更改<br>  <code>sudo  gedit  /etc/apt/sources.list</code></li>
<li>添加源</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#添加阿里源</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<ul>
<li><p>更新<br>  <code>sudo apt-get update</code><br>  <code>sudo apt-get upgrade</code></p>
</li>
<li><p>当<code>sudo apt-get update</code>出现<br>  W: Some index files failed to download. They have been ignored, or old ones used instead.时<br>  解决方案<br>  <code>sudo vim /etc/resolv.conf</code><br>  添加</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#这里用的使用的是阿里云的DNS服务器,根据你使用的源来填写</span><br><span class="line">nameserver 223.5.5.5  </span><br><span class="line">nameserver 223.6.6.6</span><br></pre></td></tr></table></figure>

<p>再次更新<br>参考:<br><a href="https://blog.csdn.net/feiniao8651/article/details/60332535" target="_blank" rel="noopener">https://blog.csdn.net/feiniao8651/article/details/60332535</a></p>
<ul>
<li>其他<br>  <a href="https://www.linuxidc.com/Linux/2018-08/153709.htm" target="_blank" rel="noopener">其他源</a><br>  但从个人经历而言<br>  最好的方法是使用Software &amp; Update的<strong>Select Best Server</strong>来选择源<br>  点击Download from<br>  后选择Select Best Server</li>
</ul>
<h4 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h4><p><code>sudo apt-get install nginx</code><br>文件结构大致如下:</p>
<ul>
<li>所有配置文件在<code>/etc/nginx</code>,且每个虚拟主机已经安排在<code>/etc/nginx/sites-acailable/</code></li>
<li>程序文件在<code>/usr/sbin/nginx</code>  但目前没有?</li>
<li>日志文件在<code>/var/log/nginx</code></li>
<li>默认的虚拟主机的目录设置在<code>/var/www/html</code>   <strong>注意,请看配置文件</strong><code>/etc/nginx/sites-acailable/</code></li>
<li>启动脚本 <code>sudo /etc/init.d/nginx start</code>,访问 <a href="http://127.0.0.1" target="_blank" rel="noopener">http://127.0.0.1</a> </li>
</ul>
<h4 id="安装php-mysql"><a href="#安装php-mysql" class="headerlink" title="安装php ,mysql"></a>安装php ,mysql</h4><p>考虑版本更新问题,装php7.4版本<br><a href="https://www.php.net/supported-versions.php" target="_blank" rel="noopener">php支援版本信息</a></p>
<ul>
<li>Add PHP PPA Repository</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt -y install software-properties-common</span><br><span class="line">sudo add-apt-repository ppa:ondrej&#x2F;php</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<h5 id="可能遇到问题"><a href="#可能遇到问题" class="headerlink" title="可能遇到问题"></a>可能遇到问题</h5><ul>
<li><code>add-apt-repository ppa:ondrej/php</code>会有错误或长时间无回应<br>  字符编码的锅<br>  <a href="https://github.com/oerdnj/deb.sury.org/issues/56" target="_blank" rel="noopener">解决方案</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo LC_ALL&#x3D;C.UTF-8 add-apt-repository ppa:ondrej&#x2F;php</span><br></pre></td></tr></table></figure>

<ul>
<li>但有Error显示</li>
</ul>
<blockquote>
<p>Error: retrieving gpg key timed out.</p>
</blockquote>
<p><a href="https://www.jianshu.com/p/e2a15336f174" target="_blank" rel="noopener">需要手动添加ppa源</a><br><a href="https://launchpad.net/~ondrej/+archive/ubuntu/php" target="_blank" rel="noopener">PPA源</a><br>注意要选择版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb http:&#x2F;&#x2F;ppa.launchpad.net&#x2F;ondrej&#x2F;php&#x2F;ubuntu bionic main </span><br><span class="line">deb-src http:&#x2F;&#x2F;ppa.launchpad.net&#x2F;ondrej&#x2F;php&#x2F;ubuntu bionic main</span><br></pre></td></tr></table></figure>

<p> 打开源并添加<br><code>sudo  gedit  /etc/apt/sources.list</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb http:&#x2F;&#x2F;ppa.launchpad.net&#x2F;ondrej&#x2F;php&#x2F;ubuntu bionic main </span><br><span class="line">deb-src http:&#x2F;&#x2F;ppa.launchpad.net&#x2F;ondrej&#x2F;php&#x2F;ubuntu bionic main</span><br></pre></td></tr></table></figure>

<p>在Terminal添加Signing Key<br><code>sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 14AA40EC0831756756D7F66C4F4EA0AAE5267A6C</code></p>
<p>再更新<br><code>sudo apt-get update &amp;&amp; sudo apt-get upgrade</code></p>
<h5 id="推荐另一种方法-install-PHP-7-4-amp-mysql"><a href="#推荐另一种方法-install-PHP-7-4-amp-mysql" class="headerlink" title="推荐另一种方法 install PHP 7.4 &amp; mysql"></a><a href="https://guides.wp-bullet.com/install-php-7-4-fpm-on-ubuntu-18-04/" target="_blank" rel="noopener">推荐另一种方法 install PHP 7.4 &amp; mysql</a></h5><p>首先添加sury.org提供的存储库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install apt-transport-https -y</span><br><span class="line">sudo wget -O &#x2F;etc&#x2F;apt&#x2F;trusted.gpg.d&#x2F;php.gpg https:&#x2F;&#x2F;packages.sury.org&#x2F;php&#x2F;apt.gpg</span><br><span class="line">echo &quot;deb https:&#x2F;&#x2F;packages.sury.org&#x2F;php&#x2F; stretch main&quot; | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;php.list</span><br></pre></td></tr></table></figure>

<p>更新软件包列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<p>安装用于nginx和PHP -fpm功能的PHP 7.4包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install php7.4-cli php7.4-curl php7.4-mysql php7.4-fpm php7.4-gd php7.4-xml php7.4-mbstring php7.4-zip php7.4-soap php7.4-dev -y</span><br></pre></td></tr></table></figure>

<p>如果这步报错试试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libcurl3</span><br></pre></td></tr></table></figure>

<p>将CLI更新到PHP 7.4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --set php &#x2F;usr&#x2F;bin&#x2F;php7.4</span><br></pre></td></tr></table></figure>

<h4 id="mysql-install"><a href="#mysql-install" class="headerlink" title="mysql install"></a>mysql install</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install mysql-server</span><br></pre></td></tr></table></figure>

<p>进行安装与配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mysql_secure_installation</span><br></pre></td></tr></table></figure>

<p>安装之后便可使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mysql</span><br></pre></td></tr></table></figure>


<h4 id="配置-Nginx"><a href="#配置-Nginx" class="headerlink" title="配置 Nginx"></a>配置 Nginx</h4><p><img src="https://ae05.alicdn.com/kf/H2e409e51f9b746ca9af9d409c0652d49s.png" alt="Nginx config"><br>修改主机名于配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo  gedit &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;default</span><br></pre></td></tr></table></figure>

<p>添加index.php<br>更改一下注释为<br><img src="https://ae06.alicdn.com/kf/Heb19d36c89a64746a034b473b0e2d001u.png" alt="php_config"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">	include snippets&#x2F;fastcgi-php.conf;</span><br><span class="line"></span><br><span class="line">	# With php-fpm (or other unix sockets):</span><br><span class="line">	fastcgi_pass unix:&#x2F;var&#x2F;run&#x2F;php&#x2F;php7.4-fpm.sock;</span><br><span class="line">	# With php-cgi (or other tcp sockets):</span><br><span class="line">	#fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启nginx和php</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service nginx restart </span><br><span class="line">sudo service php7.4-fpm restart</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">vim /<span class="keyword">var</span>/www/html/info.php</span><br><span class="line"><span class="meta">&lt;?php</span> phpinfo();<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>访问<code>localhost/info</code></p>
<p><code>/var/www/html</code>目录下,创建数据库连接文件<code>conmysql.php</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"demo"</span>;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"connecting mysql &lt;br/&gt;"</span>;</span><br><span class="line">	$link=mysqli_connect(<span class="string">"127.0.0.1"</span>,<span class="string">"root"</span>,<span class="string">"password"</span>);  <span class="comment">//mysqli_connect()</span></span><br><span class="line">	<span class="keyword">if</span>(!link)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"Sorry the connection of mysql failed!"</span>;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"error message: "</span>.mysql_error().<span class="string">"&lt;br/&gt;"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"connect success!"</span>.<span class="string">"&lt;br/&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>url <code>localhost/conmysql.php</code></p>
<p>参考文章:<br><a href="https://computingforgeeks.com/how-to-install-php-on-ubuntu/" target="_blank" rel="noopener">php7.4 install</a><br><a href="https://guides.wp-bullet.com/install-php-7-4-fpm-on-ubuntu-18-04/" target="_blank" rel="noopener">Install PHP 7.4 FPM on Ubuntu 18.04</a><br><a href="https://wiki.ubuntu.org.cn/Nginx" target="_blank" rel="noopener">Ubuntu Nginx</a><br><a href="https://www.digitalocean.com/community/tutorials/how-to-install-linux-nginx-mysql-php-lemp-stack-ubuntu-18-04" target="_blank" rel="noopener">how-to-install-linux-nginx-mysql-php-lemp-stack-ubuntu-18-04</a><br><a href="https://blog.csdn.net/qq_34039018/article/details/94437355" target="_blank" rel="noopener">Ubuntu 16.04中配置nginx + php + mysql</a></p>
<h3 id="模拟环境搭建"><a href="#模拟环境搭建" class="headerlink" title="模拟环境搭建"></a>模拟环境搭建</h3><p>在安全加固之前，可以先搭建模拟环境，同时也便于今后学习。这一点从<a href="http://www.aiyuanzhen.com/index.php/archives/86/" target="_blank" rel="noopener">Keefe_blog</a>学来。</p>
<ul>
<li>创建数据库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql - u root -p123</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> MyGuests (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span>(<span class="number">6</span>) <span class="keyword">UNSIGNED</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span>, </span><br><span class="line">    firstname <span class="built_in">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    lastname <span class="built_in">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    email <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    reg_date <span class="built_in">TIMESTAMP</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> MyGuests (firstname, lastname, email) <span class="keyword">VALUES</span> (<span class="string">'John'</span>, <span class="string">'Doe'</span>, <span class="string">'john@example.com'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> MyGuests (firstname, lastname, email) <span class="keyword">VALUES</span> (<span class="string">'Mary'</span>, <span class="string">'Moe'</span>, <span class="string">'mary@example.com'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> MyGuests (firstname, lastname, email) <span class="keyword">VALUES</span> (<span class="string">'Julie'</span>, <span class="string">'Dooley'</span>, <span class="string">'julie@example.com'</span>);</span><br></pre></td></tr></table></figure>

<p>conmysql.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$servername  = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">$username = <span class="string">"root"</span>;</span><br><span class="line">$password = <span class="string">"password"</span>;</span><br><span class="line">$dbname = <span class="string">"demo"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$conn = mysqli_connect($servername, $username, $password, $dbname);</span><br><span class="line"><span class="comment">// Check connection</span></span><br><span class="line"><span class="keyword">if</span> (!$conn) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"mysqli_connect_error: "</span> . mysqli_connect_error());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>index.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span> dir=<span class="string">"ltr"</span>&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;用户信息&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">@<span class="keyword">include</span>(<span class="string">'conmysql.php'</span>)</span><br><span class="line"></span><br><span class="line">$id = $_GET[<span class="string">'id'</span>];</span><br><span class="line"><span class="keyword">echo</span> $id;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($id))</span><br><span class="line">&#123;</span><br><span class="line">	$sql = <span class="string">"SELECT id, firstname, lastname FROM MyGuests where id = $id"</span>;</span><br><span class="line">	$result = mysqli_query($conn, $sql);</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">if</span> (mysqli_num_rows($result) &gt; <span class="number">0</span>)</span><br><span class="line">       	&#123;</span><br><span class="line">	    <span class="comment">// 输出数据</span></span><br><span class="line">		<span class="keyword">while</span>($row = mysqli_fetch_assoc($result))</span><br><span class="line">	       	&#123;</span><br><span class="line">	        <span class="keyword">echo</span> <span class="string">"id: "</span> . $row[<span class="string">"id"</span>]. <span class="string">" - Name: "</span> . $row[<span class="string">"firstname"</span>]. <span class="string">" "</span> . $row[<span class="string">"lastname"</span>]. <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">	   	 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">echo</span> <span class="string">"no result"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"please sent your id "</span>;</span><br><span class="line">&#125;</span><br><span class="line">mysqli_close($conn);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>


<p>参考：<br><a href="http://www.aiyuanzhen.com/index.php/archives/86/" target="_blank" rel="noopener">搭建 LNMP 环境及一些安全加固总结</a><br><a href="https://www.runoob.com/php" target="_blank" rel="noopener">runoob_php</a></p>
<h3 id="安全加固"><a href="#安全加固" class="headerlink" title="安全加固"></a>安全加固</h3><p>此部分的学习基本上源于网上的相关文档。分别从php、msyql、nginx、ubuntu四个部分进行安全加固。<br>参考文章：</p>
<p><a href="https://fengwenhua.top/archives/web%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">web安全加固</a><br><a href="https://github.com/php/php-src" target="_blank" rel="noopener">https://github.com/php/php-src</a><br><a href="https://www.alibabacloud.com/help/zh/faq-detail/50218.htm" target="_blank" rel="noopener">PHP环境安全加固</a><br><a href="http://www.aiyuanzhen.com/index.php/archives/86/" target="_blank" rel="noopener">centos lnmp及安全加固</a></p>
<p>[nginx安全配置 ][nginx安全配置 ]</p>
<p><a href="https://linuxeye.com/351.html" target="_blank" rel="noopener">PHP网站在linux上的安全设置</a></p>
<h4 id="Nginx-加固"><a href="#Nginx-加固" class="headerlink" title="Nginx 加固"></a>Nginx 加固</h4><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><ul>
<li>安装位置: /etc/nginx</li>
<li>全局站点的配置文件: /etc/nginx/nginx.conf</li>
<li>网站默认站点配置文件: /etc/nginx/sites-available/default</li>
<li>需注意修改文件后，要重新加载</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service nginx reload</span><br></pre></td></tr></table></figure>

<h6 id="隐藏nginx版本号"><a href="#隐藏nginx版本号" class="headerlink" title="隐藏nginx版本号"></a>隐藏nginx版本号</h6><p>nginx版本信息的泄露,将便于黑客查找相应版本的漏洞并利用。</p>
<p>修改 <code>/etc/nginx/nginx.conf</code>将<code>server_token off</code>前的注释删去即可。<br><img src="C:%5Chexo%5Csource_posts%5C%E6%90%AD%E5%BB%BAweb%E8%BF%90%E8%A1%8C%E7%9A%84%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%5C232556.png" alt=""></p>
<p>此时报错后无版本信息</p>
<p><img src="http://img.xzaslxr.xyz/img/232952.png" alt=""></p>
<h6 id="禁止目录浏览"><a href="#禁止目录浏览" class="headerlink" title="禁止目录浏览"></a>禁止目录浏览</h6><p>打开目录浏览，会将文件和文件夹信息暴力出来，一般默认关闭</p>
<p><code>/etc/nginx/sites-available/default</code></p>
<p><img src="http://img.xzaslxr.xyz/img/233715.png" alt="233715"></p>
<p>相应效果</p>
<p><img src="http://img.xzaslxr.xyz/img/233941.png" alt="233941"></p>
<p><code>autoindex off;</code>当关闭时，会显示403</p>
<p><img src="http://img.xzaslxr.xyz/img/234212.png" alt=""></p>
<h6 id="限制访问敏感文件"><a href="#限制访问敏感文件" class="headerlink" title="限制访问敏感文件"></a>限制访问敏感文件</h6><p>这类问题主要是源代码或敏感信息泄露。</p>
<p>常见的有.DS_Store,.git,.ht,各类压缩文件(.rar  .zip    .7z   .tar.gz ),备份文件(.bak) ,.txt</p>
<p>之外  还有  SVN导致文件泄露， WEB-INF/web.xml泄露  CVS泄漏</p>
<p>修改文件为<code>/etc/nginx/sites-available/default</code></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Restrict access to sensitive files in test folder</span></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~* \.(ht|git|bak|7z|zip|rar|txt)$</span> &#123;</span><br><span class="line">        <span class="attribute">deny</span> all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将禁止可以防止.ht    .git  .bak   .7z   .zip  .rar   .txt文件泄露，但最好的方法还是删除 不必要的文件</p>
<p><img src="http://img.xzaslxr.xyz/img/002047.png" alt=""></p>
<p>推荐:</p>
<p><a href="https://segmentfault.com/a/1190000013267839" target="_blank" rel="noopener">location配置 </a></p>
<h6 id="限制HTTP请求方式"><a href="#限制HTTP请求方式" class="headerlink" title="限制HTTP请求方式"></a>限制HTTP请求方式</h6><p>只允许GET|POST|HEAD 这三种方式请求，如果是之外的请求，则返回444状态码</p>
<blockquote>
<p>444 是 Nginx 定义的响应状态码，会立即断开连接，没有响应正文</p>
</blockquote>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">if</span> (<span class="variable">$request_method</span> !<span class="regexp">~ ^(GET|HEAD|POST)$</span> ) &#123;</span><br><span class="line">    <span class="attribute">return</span>    <span class="number">444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="Nginx降权启动"><a href="#Nginx降权启动" class="headerlink" title="Nginx降权启动"></a>Nginx降权启动</h6><p>在 <code>/etc/nginx/nginx.conf</code>  修改</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span> nobody;</span><br></pre></td></tr></table></figure>

<p>当然也可以使用普通用户，来防止ROOT分配权限过大。</p>
<blockquote>
<p>nobody在linux中是一个不能登陆的帐号，一些服务进程如apache，aquid等都采用一些特殊的帐号来运行，比如nobody,news,games等等，这是就可以防止程序本身有安全问题的时候，不会被黑客获得root权限</p>
</blockquote>
<h6 id="禁止文件上传目录执行php"><a href="#禁止文件上传目录执行php" class="headerlink" title="禁止文件上传目录执行php"></a>禁止文件上传目录执行php</h6><p>其配置方式与限制访问敏感文件一致<br>注意空格</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~* ^/(attachments|data)/.*\.(php|php5)$</span> &#123;</span><br><span class="line">    <span class="attribute">deny</span> all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="针对SQL注入的配置"><a href="#针对SQL注入的配置" class="headerlink" title="针对SQL注入的配置"></a>针对SQL注入的配置</h6><p>参考于:</p>
<p><a href="https://blog.csdn.net/lyj1101066558/article/details/54346053" target="_blank" rel="noopener">https://blog.csdn.net/lyj1101066558/article/details/54346053</a></p>
<p><a href="https://www.imydl.tech/lnmp/762.html" target="_blank" rel="noopener">https://www.imydl.tech/lnmp/762.html</a></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">if</span> (<span class="variable">$request_method</span> !<span class="regexp">~* GET|POST)</span> &#123; <span class="attribute">return</span> <span class="number">444</span>; &#125;</span><br><span class="line"><span class="comment">#使用444错误代码可以更加减轻服务器负载压力。</span></span><br><span class="line"><span class="comment">#防止SQL注入</span></span><br><span class="line"><span class="attribute">if</span> (<span class="variable">$query_string</span> <span class="regexp">~* (\$|'|--|[+|(%20)]union[+|(%20)]|[+|(%20)]insert[+|(%20)]|[+|(%20)]drop[+|(%20)]|[+|(%20)]truncate[+|(%20)]|[+|(%20)]update[+|(%20)]|[+|(%20)]from[+|(%20)]|[+|(%20)]grant[+|(%20)]|[+|(%20)]exec[+|(%20)]|[+|(%20)]where[+|(%20)]|[+|(%20)]select[+|(%20)]|[+|(%20)]and[+|(%20)]|[+|(%20)]or[+|(%20)]|[+|(%20)]count[+|(%20)]|[+|(%20)]exec[+|(%20)]|[+|(%20)]chr[+|(%20)]|[+|(%20)]mid[+|(%20)]|[+|(%20)]like[+|(%20)]|[+|(%20)]iframe[+|(%20)]|[\&lt;|%3c]script[\&gt;|%3e]|javascript|alert|webscan|dbappsecurity|style|confirm\(|innerhtml|innertext)(.*)$)</span> &#123; <span class="attribute">return</span> <span class="number">555</span>; &#125;</span><br><span class="line"><span class="attribute">if</span> (<span class="variable">$uri</span> <span class="regexp">~* (/~).*)</span> &#123; <span class="attribute">return</span> <span class="number">501</span>; &#125;</span><br><span class="line"><span class="attribute">if</span> (<span class="variable">$uri</span> <span class="regexp">~* (\\x.))</span> &#123; <span class="attribute">return</span> <span class="number">501</span>; &#125;</span><br><span class="line"><span class="comment">#防止SQL注入 </span></span><br><span class="line">if ($query_string ~* "[;'&lt;&gt;].*") &#123; return 509; &#125;</span><br><span class="line"><span class="attribute">if</span> (<span class="variable">$request_uri</span> <span class="regexp">~ "</span> <span class="string">") &#123; return 509; &#125;</span></span><br><span class="line"><span class="string">if (<span class="variable">$request_uri</span> ~ (\/\.+)) &#123; return 509; &#125;</span></span><br><span class="line"><span class="string">if (<span class="variable">$request_uri</span> ~ (\.+\/)) &#123; return 509; &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#if (<span class="variable">$uri</span> ~* (insert|select|delete|update|count|master|truncate|declare|exec|\*|\')(.*)$ ) &#123; return 503; &#125;</span></span><br><span class="line"><span class="string">#防止SQL注入</span></span><br><span class="line"><span class="string">if (<span class="variable">$request_uri</span> ~* "</span>(cost\()|(concat\()<span class="string">") &#123; return 504; &#125;</span></span><br><span class="line"><span class="string">if (<span class="variable">$request_uri</span> ~* "</span>[+|(%<span class="number">20</span>)]union[+|(%<span class="number">20</span>)]<span class="string">") &#123; return 504; &#125;</span></span><br><span class="line"><span class="string">if (<span class="variable">$request_uri</span> ~* "</span>[+|(%<span class="number">20</span>)]and[+|(%<span class="number">20</span>)]<span class="string">") &#123; return 504; &#125;</span></span><br><span class="line"><span class="string">if (<span class="variable">$request_uri</span> ~* "</span>[+|(%<span class="number">20</span>)]<span class="literal">select</span>[+|(%<span class="number">20</span>)]<span class="string">") &#123; return 504; &#125;</span></span><br><span class="line"><span class="string">if (<span class="variable">$request_uri</span> ~* "</span>[+|(%<span class="number">20</span>)]or[+|(%<span class="number">20</span>)]<span class="string">") &#123; return 504; &#125;</span></span><br><span class="line"><span class="string">if (<span class="variable">$request_uri</span> ~* "</span>[+|(%<span class="number">20</span>)]delete[+|(%<span class="number">20</span>)]<span class="string">") &#123; return 504; &#125;</span></span><br><span class="line"><span class="string">if (<span class="variable">$request_uri</span> ~* "</span>[+|(%<span class="number">20</span>)]update[+|(%<span class="number">20</span>)]<span class="string">") &#123; return 504; &#125;</span></span><br><span class="line"><span class="string">if (<span class="variable">$request_uri</span> ~* "</span>[+|(%<span class="number">20</span>)]insert[+|(%<span class="number">20</span>)]<span class="string">") &#123; return 504; &#125;</span></span><br><span class="line"><span class="string">if (<span class="variable">$query_string</span> ~ "</span>(&lt;|%3C).*<span class="regexp">script.*</span>(&gt;|%3E)<span class="string">") &#123; return 505; &#125;</span></span><br><span class="line">if ($query_string ~ "GLOBALS(=|\[|\%[0-9A-Z]&#123;0,2&#125;)") &#123; return 505; &#125;</span><br><span class="line">if ($query_string ~ "_REQUEST(=|\[|\%[0-9A-Z]&#123;0,2&#125;)") &#123; return 505; &#125;</span><br><span class="line"><span class="attribute">if</span> (<span class="variable">$query_string</span> <span class="regexp">~ "proc/self/environ")</span> &#123; <span class="attribute">return</span> <span class="number">505</span>; &#125;</span><br><span class="line">if ($query_string ~ "mosConfig_[a-zA-Z_]&#123;1,21&#125;(=|\%3D)") &#123; return 505; &#125;</span><br><span class="line"><span class="attribute">if</span> (<span class="variable">$query_string</span> <span class="regexp">~ "base64_(en|de)code\(.*\)")</span> &#123; <span class="attribute">return</span> <span class="number">505</span>; &#125;</span><br><span class="line"><span class="attribute">if</span> (<span class="variable">$query_string</span> <span class="regexp">~ "[a-zA-Z0-9_]=http://")</span> &#123; <span class="attribute">return</span> <span class="number">506</span>; &#125;</span><br><span class="line"><span class="attribute">if</span> (<span class="variable">$query_string</span> <span class="regexp">~ "[a-zA-Z0-9_]=(\.\.//?)+")</span> &#123; <span class="attribute">return</span> <span class="number">506</span>; &#125;</span><br><span class="line"><span class="attribute">if</span> (<span class="variable">$query_string</span> <span class="regexp">~ "[a-zA-Z0-9_]=/([a-z0-9_.]//?)+")</span> &#123; <span class="attribute">return</span> <span class="number">506</span>; &#125;</span><br><span class="line"><span class="attribute">if</span> (<span class="variable">$query_string</span> <span class="regexp">~ "b(ultram|unicauca|valium|viagra|vicodin|xanax|ypxaieo)b")</span> &#123; <span class="attribute">return</span> <span class="number">507</span>; &#125;</span><br><span class="line"><span class="attribute">if</span> (<span class="variable">$query_string</span> <span class="regexp">~ "b(erections|hoodia|huronriveracres|impotence|levitra|libido)b")</span> &#123;<span class="attribute">return</span> <span class="number">507</span>; &#125;</span><br><span class="line"><span class="attribute">if</span> (<span class="variable">$query_string</span> <span class="regexp">~ "b(ambien|bluespill|cialis|cocaine|ejaculation|erectile)b")</span> &#123; <span class="attribute">return</span> <span class="number">507</span>; &#125;</span><br><span class="line"><span class="attribute">if</span> (<span class="variable">$query_string</span> <span class="regexp">~ "b(lipitor|phentermin|pro[sz]ac|sandyauer|tramadol|troyhamby)b")</span> &#123; <span class="attribute">return</span> <span class="number">507</span>; &#125;</span><br></pre></td></tr></table></figure>




<h4 id="PHP-加固"><a href="#PHP-加固" class="headerlink" title="PHP 加固"></a>PHP 加固</h4><h5 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h5><p>php 的 配置文件为 php.ini,其具体位置可通过phpinfo()查询(/etc/php/7.4/fpm/php.ini)。</p>
<h6 id="关于PHP的安全模式"><a href="#关于PHP的安全模式" class="headerlink" title="关于PHP的安全模式"></a>关于PHP的安全模式</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">safe_mode &#x3D; on</span><br></pre></td></tr></table></figure>

<p>但safe_mode早在php5.3起废除，并将自 PHP 5.4.0 起移除。当然也不排除有些网站还会使用php5.3之前的版本.<br><a href="https://www.php.net/manual/zh/features.safe-mode.php" target="_blank" rel="noopener">具体信息features.safe-mode.php</a></p>
<h6 id="禁用不安全的PHP-函数"><a href="#禁用不安全的PHP-函数" class="headerlink" title="禁用不安全的PHP 函数"></a>禁用不安全的PHP 函数</h6><p> 我这边php.ini中之前有默认设置</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">disable_functions = pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,pcntl_unshare,</span><br></pre></td></tr></table></figure>

<p>然后添加了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passthru,exec,system,chroot,chgrp,chown,shell_exec,proc_open,proc_get_status,ini_alter,ini_restore,dl,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server,fsocket,phpinfo</span><br></pre></td></tr></table></figure>

<h6 id="关闭错误显示"><a href="#关闭错误显示" class="headerlink" title="关闭错误显示"></a>关闭错误显示</h6><p>display_errors = Off<br>避免因为错误而泄露相关信息</p>
<h6 id="设置错误日志"><a href="#设置错误日志" class="headerlink" title="设置错误日志"></a>设置错误日志</h6><p> log_errors = On<br> <a href="https://www.php.net/manual/zh/errorfunc.configuration.php" target="_blank" rel="noopener">错误和日志记录配置选项</a></p>
<h6 id="Session-安全配置可以查看"><a href="#Session-安全配置可以查看" class="headerlink" title="Session 安全配置可以查看"></a>Session 安全配置可以查看</h6><p><a href="https://www.php.net/manual/zh/session.security.ini.php" target="_blank" rel="noopener">session.security.ini.php</a><br><code>session.cookie_httponly=On</code><br>禁止 JavaScript 访问会话 cookie。 此设置项可以保护 cookie 不被 JavaScript 窃取。推荐会话ID cookie 设置 httponly 为 On。</p>
<h6 id="关闭PHP信息"><a href="#关闭PHP信息" class="headerlink" title="关闭PHP信息"></a>关闭PHP信息</h6><p>expose_php = Off<br><a href="https://www.php.net/manual/zh/ini.core.php#ini.expose-php" target="_blank" rel="noopener">Note:Since PHP 5.5.0 these guids and the php_logo_guid() function have been removed from PHP and the guids are replaced with data URIs instead. Thus accessing the PHP logo via appending the guid to the URL no longer works. Similarly, turning expose_php off will not affect seeing the PHP logo in phpinfo().</a></p>
<h6 id="限制跨目录访问"><a href="#限制跨目录访问" class="headerlink" title="限制跨目录访问"></a>限制跨目录访问</h6><p>open_basedir = /www/<br>默认是所有文件<br>将PHP可以访问的文件限制在指定的目录树中，包括文件本身。这个指令不受安全模式是开启还是关闭的影响。<a href="https://www.php.net/manual/zh/ini.core.php#ini.open-basedir" target="_blank" rel="noopener">官方手册描述</a><br>Note:</p>
<blockquote>
<p>As of PHP 5.3.0 open_basedir can be tightened at run-time. This means that if open_basedir is set to /www/ in php.ini a script can tighten the configuration to /www/tmp/ at run-time with ini_set(). When listing several directories, you can use the PATH_SEPARATOR constant as a separator regardless of the operating system.</p>
</blockquote>
<h6 id="上传目录限制"><a href="#上传目录限制" class="headerlink" title="上传目录限制"></a>上传目录限制</h6><p>upload_tmp_dir = /tmp<br>执行文件上载时用于存储文件的临时目录。必须是可写的任何用户PHP正在运行。如果没有指定，PHP将使用系统的默认值 .  其他有关upload 的还有<a href="https://www.php.net/manual/zh/ini.core.php#ini.upload-tmp-dir" target="_blank" rel="noopener"> file_uploads upload_max_filesize   max_file_uploads </a></p>
<h6 id="SQL注入防护"><a href="#SQL注入防护" class="headerlink" title="SQL注入防护"></a>SQL注入防护</h6><p><a href="https://www.php.net/manual/zh/info.configuration.php#ini.magic-quotes-gpc" target="_blank" rel="noopener">magci_quotes_gps </a><br>为 GPC (Get/Post/Cookie) 操作设置 magic_quotes 状态。 当 magic_quotes 为 on，所有的 ‘ (单引号)、” (双引号)、\（反斜杠）和 NUL’s 被一个反斜杠自动转义。适用版本:在 PHP &lt;= 4.2.3 是 PHP_INI_ALL，在 PHP 5.4.0 中被移除<br>Note:</p>
<blockquote>
<p>如果 magic_quotes_sybase 也是 ON，它会完全覆盖 magic_quotes_gpc。 两个指令都启用意味着只有单引号被转义为 ‘’。 双引号、反斜杠和 NUL’s 不会被转义。</p>
</blockquote>
<h4 id="mysql加固"><a href="#mysql加固" class="headerlink" title="mysql加固"></a>mysql加固</h4><p>参考:</p>
<p><a href="https://www.alibabacloud.com/help/zh/faq-detail/49568.htm" target="_blank" rel="noopener">MySQL服务安全加固</a></p>
<p><a href="https://www.cnblogs.com/guoke-boy/p/12391441.html" target="_blank" rel="noopener">mysql用户管理</a></p>
<h6 id="账户安全"><a href="#账户安全" class="headerlink" title="账户安全"></a>账户安全</h6><ul>
<li>禁止使用管理员权限运行</li>
</ul>
<p>以普通账户安全运行mysqld,禁止以管理员账号权限来运行MYSQL 服务，</p>
<p>配置文件<code>/etc/mysql/my.cnf</code> 为全局选项, <code>~/.my.cnf</code> 为用户特定选项</p>
<ul>
<li><ul>
<li><p>修改为</p>
<ul>
<li><pre><code class="mysql">[mysql.server]
user=mysql
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 避免不同用户间共享账号</span><br><span class="line"></span><br><span class="line">* * 创建用户 xzlxr  密码 xzlxr2333 </span><br><span class="line"></span><br><span class="line">		&#96;&#96;&#96;mysql</span><br><span class="line">		GRANT USAGE ON *.* TO &#39;xzlxr&#39;@&#39;%&#39; IDENTIFIED BY &#39;any@hin$&#39; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure>

刷新生效

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

查看账户

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select host,user,authentication_string from mysql.user;</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>* 切换账号

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u xzlxr -p</span><br></pre></td></tr></table></figure>

* 删除账号

    使用DROP USER 可以删除一个或多个MYSQL账户。使用 DROP USER 语句必须拥有 MySQL 中的 MySQL 数据库的 DELETE 权限或全局 CREATE USER 权限。在 DROP USER 语句的使用中，若没有明确地给出账户的主机名，则该主机名默认为“%”

    没有权限时的ERROR

    &gt;ERROR 1227 (42000): Access denied; you need (at least one of) the CREATE USER privilege(s) for this operation
    &gt;
    &gt;</code></pre><h6 id="口令"><a href="#口令" class="headerlink" title="口令"></a>口令</h6><p>检查账户默认密码和弱密码。口令长度需要至少八位，并包括数字、小写字母、大写字母和特殊符号四类中的至少两种类型，且五次以内不得设置相同的口令。密码应至少每 90 天进行一次更换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update user set  authentication_string&#x3D;password(&#39;any@hin$&#39;) where user&#x3D;&quot;xzlxr&quot;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<h6 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h6><p>在数据库权限配置能力范围内，根据用户的业务需要，配置其所需的最小权限。</p>
<ul>
<li><p>查看数据库授权情况</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">select * from user;</span><br><span class="line">select * from db;</span><br><span class="line">select * from host;</span><br><span class="line">select * from tables_priv;</span><br><span class="line">select * from columns_priv;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>更新权限，为xzlxr用户添加SELECT 权限</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT Host,User,Select_priv,Grant_priv from user where user &#x3D; &#39;xzlxr&#39;; #查看权限</span><br><span class="line">update user set Select_priv &#x3D; &quot;Y&quot; where user&#x3D;&#39;xzlxr&#39;;</span><br><span class="line">flush privileges</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 revoke 命令回收不必要的或危险的授权。</p>
<p>  可以使用<code>help revoke</code>来查看使用</p>
</li>
</ul>
</li>
</ul>
<h6 id="开启日志审核功能"><a href="#开启日志审核功能" class="headerlink" title="开启日志审核功能"></a>开启日志审核功能</h6><p>数据库应配置日志功能，便于记录运行状况和操作行为。</p>
<p>MySQL服务有以下几种日志类型：</p>
<table>
<thead>
<tr>
<th><strong>错误日志</strong></th>
<th>-log-err</th>
</tr>
</thead>
<tbody><tr>
<td><strong>查询日志</strong></td>
<td>-log （可选）</td>
</tr>
<tr>
<td><strong>慢查询日志</strong></td>
<td>-log-slow-queries （可选）</td>
</tr>
<tr>
<td><strong>更新日志</strong></td>
<td>-log-update</td>
</tr>
<tr>
<td><strong>二进制日志</strong></td>
<td>-log-bin</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#Enter a name for the binary log.</span><br><span class="line">#log-bin&#x3D; mysql_bin</span><br><span class="line">#Enter a name for the query log file. </span><br><span class="line">#log&#x3D; </span><br><span class="line">#Enter a name for the error log file. </span><br><span class="line">log-error&#x3D;&#x2F;var&#x2F;log&#x2F;mysql&#x2F;error.log</span><br><span class="line">#Enter a name for the update log file. Otherwise a default name will be </span><br><span class="line">#log-update&#x3D;</span><br></pre></td></tr></table></figure>

<p>日志查询操作说明</p>
<p>执行<code>show variables like &#39;log_%&#39;;</code>命令可查看所有的 log。</p>
<p>此处已经添加error.log </p>
<h6 id="my-cnf的其他配置"><a href="#my-cnf的其他配置" class="headerlink" title="my.cnf的其他配置"></a>my.cnf的其他配置</h6><p>其他配置推荐看这篇</p>
<p><a href="https://zhuanlan.zhihu.com/p/64871865" target="_blank" rel="noopener">Mysql配置文件/etc/my.cnf解析 </a></p>
<h2 id="搭建-0x02"><a href="#搭建-0x02" class="headerlink" title="搭建 0x02"></a>搭建 0x02</h2><h3 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h3><h4 id="安装-Apache"><a href="#安装-Apache" class="headerlink" title="安装 Apache"></a>安装 Apache</h4><blockquote>
<p>apache2的安装我还是安装在原ubuntu上的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install apache2</span><br></pre></td></tr></table></figure>





<h4 id="配置文件-2"><a href="#配置文件-2" class="headerlink" title="配置文件"></a>配置文件</h4><ul>
<li>apache2的配置文件在</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/apache2/apache2.conf</span><br></pre></td></tr></table></figure>

<p>同时在apache2.conf 描述了配置文件,apache2.conf 为一个主配置文件，通过including 方式包含其他配置文件.如果需要更多详细信息可以看官网</p>
<p><a href="http://httpd.apache.org/docs/2.4/" target="_blank" rel="noopener">apache HTTP 服务器 2.4 版本</a></p>
<p>或<a href="https://blog.csdn.net/stay_zezo/article/details/80212552" target="_blank" rel="noopener">apache2.conf详讲</a></p>
<p>此外，在<code>/usr/share/doc/apache2/README.Debian.gz</code>中描述了apache2在Debain中的特殊点</p>
<blockquote>
<p>两个文件都写的很仔细，好评</p>
</blockquote>
<ul>
<li>apache2的目录</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#	/etc/apache2/</span></span><br><span class="line"><span class="comment">#	|-- apache2.conf</span></span><br><span class="line"><span class="comment">#	|	`--  ports.conf</span></span><br><span class="line"><span class="comment">#	|-- mods-enabled</span></span><br><span class="line"><span class="comment">#	|	|-- *.load</span></span><br><span class="line"><span class="comment">#	|	`-- *.conf</span></span><br><span class="line"><span class="comment">#	|-- conf-enabled</span></span><br><span class="line"><span class="comment">#	|	`-- *.conf</span></span><br><span class="line"><span class="comment"># 	`-- sites-enabled</span></span><br><span class="line"><span class="comment">#	 	`-- *.conf</span></span><br></pre></td></tr></table></figure>

<ul>
<li>端口配置文件为<code>/etc/apache2/ports.conf</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># If you just change the port or add more ports here, you will likely also</span></span><br><span class="line"><span class="comment"># have to change the VirtualHost statement in</span></span><br><span class="line"><span class="comment"># /etc/apache2/sites-enabled/000-default.conf</span></span><br><span class="line"></span><br><span class="line">Listen 80</span><br><span class="line"></span><br><span class="line">&lt;IfModule ssl_module&gt;</span><br><span class="line">        Listen 443</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line"></span><br><span class="line">&lt;IfModule mod_gnutls.c&gt;</span><br><span class="line">        Listen 443</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># vim: syntax=apache ts=4 sw=4 sts=4 sr noet</span></span><br></pre></td></tr></table></figure>

<p><code>mods-availablel</code>和<code>mods-enabled</code>文件夹：这两个文件夹里面存放的都是一些apache2的读写操作等模块，<code>mods-enabled</code>是apache2服务器启动配置的文件，<code>mods-available</code>是apache2服务器可以用的配置文件</p>
<p>如果需要添加功能模块，可在<code>mods-available</code>中建立软连接到<code>mods-enabled</code>.</p>
<ul>
<li><code>site-available</code>和<code>site-enabled</code>是网站根目录的配置文件.</li>
</ul>
<p>同样在<code>site-enabled</code>中保留的是<code>site-available</code>的软连接</p>
<p>在 <code>site-available</code>有两个文件</p>
<table>
<thead>
<tr>
<th>配置文件名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>000-default.conf</td>
<td>使用http协议网站的默认网站配置文件</td>
</tr>
<tr>
<td>default-ss.conf</td>
<td>https协议网站才使用的默认网站配置文件,使用的话，还需申请SSL证书。</td>
</tr>
</tbody></table>
<ul>
<li><code>000-default.conf</code></li>
</ul>
<p>所以主要的配置工作是在<code>000-default.conf</code>中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">	<span class="comment"># The ServerName directive sets the request scheme, hostname and port that</span></span><br><span class="line">	<span class="comment"># the server uses to identify itself. This is used when creating</span></span><br><span class="line">	<span class="comment"># redirection URLs. In the context of virtual hosts, the ServerName</span></span><br><span class="line">	<span class="comment"># specifies what hostname must appear in the request's Host: header to</span></span><br><span class="line">	<span class="comment"># match this virtual host. For the default virtual host (this file) this</span></span><br><span class="line">	<span class="comment"># value is not decisive as it is used as a last resort host regardless.</span></span><br><span class="line">	<span class="comment"># However, you must set it for any further virtual host explicitly.</span></span><br><span class="line">	<span class="comment">#ServerName www.example.com</span></span><br><span class="line"></span><br><span class="line">	ServerAdmin webmaster@localhost</span><br><span class="line">	DocumentRoot /var/www/html</span><br><span class="line"></span><br><span class="line">	<span class="comment"># Available loglevels: trace8, ..., trace1, debug, info, notice, warn,</span></span><br><span class="line">	<span class="comment"># error, crit, alert, emerg.</span></span><br><span class="line">	<span class="comment"># It is also possible to configure the loglevel for particular</span></span><br><span class="line">	<span class="comment"># modules, e.g.</span></span><br><span class="line">	<span class="comment">#LogLevel info ssl:warn</span></span><br><span class="line"></span><br><span class="line">	ErrorLog <span class="variable">$&#123;APACHE_LOG_DIR&#125;</span>/error.log</span><br><span class="line">	CustomLog <span class="variable">$&#123;APACHE_LOG_DIR&#125;</span>/access.log combined</span><br><span class="line"></span><br><span class="line">	<span class="comment"># For most configuration files from conf-available/, which are</span></span><br><span class="line">	<span class="comment"># enabled or disabled at a global level, it is possible to</span></span><br><span class="line">	<span class="comment"># include a line for only one particular virtual host. For example the</span></span><br><span class="line">	<span class="comment"># following line enables the CGI configuration for this host only</span></span><br><span class="line">	<span class="comment"># after it has been globally disabled with "a2disconf".</span></span><br><span class="line">	<span class="comment">#Include conf-available/serve-cgi-bin.conf</span></span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># vim: syntax=apache ts=4 sw=4 sts=4 sr noet</span></span><br></pre></td></tr></table></figure>



<pre><code>ServerAdmin webmaster@localhost
#设置站点邮箱
DocumentRoot /var/www/html
#DocumentRoot 为该站点的根目录</code></pre><ul>
<li>在<code>etc/apache2/mods-available/dir.conf</code>中，DirectoryIndex为Apache默认起始页面</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;IfModule mod_dir.c&gt;</span><br><span class="line">        DirectoryIndex index.html index.cgi index.pl index.php index.xhtml index.htm</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># vim: syntax=apache ts=4 sw=4 sts=4 sr noet</span></span><br></pre></td></tr></table></figure>

<ul>
<li>配置中添加php配置</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s /etc/apache2/conf-available/php7.4-fpm.conf  /etc/apache2/conf-enabled/php7.4-fpm.conf</span><br></pre></td></tr></table></figure>

<p>软连接即可</p>
<p>访问<code>index.php</code></p>
<p><img src="http://img.xzaslxr.xyz/img/161955.png" alt=""></p>
<h4 id="安全加固-1"><a href="#安全加固-1" class="headerlink" title="安全加固"></a>安全加固</h4><p>参考:<br><a href="http://httpd.apache.org/docs/2.4/misc/security_tips.html" target="_blank" rel="noopener">Apache2 security_tips</a><br><a href="https://www.alibabacloud.com/help/zh/faq-detail/52981.htm" target="_blank" rel="noopener">Apache服务安全加固</a><br>推荐:<a href="http://httpd.apache.org/lists.html#http-announce" target="_blank" rel="noopener">http-announce</a>以获取Apache信息</p>
<p><del>网上对这部分基本相识</del></p>
<h4 id="账号设置"><a href="#账号设置" class="headerlink" title="账号设置"></a>账号设置</h4><p>根据需要，为 Apache 服务创建用户及用户组。如果没有设置用户和组(默认是www-data)，则新建用户，并在 Apache 配置文件中进行指定。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd apache #创建 Apache 用户组</span><br><span class="line">useradd apache -g apache #创建 Apache 用户并加入 Apache 用户组</span><br></pre></td></tr></table></figure>

<p>根据在<code>apache2.conf</code>中的信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> These need to be <span class="built_in">set</span> <span class="keyword">in</span> /etc/apache2/envvars</span></span><br><span class="line">User $&#123;APACHE_RUN_USER&#125;</span><br><span class="line">Group $&#123;APACHE_RUN_GROUP&#125;</span><br></pre></td></tr></table></figure>



<p>之后再修改<code>/etc/apache2/envvars</code>文件(注此为Ubuntu系统)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> APACHE_RUN_USER=apache</span><br><span class="line"><span class="built_in">export</span> APACHE_RUN_GROUP=apache</span><br></pre></td></tr></table></figure>

<p><a href="https://askubuntu.com/questions/873839/what-is-the-www-data-user" target="_blank" rel="noopener">what-is-the-www-data-user</a></p>
<h6 id="授权设置"><a href="#授权设置" class="headerlink" title="授权设置"></a>授权设置</h6><ul>
<li>严格控制 Apache 主目录的访问权限，非超级用户不能修改该目录中的内容。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ServerRoot: The top of the directory tree under <span class="built_in">which</span> the server<span class="string">'s</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> configuration, error, and <span class="built_in">log</span> files are kept.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> NOTE!  If you intend to place this on an NFS (or otherwise network)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mounted filesystem <span class="keyword">then</span> please <span class="built_in">read</span> the Mutex documentation (available</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> at &lt;URL:http://httpd.apache.org/docs/2.4/mod/core.html<span class="comment">#mutex&gt;);</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> you will save yourself a lot of trouble.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Do NOT add a slash at the end of the directory path.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ServerRoot <span class="string">"/etc/apache2"</span></span></span><br></pre></td></tr></table></figure>

<p>一般而言，默认配置已经符合要求。</p>
<blockquote>
<p>这里有个疑惑为什么给的配置文件中给ServerRoot注释掉？</p>
<p><a href="https://stackoverflow.com/questions/16701761/apache2-and-serverroot-directive-in-ubuntu/16703035#16703035?newreg=4e42a6badd0e46bbbe8a82e1eddc1f3c" target="_blank" rel="noopener">answer</a></p>
</blockquote>
<ul>
<li>严格设置配置文件和日志文件的权限，防止未授权访问。</li>
</ul>
<p><code>/etc/apache/</code> 默认属主可读写，其他用户拥有只读权限。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">total 96</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">drwxr-xr-x   8 root root  4096 Mar 14 10:15 .</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">drwxr-xr-x 132 root root 12288 Mar 14 09:14 ..</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">-rw-r--r--   1 root root  7224 Dec  3 07:55 apache2.conf</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">drwxr-xr-x   2 root root  4096 Mar 14 21:05 conf-available</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">drwxr-xr-x   2 root root  4096 Mar 14 21:07 conf-enabled</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">-rw-r--r--   1 root root  1782 Jul 16  2019 envvars</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">-rw-r--r--   1 root root 31063 Jul 16  2019 magic</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">drwxr-xr-x   2 root root 12288 Mar 14 21:05 mods-available</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">drwxr-xr-x   2 root root  4096 Mar 14 21:05 mods-enabled</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">-rw-r--r--   1 root root   320 Jul 16  2019 ports.conf</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">drwxr-xr-x   2 root root  4096 Mar 14 01:37 sites-available</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">drwxr-xr-x   2 root root  4096 Mar 14 01:37 sites-enabled</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>将<code>apache2.conf</code>改为600权限，即仅ROOT用户读写</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">drwxr-xr-x   8 root root  4096 Mar 14 10:15 .</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">drwxr-xr-x 132 root root 12288 Mar 14 09:14 ..</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">-rw-------   1 root root  7224 Dec  3 07:55 apache2.conf</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">drwxr-xr-x   2 root root  4096 Mar 14 21:05 conf-available</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">drwxr-xr-x   2 root root  4096 Mar 14 21:07 conf-enabled</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">-rw-r--r--   1 root root  1782 Jul 16  2019 envvars</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">-rw-r--r--   1 root root 31063 Jul 16  2019 magic</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">drwxr-xr-x   2 root root 12288 Mar 14 21:05 mods-available</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">drwxr-xr-x   2 root root  4096 Mar 14 21:05 mods-enabled</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">-rw-r--r--   1 root root   320 Jul 16  2019 ports.conf</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">drwxr-xr-x   2 root root  4096 Mar 14 01:37 sites-available</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">drwxr-xr-x   2 root root  4096 Mar 14 01:37 sites-enabled</span></span><br></pre></td></tr></table></figure>


</blockquote>
<h6 id="日志设置"><a href="#日志设置" class="headerlink" title="日志设置"></a>日志设置</h6><p>Apache 设备应配置日志功能，对运行错误、用户访问等事件进行记录，记录内容包括时间，用户使用的 IP 地址等内容,它们也会让您了解对服务器引发的攻击，并允许您检查是否存在必要的安全级别。</p>
<ul>
<li>error.log</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ErrorLog: The location of the error <span class="built_in">log</span> file.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> If you <span class="keyword">do</span> not specify an ErrorLog directive within a &lt;VirtualHost&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> container, error messages relating to that virtual host will be</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> logged here.  If you *<span class="keyword">do</span>* define an error logfile <span class="keyword">for</span> a &lt;VirtualHost&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> container, that host<span class="string">'s errors will be logged there and not here.</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log</span><br></pre></td></tr></table></figure>

<p><code>${APACHE_LOG_DIR}</code>在<code>envvars</code>文件有描述</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Only /var/<span class="built_in">log</span>/apache2 is handled by /etc/logrotate.d/apache2.</span></span><br><span class="line">export APACHE_LOG_DIR=/var/log/apache2$SUFFIX</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><code>LogLevel</code>命令用于调整记录在错误日志中的信息的详细程度，建议设置为 notice。日志的级别，默认是 warn 级别，notice 级别比较详细，但在实际中由于日志会占用大量硬盘空间。</li>
</ul>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> LogLevel: Control the severity of messages logged to the error_log.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Available values: trace8, ..., trace1, debug, info, notice, warn,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> error, crit, alert, emerg.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> It is also possible to configure the <span class="built_in">log</span> level <span class="keyword">for</span> particular modules, e.g.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">"LogLevel info ssl:warn"</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">LogLevel warn</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>access_log</li>
</ul>
<p><a href="http://httpd.apache.org/docs/2.4/logs.html#accesslog" target="_blank" rel="noopener">http://httpd.apache.org/docs/2.4/logs.html#accesslog</a></p>
<p>默认是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The following directives define some format nicknames <span class="keyword">for</span> use with</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> a CustomLog directive.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> These deviate from the Common Log Format definitions <span class="keyword">in</span> that they use %O</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> (the actual bytes sent including headers) instead of %b (the size of the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> requested file), because the latter makes it impossible to detect partial</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> requests.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Note that the use of %&#123;X-Forwarded-For&#125;i instead of %h is not recommended.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Use mod_remoteip instead.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">LogFormat "%v:%p %h %l %u %t \"%r\" %&gt;s %O \"%&#123;Referer&#125;i\" \"%&#123;User-Agent&#125;i\"" vhost_combined</span><br><span class="line">LogFormat "%h %l %u %t \"%r\" %&gt;s %O \"%&#123;Referer&#125;i\" \"%&#123;User-Agent&#125;i\"" combined</span><br><span class="line">LogFormat "%h %l %u %t \"%r\" %&gt;s %O" common</span><br><span class="line">LogFormat "%&#123;Referer&#125;i -&gt; %U" referer</span><br><span class="line">LogFormat "%&#123;User-agent&#125;i" agent</span><br></pre></td></tr></table></figure>

<p>添加<code>CustomLog /var/log/apache2/access_log vhost_combined</code></p>
<p>重启Apache</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/etc/apache2# find /var -name access_log</span><br><span class="line">/var/log/cups/access_log</span><br><span class="line">/var/log/apache2/access_log</span><br></pre></td></tr></table></figure>



<h6 id="禁止访问外部文件-和-禁止目录列出"><a href="#禁止访问外部文件-和-禁止目录列出" class="headerlink" title="禁止访问外部文件 和 禁止目录列出"></a>禁止访问外部文件 和 禁止目录列出</h6><p>禁止 Apache 访问 Web 目录之外的任何文件。</p>
<p>禁止访问设置在原配置文件中是有说明的，且在<a href="http://httpd.apache.org/docs/2.4/misc/security_tips.html" target="_blank" rel="noopener">官方网站上的安全提示</a>中也提到</p>
<ul>
<li>说明</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Sets the default security model of the Apache2 HTTPD server. It does</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> not allow access to the root filesystem outside of /usr/share and /var/www.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The former is used by web applications packaged <span class="keyword">in</span> Debian,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the latter may be used <span class="keyword">for</span> <span class="built_in">local</span> directories served by the web server. If</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> your system is serving content from a sub-directory <span class="keyword">in</span> /srv you must allow</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> access here, or <span class="keyword">in</span> any related virtual host.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>与上面说明相对于的默认配置</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;Directory /&gt;</span><br><span class="line">	Options FollowSymLinks</span><br><span class="line">	AllowOverride None</span><br><span class="line">	Require all denied</span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line"></span><br><span class="line">&lt;Directory /usr/share&gt;</span><br><span class="line">	AllowOverride None</span><br><span class="line">	Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line"></span><br><span class="line">&lt;Directory /var/www/&gt;</span><br><span class="line">	Options Indexes FollowSymLinks</span><br><span class="line">	AllowOverride None</span><br><span class="line">	Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&lt;Directory /srv/&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">	Options Indexes FollowSymLinks</span></span><br><span class="line"><span class="meta">#</span><span class="bash">	AllowOverride None</span></span><br><span class="line"><span class="meta">#</span><span class="bash">	Require all granted</span></span><br><span class="line"><span class="meta">#</span><span class="bash">&lt;/Directory&gt;</span></span><br></pre></td></tr></table></figure>

<p>简单说明</p>
<blockquote>
<p>不允许访问<code>/usr/share</code>和<code>/var/www</code>之外的根文件系统。</p>
<p><code>/usr/share</code>用于Debian中打包的Web应用程序</p>
<p><code>/var/www</code>用于Web服务器服务的本地目录</p>
</blockquote>
<ul>
<li>禁止目录列出</li>
</ul>
<p>在<code>/var/www</code>设置中有<code>Options Indexes FollowSymLinks</code></p>
<p>Indexes 的作用就是当该目录下没有 index.html 文件时，就显示目录结构，去掉 Indexes，Apache 就不会显示该目录的列表了。</p>
<p>即</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;Directory /var/www/&gt;</span><br><span class="line">	Options FollowSymLinks</span><br><span class="line">	AllowOverride None</span><br><span class="line">	Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>效果</p>
<p>  <img src="http://img.xzaslxr.xyz/img/142600.png" alt=""></p>
</li>
</ul>
<h6 id="错误页面重新定向"><a href="#错误页面重新定向" class="headerlink" title="错误页面重新定向"></a>错误页面重新定向</h6><p>Apache 错误页面重定向功能可以防止敏感信息泄露。</p>
<p>参考:<br><a href="https://www.howtoing.com/how-to-configure-apache-to-use-custom-error-pages-on-ubuntu-14-04" target="_blank" rel="noopener">https://www.howtoing.com/how-to-configure-apache-to-use-custom-error-pages-on-ubuntu-14-04</a></p>
<ul>
<li>在重新定向前，需要创建一些自定义的页面</li>
</ul>
<p><code>custom_404.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">'color:red'</span>&gt;</span>Error 404: Not found :-(<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>I have no idea where that file is, sorry.  Are you sure you typed in the correct URL?<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>custom_50x.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Oops! Something went wrong...<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>We seem to be having some technical difficulties. Hang tight.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>配置</li>
</ul>
<p>配置文件是<code>000-default.conf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">        ServerAdmin webmaster@localhost</span><br><span class="line">        DocumentRoot &#x2F;var&#x2F;www&#x2F;html</span><br><span class="line">        </span><br><span class="line">        ErrorLog $&#123;APACHE_LOG_DIR&#125;&#x2F;error.log</span><br><span class="line">        CustomLog $&#123;APACHE_LOG_DIR&#125;&#x2F;access.log combined</span><br><span class="line">        </span><br><span class="line">        #ErrorDocument</span><br><span class="line">        ErrorDocument 404 &#x2F;custom_404.html</span><br><span class="line">        ErrorDocument 500 &#x2F;custom_50x.html</span><br><span class="line">        ErrorDocument 502 &#x2F;custom_50x.html</span><br><span class="line">        ErrorDocument 503 &#x2F;custom_50x.html</span><br><span class="line">        ErrorDocument 504 &#x2F;custom_50x.html</span><br><span class="line">        </span><br><span class="line">         &lt;Files &quot;custom_404.html&quot;&gt;</span><br><span class="line">             &lt;If &quot;-z %&#123;ENV:REDIRECT_STATUS&#125;&quot;&gt;</span><br><span class="line">                 RedirectMatch 404 ^&#x2F;custom_404.html$</span><br><span class="line">             &lt;&#x2F;If&gt;</span><br><span class="line">        &lt;&#x2F;Files&gt;</span><br><span class="line">        </span><br><span class="line">&lt;&#x2F;VirtualHost&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>404  当访问不存在的页面时，报错</li>
<li><img src="http://img.xzaslxr.xyz/img/152337.png" alt=""></li>
</ul>
<h6 id="拒绝服务-dos-攻击"><a href="#拒绝服务-dos-攻击" class="headerlink" title="拒绝服务(dos)攻击"></a>拒绝服务(dos)攻击</h6><blockquote>
<p>所有网络服务器都可能遭受拒绝服务攻击，这种攻击试图通过占用服务器的资源来阻止对客户机的响应。完全阻止这种攻击是不可能的，但是您可以做一些事情来减轻它们所造成的问题。通常最有效的反dos工具是防火墙或其他操作系统配置。例如，可以将大多数防火墙配置为限制来自任何单个IP地址或网络的并发连接数量，从而防止一系列简单的攻击。当然，这对抵抗分布式拒绝服务攻击(DDoS)毫无帮助。</p>
</blockquote>
<p>还有一些特定的Apache HTTP服务器配置设置可以帮助缓解问题</p>
<p>同样该点在官网<a href="http://httpd.apache.org/docs/2.4/misc/security_tips.html#page-header" target="_blank" rel="noopener">http://httpd.apache.org/docs/2.4/misc/security_tips.html#page-header</a>  提及，并给出一些设置方案</p>
<p>配置文件为<code>apache.conf</code></p>
<ul>
<li><pre><code class="bash"><span class="comment">#</span>
<span class="comment"># KeepAlive: Whether or not to allow persistent connections (more than</span>
<span class="comment"># one request per connection). Set to "Off" to deactivate.</span>
<span class="comment">#</span>
KeepAlive On

<span class="comment">#</span>
<span class="comment"># MaxKeepAliveRequests: The maximum number of requests to allow</span>
<span class="comment"># during a persistent connection. Set to 0 to allow an unlimited amount.</span>
<span class="comment"># We recommend you leave this number high, for maximum performance.</span>
<span class="comment">#</span>
MaxKeepAliveRequests 100

<span class="comment">#</span>
<span class="comment"># KeepAliveTimeout: Number of seconds to wait for the next request from the</span>
<span class="comment"># same client on the same connection.</span>
<span class="comment">#</span>
KeepAliveTimeout 5
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* &#96;Timeout 300&#96;  #客户端与服务器端建立连接前的时间间隔</span><br><span class="line"></span><br><span class="line">* 可通过http:&#x2F;&#x2F;modules.apache.org&#x2F;提供许多第三方模块，这些模块可以限制某些客户端行为，从而缓解 DoS 问题。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### 隐藏 Apache 的版本号</span><br><span class="line"></span><br><span class="line">Apache主机在默认状态下，如果遭遇错误页面，除了提示出错之外，还会将你的机器软件环境显示出来，如你的Apache版本，PHP版本。</span><br><span class="line"></span><br><span class="line">详细介绍:</span><br><span class="line">[ubuntu隐藏 Apache 的版本号](http:&#x2F;&#x2F;blog.sina.com.cn&#x2F;s&#x2F;blog_4a2ee3fb0102vb04.html)</span><br><span class="line"></span><br><span class="line">配置文件&#96;&#x2F;etc&#x2F;apache2&#x2F;conf-available&#x2F;security&#96;</span><br><span class="line"></span><br><span class="line">修改后内容</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;bash</span><br><span class="line">#</span><br><span class="line"># ServerTokens</span><br><span class="line"># This directive configures what you return as the Server HTTP response</span><br><span class="line"># Header. The default is &#39;Full&#39; which sends information about the OS-Type</span><br><span class="line"># and compiled in modules.</span><br><span class="line"># Set to one of:  Full | OS | Minimal | Minor | Major | Prod</span><br><span class="line"># where Full conveys the most information, and Prod the least.</span><br><span class="line">#ServerTokens Minimal</span><br><span class="line">ServerTokens Prod</span><br><span class="line">#ServerTokens Full</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Optionally add a line containing the server version and virtual host</span><br><span class="line"># name to server-generated pages (internal error documents, FTP directory</span><br><span class="line"># listings, mod_status and mod_info output etc., but not CGI generated</span><br><span class="line"># documents or custom error documents).</span><br><span class="line"># Set to &quot;EMail&quot; to also include a mailto: link to the ServerAdmin.</span><br><span class="line"># Set to one of:  On | Off | EMail</span><br><span class="line">#ServerSignature Off</span><br><span class="line">ServerSignature Off</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>详细介绍可以看上面的注释</p>
<h6 id="关闭-TRACE功能"><a href="#关闭-TRACE功能" class="headerlink" title="关闭 TRACE功能"></a>关闭 TRACE功能</h6><p>关闭 TRACE 功能，防止 TRACE 方法被访问者恶意利用。</p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/61990354" target="_blank" rel="noopener">XST的攻击原理与防御</a></strong></p>
<p>与上面一样，配置文件为<code>/etc/apache2/conf-available/security</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Set to one of:  On | Off | extended</span></span><br><span class="line">TraceEnable Off</span><br><span class="line"><span class="comment">#TraceEnable On</span></span><br></pre></td></tr></table></figure>

<h6 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h6><p>建议看<a href="http://httpd.apache.org/docs/2.4/misc/security_tips.html#page-header" target="_blank" rel="noopener">官方建议</a>。</p>
<h6 id="动态内容安全性"><a href="#动态内容安全性" class="headerlink" title="动态内容安全性"></a>动态内容安全性</h6><p>在 Apache中，<a href="http://modsecurity.org/" target="_blank" rel="noopener">mod_security</a>的模块可以被视为 HTTP 防火墙，并且只要配置得足够好，可以</p>
<p>增强动态内容安全性。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>收获很多</p>
<p>感觉实际配置中，使用docker的可能性更大，也相对方便、安全。</p>
]]></content>
      <categories>
        <category>web</category>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>apache2</tag>
        <tag>nginx</tag>
        <tag>ubuntu</tag>
        <tag>信安之路</tag>
        <tag>加固</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻译】what is data mining?</title>
    <url>/2020/04/11/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91What%20is%20data%20minning/</url>
    <content><![CDATA[<h1 id="What-is-data-mining"><a href="#What-is-data-mining" class="headerlink" title="What is data mining?"></a>What is data mining?</h1><blockquote>
<h1 id="什么是数据挖掘？"><a href="#什么是数据挖掘？" class="headerlink" title="什么是数据挖掘？"></a>什么是数据挖掘？</h1></blockquote>
<blockquote>
<p>来源：<a href="https://courses.edx.org/courses/course-v1:AdelaideX+BigDataX+3T2018/courseware/29888fbe204345f682218bdf6754dd23/0b218c7e01e9491c90f79c72900993a7/1?activate_block_id=block-v1%3AAdelaideX%2BBigDataX%2B3T2018%2Btype%40video%2Bblock%40985a01230b8d42bc919d7f33e96eebce" target="_blank" rel="noopener">EDX上的课程BigData Fundamentals中What is data mining一节的字幕</a></p>
<p>部分翻译参考网易有道词典的翻译结果<br>由于笔者水平有限，部分翻译可能不太准确，还望大家不吝指正。</p>
</blockquote>
<p>FRANK NEUMANN: In this video, you will learn some of the basics when considering algorithms for big data.</p>
<blockquote>
<p>在这个视频里，你可以学到有关大数据算法的一些基础知识。</p>
</blockquote>
<p>One of the most frequently used approaches to finding out information from big data is through data mining.</p>
<blockquote>
<p>从大数据中发现信息的最常用的方式之一就是数据挖掘。</p>
</blockquote>
<p>But what is data mining?</p>
<blockquote>
<p>但是什么是数据挖掘呢？</p>
</blockquote>
<p>Most probably you have some ideas on what data mining is about.</p>
<blockquote>
<p>很可能你有一些关于数据挖掘是什么的想法。</p>
</blockquote>
<p>Think about it for a second.</p>
<blockquote>
<p>想一下。</p>
</blockquote>
<p>I want to make your <strong>notion</strong> of data mining precise by providing you the following definition.</p>
<blockquote>
<p>我想通过提供下边的定义来让你对数据挖掘的<strong>概念</strong>更加精确。</p>
</blockquote>
<p>“Data mining is the discovery of ‘models’ for data.”</p>
<blockquote>
<p>“数据挖掘是对数据中‘模型’的发现。”</p>
</blockquote>
<p>A model can be various things, and I would like to show you some examples.</p>
<blockquote>
<p>模型可以是各种各样的东西，在这里我将向你展示一些例子。</p>
</blockquote>
<p>An important example is PageRank by Google, which is used for web search.</p>
<blockquote>
<p>一个重要的例子是Google的用于网页搜索的PageRank。</p>
</blockquote>
<p>It models the importance of web pages in the internet.</p>
<blockquote>
<p>它模拟了互联网上网页的重要性。</p>
</blockquote>
<p>Pages are connected through links in a web graph.</p>
<blockquote>
<p>网页通过网络图中的链接被连接起来。</p>
</blockquote>
<p>In this model, each page is assigned a value that summarises the importance of that page.</p>
<blockquote>
<p>在这个模型里，每个页面被指定了一个概括了这个页面重要性的值。</p>
</blockquote>
<p>I will get to this in greater detail later in the course.</p>
<blockquote>
<p>我会在接下来的课程里更加详细地讨论这个问题。</p>
</blockquote>
<p>But essentially, the number assigned to a specific web page is the probability that a random surfer on the web graph is at this page at any given point in time.</p>
<blockquote>
<p>但从本质上讲，每个特定的网页被指定的数字正是网络图上一个随机的上网者在任何给定时间在这个页面的概率</p>
</blockquote>
<p>A high value means that the web page is an important one.</p>
<blockquote>
<p>高值意味着这个网页很重要。</p>
</blockquote>
<p>In this example, you can see a graph with five nodes and a page rank assigned to every page.</p>
<blockquote>
<p>在这个例子里，你可以看到一个有着五个节点的图和以及每个页面都被指定了一个页面级别。</p>
</blockquote>
<img src="https://img2020.cnblogs.com/blog/1598033/202004/1598033-20200411145957147-255466795.png" alt="包含五个节点的网络图" style="zoom:33%;" />

<p>It can be observed that the central node, which has many incoming links, gets a higher score than the nodes that have not that many pages pointing to them.</p>
<blockquote>
<p>我们可以看到中间节点（有着许多传入链接），比那些没有很多页面指向它们的节点获得了更高的分数。</p>
</blockquote>
<p>In this sense, a page rank of a page is high if it is regarded as important by other pages that link to it.</p>
<blockquote>
<p>从这个意义上讲，如果一个网页被链接到它的其他页面认为很重要，则它的页面级别就会很高。</p>
</blockquote>
<p>Having the importance of web pages modelled in this way - one score per page - allows algorithms to judge the importance of pages as part of an internet search engine.</p>
<blockquote>
<p>以这样的方式来模拟网页的重要性—一个页面对应一个分数—允许算法去判断作为互联网搜索引擎的一部分的网页的重要性。</p>
</blockquote>
<p>As another example of data model, I’d like to look at the performance of algorithms.</p>
<blockquote>
<p>作为另一个有关数据模型的例子，我想看看一下算法的性能。</p>
</blockquote>
<p>Let’s say you have designed an algorithm and have run it on various <strong>benchmarks</strong>.</p>
<blockquote>
<p>比如说你设计了一个算法，并在各种<strong>基准</strong>上运行了它。</p>
</blockquote>
<p>To make things simple, assume that all benchmark instances have the same size - let’s say graphs of 10,000 nodes.</p>
<blockquote>
<p>简单来说，假定所有基准实例都同样大—比如说有着10000节点的图。</p>
</blockquote>
<p>The runtime of your algorithm on one particular benchmark instance would be measured in milliseconds.</p>
<blockquote>
<p>算法在一个特定基准实例上的运行时间将以毫秒位单位测量。</p>
</blockquote>
<p>Running your algorithm on each benchmark instance gives you a set of numbers characterising the runtime behaviour.</p>
<blockquote>
<p>在每个基准实例上运行算法可以得出一组描述运行时行为的数字。</p>
</blockquote>
<p>If you have done many runs of your algorithm, you might want to have a more <strong>compact</strong> model of your runtime data.</p>
<blockquote>
<p>如果你将算法运行了很多遍，你可能会想要一个更<strong>紧凑</strong>的用于运行时数据模型。</p>
</blockquote>
<p>If you assume that the data comes from a Gaussian distribution, then the model can be given by the average of these numbers together with its standard deviation.</p>
<blockquote>
<p>如果假设数据来自高斯分布，那么模型可以由这些数字的平均值及其标准差给出。</p>
</blockquote>
<p>This chart shows different Gaussian in distributions - all have mean 100.</p>
<blockquote>
<p>这张图显示了不同的高斯分布—它们的平均值都是100</p>
</blockquote>
<p>Three distributions having standard deviation 5, 10, and 15 are shown.</p>
<img src="https://img2020.cnblogs.com/blog/1598033/202004/1598033-20200411150112760-1140467519.png" alt="高斯分布" style="zoom:33%;" />

<blockquote>
<p>其中三个分布的标准差分别是5，10和15。</p>
</blockquote>
<p>You can observe that the distributions have higher concentration around the mean if the standard deviation is small.</p>
<blockquote>
<p>你可以看到如果分布的标准差更小，它在平均值附近就会更集中。</p>
</blockquote>
<p>If your data consists of a lot of data points - let’s say a billion - in a particular application, then describing your data by just two <strong>parameters</strong>, average and standard deviation, gives a very <strong>compact</strong> description.</p>
<blockquote>
<p>如果在一个特定的应用中，你的数据中包含了大量的数据点（比如说一百万个），那么只需要平均值和标准差这两个<strong>参数</strong>来描述数据就可以得出一个非常<strong>紧凑</strong>的描述。</p>
</blockquote>
<p>Having a compact description of your data is useful because you can easily implement algorithms that <strong>exploit</strong> the model.</p>
<blockquote>
<p>有一个紧凑的数据描述是有用的，因为你可以轻松地实现利用这个模型的算法。</p>
</blockquote>
<p>You will see this throughout the course.</p>
<blockquote>
<p>你将在整个课程中看到这一点。</p>
</blockquote>
<p>Next, you will be looking at how to make data mining models more precise and discuss different ways of modelling data in detail.</p>
<blockquote>
<p>接下来，你将看到如何让数据挖掘模型更精确，并详细讨论不同的数据建模方式。</p>
</blockquote>
]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>大数据</tag>
        <tag>数据挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title>RSP_Blog来啦【置顶】</title>
    <url>/2020/02/13/RSP_Blog%E6%9D%A5%E5%95%A6%EF%BC%81/</url>
    <content><![CDATA[<h1 id="RSP-Blog来啦！"><a href="#RSP-Blog来啦！" class="headerlink" title="RSP_Blog来啦！"></a>RSP_Blog来啦！</h1><p>2月10日，我们正式推出了RSP_of_CUMTCS项目，即矿大计算机学院资源共享计划。今天，作为RSP一部分的RSP_Blog也上线啦！</p>
<h1 id="借助这个平台，我们打算干这些事儿"><a href="#借助这个平台，我们打算干这些事儿" class="headerlink" title="借助这个平台，我们打算干这些事儿"></a>借助这个平台，我们打算干这些事儿</h1><ul>
<li>广泛的向同学们进行征稿<ul>
<li>稿子可以是同学们新写的，也可以是大家已经发布到自己博客上的</li>
<li>在本博客建立初期，我们对博客内容没有明确的要求，只要是大家觉得对其他同学有用的稿子，都可以来投递给我们。</li>
</ul>
</li>
<li>尽可能更多的去联系一些拥有个人博客的同学，在征求到他们同意的情况下，在本站放置他们博客的链接。</li>
<li>待到时机成熟，举办主题技术类征文活动</li>
</ul>
<h1 id="我们希望这个博客之于计算机学院全体同学的意义是："><a href="#我们希望这个博客之于计算机学院全体同学的意义是：" class="headerlink" title="我们希望这个博客之于计算机学院全体同学的意义是："></a>我们希望这个博客之于计算机学院全体同学的意义是：</h1><ul>
<li>提供一个拓展视野、交流提升的平台</li>
<li>营造一个信息畅通，同学们互帮互助的学习氛围</li>
<li>争取形成属于咱们学院自己的骄傲的极客风！</li>
</ul>
<h1 id="我们期待着大家的投稿"><a href="#我们期待着大家的投稿" class="headerlink" title="我们期待着大家的投稿"></a>我们期待着大家的投稿</h1><h2 id="投稿方式"><a href="#投稿方式" class="headerlink" title="投稿方式"></a>投稿方式</h2><ul>
<li>向学习部的GitHub账户下的<a href="https://github.com/cumtcssuld/RSP_Blog_Contribution" target="_blank" rel="noopener">RSP_Blog_Contribution</a>库提交pull request。</li>
<li>向学习菌QQ号投稿,学习菌QQ号为：1390274240。</li>
<li>发送邮件到<a href="mailto:cumtcssuld@foxmail.com">学习部邮箱</a>。</li>
</ul>
<h2 id="稿件要求"><a href="#稿件要求" class="headerlink" title="稿件要求"></a>稿件要求</h2><ul>
<li>格式为markdown格式</li>
<li>若使用了图片，请在markdown中嵌入已经上传到其他平台的在线图片链接，或在markdown文件中使用<strong>相对链接</strong>，并将图片和<code>.md</code>文件一并打包发给我们</li>
<li>请尽可能的给文章打上几个标签</li>
</ul>
<p>CUMTCSSULD（矿大计算机学院学生会学习部）　2020年2月13日</p>
]]></content>
      <categories>
        <category>博客管理</category>
      </categories>
      <tags>
        <tag>RSP_Blog</tag>
        <tag>博客上线啦</tag>
      </tags>
  </entry>
</search>
